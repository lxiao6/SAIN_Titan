<!--
RSS generated by JIRA (7.6.3#76005-sha1:8a4e38d34af948780dbf52044e7aafb13a7cae58) at Mon Jan 21 19:26:33 UTC 2019

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<!-- If you wish to do custom client-side styling of RSS, uncomment this:
<?xml-stylesheet href="https://issues.apache.org/jira/styles/jiraxml2html.xsl" type="text/xsl"?>
-->
<rss version="0.92">
    <channel>
        <title>ASF JIRA</title>
        <link>https://issues.apache.org/jira/issues/?jql=project+%3D+AVRO+AND+created+%3E%3D+2018-4-25+AND+created+%3C%3D+2018-5-2+ORDER+BY+key+ASC</link>
        <description>An XML representation of a search request</description>
                <language>en-uk</language>
                        <issue start="0" end="1" total="1"/>
                <build-info>
            <version>7.6.3</version>
            <build-number>76005</build-number>
            <build-date>09-01-2018</build-date>
        </build-info>

<item>
            <title>[AVRO-2172] Avro over gRPC (Java Implementation)</title>
                <link>https://issues.apache.org/jira/browse/AVRO-2172</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;We (wavefront/VMware) have implemented a java library/module for using RPC defined using Avro (.avdl/.avpr) over gRPC, and would like to contribute this to Apache Avro. gRPC provides ability to build streaming RPC and also in terms of Java implementation its built on recent version of Netty (4.x). &#160;&lt;/p&gt;

&lt;p&gt;Overview of our Avro-gRPC Java Implementation:&lt;/p&gt;

&lt;p&gt;gRPC by default provides support for Protobuf &#160;IDL and the APIs are tuned towards it. Following are main differences in gRPC API/Protobuf and Avro&apos;s RPC IDL that our library bridges:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Protobuf/gRPC supports only single argument for RPC request vs Avro&apos;s multiple arguments. This is handled in serialization logic.&lt;/li&gt;
	&lt;li&gt;Protobuf/gRPC does not support throwing typed exceptions over wire natively. Avro&#8217;s typed RPC exceptions are handled in the serialization logic.&lt;/li&gt;
	&lt;li&gt;Protobuf/gRPC does not support one-way RPC. We don&#8217;t avoid doing round-trip to server but respond back with null response as soon as request is received at server, and then invoke the server implementation.&lt;/li&gt;
	&lt;li&gt;gRPC provides RPC code generation for Protobuf. For Avro, we use the current minimal code generation, and provide Client and Server Invocation handlers.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Can we have this as a new artifact/maven child project in Avro Java project with a name something like `avro-grpc` ?&lt;/p&gt;</description>
                <environment></environment>
        <key id="13155799">AVRO-2172</key>
            <summary>Avro over gRPC (Java Implementation)</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21141&amp;avatarType=issuetype">New Feature</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="srujann">Srujan Narkedamalli</assignee>
                                    <reporter username="srujann">Srujan Narkedamalli</reporter>
                        <labels>
                    </labels>
                <created>Fri, 27 Apr 2018 20:50:40 +0000</created>
                <updated>Thu, 3 May 2018 20:45:50 +0000</updated>
                            <resolved>Wed, 2 May 2018 17:42:23 +0000</resolved>
                                                    <fixVersion>1.9.0</fixVersion>
                                    <component>java</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="16459825" author="cutting" created="Tue, 1 May 2018 16:31:12 +0000"  >&lt;p&gt;This would be a wonderful addition to Apache Avro!&lt;/p&gt;

&lt;p&gt;Can you add it under lang/java in the Avro source tree and submit a pull request on GitHub?&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="16460500" author="githubbot" created="Wed, 2 May 2018 04:08:47 +0000"  >&lt;p&gt;srujann opened a new pull request #308: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2172&quot; title=&quot;Avro over gRPC (Java Implementation)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2172&quot;&gt;&lt;del&gt;AVRO-2172&lt;/del&gt;&lt;/a&gt;: Avro binding for gRPC (Java Implementation)&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/308&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/308&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   To enable avro based schema and RPC IDL to be transported over gRPC.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16460501" author="srujann" created="Wed, 2 May 2018 04:12:27 +0000"  >&lt;p&gt;Thank you, Submitted a pull request&#160;on Github.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The PR proposes a new maven module &quot;avro-grpc&quot;. Added the Apache license to all the files and made sure the build passes the tests.&lt;/p&gt;</comment>
                            <comment id="16461359" author="githubbot" created="Wed, 2 May 2018 17:34:02 +0000"  >&lt;p&gt;cutting closed pull request #308: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2172&quot; title=&quot;Avro over gRPC (Java Implementation)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2172&quot;&gt;&lt;del&gt;AVRO-2172&lt;/del&gt;&lt;/a&gt;: Avro binding for gRPC (Java Implementation)&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/308&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/308&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/lang/java/grpc/pom.xml b/lang/java/grpc/pom.xml&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..a64d8cd54&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/pom.xml&lt;br/&gt;
@@ -0,0 +1,109 @@&lt;br/&gt;
+&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;
+&amp;lt;!--&lt;br/&gt;
+   Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+   contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
+   this work for additional information regarding copyright ownership.&lt;br/&gt;
+   The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+   (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+   the License.  You may obtain a copy of the License at&lt;br/&gt;
+&lt;br/&gt;
+       &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+&lt;br/&gt;
+   Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+   See the License for the specific language governing permissions and&lt;br/&gt;
+   limitations under the License.&lt;br/&gt;
+--&amp;gt;&lt;br/&gt;
+&amp;lt;project&lt;br/&gt;
+  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 &lt;a href=&quot;http://maven.apache.org/xsd/maven-4.0.0.xsd&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://maven.apache.org/xsd/maven-4.0.0.xsd&lt;/a&gt;&quot;&lt;br/&gt;
+  xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&amp;gt;&lt;br/&gt;
+  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;parent&amp;gt;&lt;br/&gt;
+    &amp;lt;groupId&amp;gt;org.apache.avro&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+    &amp;lt;artifactId&amp;gt;avro-parent&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+    &amp;lt;version&amp;gt;1.9.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;br/&gt;
+    &amp;lt;relativePath&amp;gt;../&amp;lt;/relativePath&amp;gt;&lt;br/&gt;
+  &amp;lt;/parent&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;artifactId&amp;gt;avro-grpc&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;name&amp;gt;Apache Avro gRPC&amp;lt;/name&amp;gt;&lt;br/&gt;
+  &amp;lt;description&amp;gt;Avro IDL based RPC and serialization over gRPC&amp;lt;/description&amp;gt;&lt;br/&gt;
+  &amp;lt;packaging&amp;gt;bundle&amp;lt;/packaging&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;properties&amp;gt;&lt;br/&gt;
+    &amp;lt;osgi.import&amp;gt;&lt;br/&gt;
+      !org.apache.avro.grpc*,&lt;br/&gt;
+      org.apache.avro*;version=&quot;${project.version}&quot;,&lt;br/&gt;
+      io.grpc*&lt;br/&gt;
+      *&lt;br/&gt;
+    &amp;lt;/osgi.import&amp;gt;&lt;br/&gt;
+    &amp;lt;osgi.export&amp;gt;org.apache.avro.grpc*;version=&quot;${project.version}&quot;&amp;lt;/osgi.export&amp;gt;&lt;br/&gt;
+  &amp;lt;/properties&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;build&amp;gt;&lt;br/&gt;
+    &amp;lt;resources&amp;gt;&lt;br/&gt;
+      &amp;lt;resource&amp;gt;&lt;br/&gt;
+        &amp;lt;directory&amp;gt;src/main/velocity&amp;lt;/directory&amp;gt;&lt;br/&gt;
+      &amp;lt;/resource&amp;gt;&lt;br/&gt;
+    &amp;lt;/resources&amp;gt;&lt;br/&gt;
+    &amp;lt;plugins&amp;gt;&lt;br/&gt;
+      &amp;lt;plugin&amp;gt;&lt;br/&gt;
+        &amp;lt;groupId&amp;gt;${project.groupId}&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+        &amp;lt;artifactId&amp;gt;avro-maven-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+        &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+        &amp;lt;executions&amp;gt;&lt;br/&gt;
+          &amp;lt;execution&amp;gt;&lt;br/&gt;
+            &amp;lt;id&amp;gt;schemas&amp;lt;/id&amp;gt;&lt;br/&gt;
+            &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;&lt;br/&gt;
+            &amp;lt;goals&amp;gt;&lt;br/&gt;
+              &amp;lt;goal&amp;gt;schema&amp;lt;/goal&amp;gt;&lt;br/&gt;
+              &amp;lt;goal&amp;gt;protocol&amp;lt;/goal&amp;gt;&lt;br/&gt;
+              &amp;lt;goal&amp;gt;idl-protocol&amp;lt;/goal&amp;gt;&lt;br/&gt;
+            &amp;lt;/goals&amp;gt;&lt;br/&gt;
+            &amp;lt;configuration&amp;gt;&lt;br/&gt;
+              &amp;lt;stringType&amp;gt;String&amp;lt;/stringType&amp;gt;&lt;br/&gt;
+              &amp;lt;testSourceDirectory&amp;gt;${project.basedir}/src/test/avro&amp;lt;/testSourceDirectory&amp;gt;&lt;br/&gt;
+              &amp;lt;testOutputDirectory&amp;gt;${project.build.directory}/generated-test-sources/java&amp;lt;/testOutputDirectory&amp;gt;&lt;br/&gt;
+            &amp;lt;/configuration&amp;gt;&lt;br/&gt;
+          &amp;lt;/execution&amp;gt;&lt;br/&gt;
+        &amp;lt;/executions&amp;gt;&lt;br/&gt;
+      &amp;lt;/plugin&amp;gt;&lt;br/&gt;
+    &amp;lt;/plugins&amp;gt;&lt;br/&gt;
+  &amp;lt;/build&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;dependencies&amp;gt;&lt;br/&gt;
+    &amp;lt;dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+      &amp;lt;artifactId&amp;gt;grpc-stub&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+      &amp;lt;version&amp;gt;${grpc.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+    &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+    &amp;lt;dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+      &amp;lt;artifactId&amp;gt;grpc-netty&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+      &amp;lt;version&amp;gt;${grpc.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+      &amp;lt;!-- use netty only for tests as user can use grpc transports other than Netty --&amp;gt;&lt;br/&gt;
+      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&lt;br/&gt;
+    &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+    &amp;lt;dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;groupId&amp;gt;${project.groupId}&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+      &amp;lt;artifactId&amp;gt;avro&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+      &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+    &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+    &amp;lt;dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;groupId&amp;gt;${project.groupId}&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+      &amp;lt;artifactId&amp;gt;avro-ipc&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+      &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+      &amp;lt;!-- exclude all dependencies from avro-ipc as only Callback class is needed --&amp;gt;&lt;br/&gt;
+      &amp;lt;exclusions&amp;gt;&lt;br/&gt;
+        &amp;lt;exclusion&amp;gt;&lt;br/&gt;
+          &amp;lt;groupId&amp;gt;*&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+          &amp;lt;artifactId&amp;gt;*&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;
+      &amp;lt;/exclusions&amp;gt;&lt;br/&gt;
+    &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+  &amp;lt;/dependencies&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+&amp;lt;/project&amp;gt;&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcClient.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcClient.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..f0e7d22f6&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcClient.java&lt;br/&gt;
@@ -0,0 +1,167 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import com.google.common.base.Throwables;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.AvroRemoteException;&lt;br/&gt;
+import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+import org.apache.avro.ipc.CallFuture;&lt;br/&gt;
+import org.apache.avro.ipc.Callback;&lt;br/&gt;
+&lt;br/&gt;
+import java.lang.reflect.InvocationHandler;&lt;br/&gt;
+import java.lang.reflect.Method;&lt;br/&gt;
+import java.lang.reflect.Proxy;&lt;br/&gt;
+import java.lang.reflect.Type;&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.CallOptions;&lt;br/&gt;
+import io.grpc.Channel;&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+import io.grpc.stub.ClientCalls;&lt;br/&gt;
+import io.grpc.stub.StreamObserver;&lt;br/&gt;
+&lt;br/&gt;
+/** Component that sets up a gRPC client for Avro&apos;s IDL and Serialization. */&lt;br/&gt;
+public abstract class AvroGrpcClient {&lt;br/&gt;
+&lt;br/&gt;
+  private AvroGrpcClient() &lt;/p&gt;
{
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates a gRPC client for Avro&apos;s interface with default {@link CallOptions}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param channel the channel used for gRPC {@link ClientCalls}.&lt;br/&gt;
+   * @param iface   Avro interface for which client is built.&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt;     type of Avro Interface.&lt;br/&gt;
+   * @return a new client proxy.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static &amp;lt;T&amp;gt; T create(Channel channel, Class&amp;lt;T&amp;gt; iface) {
+    return create(channel, iface, CallOptions.DEFAULT);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates a gRPC client for Avro&apos;s interface with provided {@link CallOptions}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param channel     the channel used for gRPC {@link ClientCalls}.&lt;br/&gt;
+   * @param iface       Avro interface for which client is built.&lt;br/&gt;
+   * @param callOptions client call options for gRPC.&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt;         type of Avro Interface.&lt;br/&gt;
+   * @return a new client proxy.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static &amp;lt;T&amp;gt; T create(Channel channel, Class&amp;lt;T&amp;gt; iface, CallOptions&lt;br/&gt;
+      callOptions) {&lt;br/&gt;
+    Protocol protocol = AvroGrpcUtils.getProtocol(iface);&lt;br/&gt;
+    ServiceDescriptor serviceDescriptor = ServiceDescriptor.create(iface);&lt;br/&gt;
+    ServiceInvocationHandler proxyHandler = new ServiceInvocationHandler(channel, callOptions,&lt;br/&gt;
+        protocol, serviceDescriptor);&lt;br/&gt;
+    return (T) Proxy.newProxyInstance(iface.getClassLoader(), new Class[]{iface}, proxyHandler);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private static class ServiceInvocationHandler implements InvocationHandler {&lt;br/&gt;
+    private final Channel channel;&lt;br/&gt;
+    private final CallOptions callOptions;&lt;br/&gt;
+    private final Protocol protocol;&lt;br/&gt;
+    private final ServiceDescriptor serviceDescriptor;&lt;br/&gt;
+&lt;br/&gt;
+    ServiceInvocationHandler(Channel channel, CallOptions callOptions, Protocol&lt;br/&gt;
+        protocol, ServiceDescriptor serviceDescriptor) {
+      this.channel = channel;
+      this.callOptions = callOptions;
+      this.protocol = protocol;
+      this.serviceDescriptor = serviceDescriptor;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {&lt;br/&gt;
+      try {
+        return invokeUnaryMethod(method, args);
+      } catch (Exception e) {&lt;br/&gt;
+        //throw any of the declared exceptions&lt;br/&gt;
+        for (Class&amp;lt;?&amp;gt; exceptionClass : method.getExceptionTypes()) {
+          Throwables.propagateIfInstanceOf(e, (Class&amp;lt;Exception&amp;gt;) exceptionClass);
+        }&lt;br/&gt;
+        //also throw if any runtime exception&lt;br/&gt;
+        Throwables.propagateIfInstanceOf(e, RuntimeException.class);&lt;br/&gt;
+        //wrap all other exceptions&lt;br/&gt;
+        throw new AvroRemoteException(e);&lt;br/&gt;
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private Object invokeUnaryMethod(Method method, Object[] args) throws Exception {&lt;br/&gt;
+      Type[] parameterTypes = method.getParameterTypes();&lt;br/&gt;
+      if ((parameterTypes.length &amp;gt; 0) &amp;amp;&amp;amp;&lt;br/&gt;
+          (parameterTypes&lt;span class=&quot;error&quot;&gt;&amp;#91;parameterTypes.length - 1&amp;#93;&lt;/span&gt; instanceof Class) &amp;amp;&amp;amp;&lt;br/&gt;
+          Callback.class.isAssignableFrom(((Class&amp;lt;?&amp;gt;) parameterTypes&lt;span class=&quot;error&quot;&gt;&amp;#91;parameterTypes.length - 1&amp;#93;&lt;/span&gt;))) {
+        // get the callback argument from the end
+        Object[] finalArgs = Arrays.copyOf(args, args.length - 1);
+        Callback&amp;lt;?&amp;gt; callback = (Callback&amp;lt;?&amp;gt;) args[args.length - 1];
+        unaryRequest(method.getName(), finalArgs, callback);
+        return null;
+      } else {
+        return unaryRequest(method.getName(), args);
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private Object unaryRequest(String methodName, Object[] args) throws Exception {&lt;br/&gt;
+      CallFuture&amp;lt;Object&amp;gt; callFuture = new CallFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+      unaryRequest(methodName, args, callFuture);&lt;br/&gt;
+      try {
+        return callFuture.get();
+      } catch (Exception e) {
+        Throwables.propagateIfInstanceOf(e.getCause(), Exception.class);
+        throw new AvroRemoteException(e.getCause());
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private &amp;lt;RespT&amp;gt; void unaryRequest(String methodName, Object[] args, Callback&amp;lt;RespT&amp;gt; callback) throws&lt;br/&gt;
+        Exception {
+      StreamObserver&amp;lt;Object&amp;gt; observerAdpater = new CallbackToResponseStreamObserverAdpater&amp;lt;&amp;gt;
+          (callback);
+      ClientCalls.asyncUnaryCall(channel.newCall(serviceDescriptor.getMethod(methodName,
+          MethodDescriptor.MethodType.UNARY), callOptions), args, observerAdpater);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private static class CallbackToResponseStreamObserverAdpater&amp;lt;T&amp;gt; implements StreamObserver&amp;lt;Object&amp;gt; {&lt;br/&gt;
+      private final Callback&amp;lt;T&amp;gt; callback;&lt;br/&gt;
+&lt;br/&gt;
+      CallbackToResponseStreamObserverAdpater(Callback&amp;lt;T&amp;gt; callback) {
+        this.callback = callback;
+      }&lt;br/&gt;
+&lt;br/&gt;
+      @Override&lt;br/&gt;
+      public void onNext(Object value) {&lt;br/&gt;
+        if (value instanceof Throwable) {
+          callback.handleError((Throwable) value);
+        } else {
+          callback.handleResult((T) value);
+        }&lt;br/&gt;
+      }&lt;br/&gt;
+&lt;br/&gt;
+      @Override&lt;br/&gt;
+      public void onError(Throwable t) {
+        callback.handleError(new AvroRuntimeException(t));
+      }&lt;br/&gt;
+&lt;br/&gt;
+      @Override&lt;br/&gt;
+      public void onCompleted() {
+        // do nothing as there is no equivalent in Callback.
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcServer.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcServer.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..c18822ee4&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcServer.java&lt;br/&gt;
@@ -0,0 +1,120 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import com.google.common.base.Throwables;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+&lt;br/&gt;
+import java.lang.reflect.InvocationTargetException;&lt;br/&gt;
+import java.lang.reflect.Method;&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.logging.Level;&lt;br/&gt;
+import java.util.logging.Logger;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+import io.grpc.ServerServiceDefinition;&lt;br/&gt;
+import io.grpc.stub.ServerCalls;&lt;br/&gt;
+import io.grpc.stub.StreamObserver;&lt;br/&gt;
+&lt;br/&gt;
+/** Provides components to set up a gRPC Server for Avro&apos;s IDL and serialization. */&lt;br/&gt;
+public abstract class AvroGrpcServer {&lt;br/&gt;
+&lt;br/&gt;
+  private AvroGrpcServer() {+  }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates a &lt;/p&gt;
{@link ServerServiceDefinition}
&lt;p&gt; for Avro Interface and its implementation that can&lt;br/&gt;
+   * be passed a gRPC Server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface Avro generated RPC service interface for which service defintion is created.&lt;br/&gt;
+   * @param impl  Implementation of the service interface to be invoked for requests.&lt;br/&gt;
+   * @return a new server service definition.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static ServerServiceDefinition createServiceDefinition(Class iface, Object impl) {&lt;br/&gt;
+    Protocol protocol = AvroGrpcUtils.getProtocol(iface);&lt;br/&gt;
+    ServiceDescriptor serviceDescriptor = ServiceDescriptor.create(iface);&lt;br/&gt;
+    ServerServiceDefinition.Builder serviceDefinitionBuilder = ServerServiceDefinition.builder&lt;br/&gt;
+        (serviceDescriptor.getServiceName());&lt;br/&gt;
+    Map&amp;lt;String, Protocol.Message&amp;gt; messages = protocol.getMessages();&lt;br/&gt;
+    for (Method method : iface.getMethods()) {&lt;br/&gt;
+      Protocol.Message msg = messages.get(method.getName());&lt;br/&gt;
+      //setup a method handler only if corresponding message exists in avro protocol.&lt;br/&gt;
+      if (msg != null) &lt;/p&gt;
{
+        UnaryMethodHandler methodHandler = msg.isOneWay() ? new OneWayUnaryMethodHandler(impl,
+            method) : new UnaryMethodHandler(impl, method);
+        serviceDefinitionBuilder.addMethod(serviceDescriptor.getMethod(method.getName(),
+            MethodDescriptor.MethodType.UNARY), ServerCalls.asyncUnaryCall(methodHandler));
+      }
&lt;p&gt;+    }&lt;br/&gt;
+    return serviceDefinitionBuilder.build();&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private static class UnaryMethodHandler implements ServerCalls.UnaryMethod&amp;lt;Object[], Object&amp;gt; {&lt;br/&gt;
+    private final Object serviceImpl;&lt;br/&gt;
+    private final Method method;&lt;br/&gt;
+&lt;br/&gt;
+    UnaryMethodHandler(Object serviceImpl, Method method) &lt;/p&gt;
{
+      this.serviceImpl = serviceImpl;
+      this.method = method;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public void invoke(Object[] request, StreamObserver&amp;lt;Object&amp;gt; responseObserver) {&lt;br/&gt;
+      Object methodResponse = null;&lt;br/&gt;
+      try &lt;/p&gt;
{
+        methodResponse = method.invoke(getServiceImpl(), request);
+      }
&lt;p&gt; catch (InvocationTargetException e) &lt;/p&gt;
{
+        methodResponse = e.getTargetException();
+      }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
+        methodResponse = e;
+      }
&lt;p&gt;+      responseObserver.onNext(methodResponse);&lt;br/&gt;
+      responseObserver.onCompleted();&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public Method getMethod() &lt;/p&gt;
{
+      return method;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public Object getServiceImpl() &lt;/p&gt;
{
+      return serviceImpl;
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  private static class OneWayUnaryMethodHandler extends UnaryMethodHandler {&lt;br/&gt;
+    private static final Logger LOG = Logger.getLogger(OneWayUnaryMethodHandler.class.getName());&lt;br/&gt;
+&lt;br/&gt;
+    OneWayUnaryMethodHandler(Object serviceImpl, Method method) &lt;/p&gt;
{
+      super(serviceImpl, method);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void invoke(Object[] request, StreamObserver&amp;lt;Object&amp;gt; responseObserver) {&lt;br/&gt;
+      //first respond back with a fixed void response in order for call to be complete&lt;br/&gt;
+      responseObserver.onNext(null);&lt;br/&gt;
+      responseObserver.onCompleted();&lt;br/&gt;
+      //process the rpc request&lt;br/&gt;
+      try &lt;/p&gt;
{
+        getMethod().invoke(getServiceImpl(), request);
+      }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
+        LOG.log(Level.WARNING, &quot;Error processing one-way rpc&quot;, Throwables.getRootCause(e));
+      }
&lt;p&gt;+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcUtils.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcUtils.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..f3ab07bc7&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcUtils.java&lt;br/&gt;
@@ -0,0 +1,85 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.util.logging.Level;&lt;br/&gt;
+import java.util.logging.Logger;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.KnownLength;&lt;br/&gt;
+&lt;br/&gt;
+/** Utility methods for using Avro IDL and serialization with gRPC. */&lt;br/&gt;
+public final class AvroGrpcUtils {&lt;br/&gt;
+  private static Logger log = Logger.getLogger(AvroGrpcUtils.class.getName());&lt;br/&gt;
+&lt;br/&gt;
+  private AvroGrpcUtils() &lt;/p&gt;
{
+  }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Provides a a unique gRPC service name for Avro RPC interface or its subclass Callback&lt;br/&gt;
+   * Interface.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface Avro RPC interface.&lt;br/&gt;
+   * @return unique service name for gRPC.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static String getServiceName(Class iface) &lt;/p&gt;
{
+    Protocol protocol = getProtocol(iface);
+    return protocol.getNamespace() + &quot;.&quot; + protocol.getName();
+  }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets the &lt;/p&gt;
{@link Protocol} from the Avro Interface.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static Protocol getProtocol(Class iface) {&lt;br/&gt;
+    try {
+      Protocol p = (Protocol) (iface.getDeclaredField(&quot;PROTOCOL&quot;).get(null));
+      return p;
+    } catch (NoSuchFieldException e) {
+      throw new AvroRuntimeException(&quot;Not a Specific protocol: &quot; + iface);
+    } catch (IllegalAccessException e) {
+      throw new AvroRuntimeException(e);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Skips any unread bytes from InputStream and closes it.&lt;br/&gt;
+   */&lt;br/&gt;
+  static void skipAndCloseQuietly(InputStream stream) {&lt;br/&gt;
+    try {&lt;br/&gt;
+      if (stream instanceof KnownLength &amp;amp;&amp;amp; stream.available() &amp;gt; 0) {
+        stream.skip(stream.available());
+      } else {&lt;br/&gt;
+        //don&apos;t expect this for an inputStream provided by gRPC but just to be on safe side.&lt;br/&gt;
+        byte[] skipBuffer = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;4096&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+        while (true) {&lt;br/&gt;
+          int read = stream.read(skipBuffer);&lt;br/&gt;
+          if (read &amp;lt; skipBuffer.length) {
+            break;
+          }&lt;br/&gt;
+        }&lt;br/&gt;
+      }&lt;br/&gt;
+      stream.close();&lt;br/&gt;
+    } catch (Exception e) {
+      log.log(Level.WARNING, &quot;failed to skip/close the input stream, may cause memory leak&quot;, e);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroInputStream.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroInputStream.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..79793ee6c&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroInputStream.java&lt;br/&gt;
@@ -0,0 +1,103 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.ByteArrayInputStream;&lt;br/&gt;
+import java.io.ByteArrayOutputStream;&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.io.OutputStream;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.NotThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.Drainable;&lt;br/&gt;
+&lt;br/&gt;
+/** An {@link InputStream} backed by Avro RPC request/response that can drained to&lt;br/&gt;
+ * a{@link OutputStream}. */&lt;br/&gt;
+@NotThreadSafe&lt;br/&gt;
+public abstract class AvroInputStream extends InputStream implements Drainable {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Container to hold the serialized Avro payload when its read before draining it.&lt;br/&gt;
+   */&lt;br/&gt;
+  @Nullable&lt;br/&gt;
+  private ByteArrayInputStream partial;&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public int read(byte[] b, int off, int len) throws IOException {
+    return getPartialInternal().read(b, off, len);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public int read() throws IOException {
+    return getPartialInternal().read();
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private ByteArrayInputStream getPartialInternal() throws IOException {&lt;br/&gt;
+    if (partial == null) {
+      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+      drainTo(outputStream);
+      partial = new ByteArrayInputStream(outputStream.toByteArray());
+    }&lt;br/&gt;
+    return partial;&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  protected ByteArrayInputStream getPartial() {
+    return partial;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * An {@link OutputStream} that writes to a target {@link OutputStream} and provides total&lt;br/&gt;
+   * number of bytes written to it.&lt;br/&gt;
+   */&lt;br/&gt;
+  protected class CountingOutputStream extends OutputStream {&lt;br/&gt;
+    private final OutputStream target;&lt;br/&gt;
+    private int writtenCount = 0;&lt;br/&gt;
+&lt;br/&gt;
+    public CountingOutputStream(OutputStream target) {
+      this.target = target;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void write(byte[] b, int off, int len) throws IOException {
+      target.write(b, off, len);
+      writtenCount += len;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void write(int b) throws IOException {
+      target.write(b);
+      writtenCount += 1;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void flush() throws IOException {
+      target.flush();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void close() throws IOException {
+      target.close();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public int getWrittenCount() {
+      return writtenCount;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroRequestMarshaller.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroRequestMarshaller.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..618e2af5a&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroRequestMarshaller.java&lt;br/&gt;
@@ -0,0 +1,106 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+import org.apache.avro.Schema;&lt;br/&gt;
+import org.apache.avro.generic.GenericRecord;&lt;br/&gt;
+import org.apache.avro.io.BinaryDecoder;&lt;br/&gt;
+import org.apache.avro.io.BinaryEncoder;&lt;br/&gt;
+import org.apache.avro.io.DecoderFactory;&lt;br/&gt;
+import org.apache.avro.io.EncoderFactory;&lt;br/&gt;
+import org.apache.avro.specific.SpecificDatumReader;&lt;br/&gt;
+import org.apache.avro.specific.SpecificDatumWriter;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.io.OutputStream;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+import io.grpc.Status;&lt;br/&gt;
+import io.grpc.internal.IoUtils;&lt;br/&gt;
+&lt;br/&gt;
+/** Marshaller for Avro RPC request. */&lt;br/&gt;
+public class AvroRequestMarshaller implements MethodDescriptor.Marshaller&amp;lt;Object[]&amp;gt; {&lt;br/&gt;
+  private static final EncoderFactory ENCODER_FACTORY = new EncoderFactory();&lt;br/&gt;
+  private static final DecoderFactory DECODER_FACTORY = new DecoderFactory();&lt;br/&gt;
+  private final Protocol.Message message;&lt;br/&gt;
+&lt;br/&gt;
+  public AvroRequestMarshaller(Protocol.Message message) {
+    this.message = message;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public InputStream stream(Object[] value) {
+    return new AvroRequestInputStream(value, message);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public Object[] parse(InputStream stream) {&lt;br/&gt;
+    try {&lt;br/&gt;
+      BinaryDecoder in = DECODER_FACTORY.binaryDecoder(stream, null);&lt;br/&gt;
+      Schema reqSchema = message.getRequest();&lt;br/&gt;
+      GenericRecord request = (GenericRecord) new SpecificDatumReader&amp;lt;&amp;gt;(reqSchema).read(null, in);&lt;br/&gt;
+      Object[] args = new Object&lt;span class=&quot;error&quot;&gt;&amp;#91;reqSchema.getFields().size()&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+      int i = 0;&lt;br/&gt;
+      for (Schema.Field field : reqSchema.getFields()) {
+        args[i++] = request.get(field.name());
+      }&lt;br/&gt;
+      return args;&lt;br/&gt;
+    } catch (IOException e) {
+      throw Status.INTERNAL.withCause(e).
+          withDescription(&quot;Error deserializing avro request arguments&quot;).asRuntimeException();
+    } finally {
+      AvroGrpcUtils.skipAndCloseQuietly(stream);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private class AvroRequestInputStream extends AvroInputStream {&lt;br/&gt;
+    private final Protocol.Message message;&lt;br/&gt;
+    @Nullable&lt;br/&gt;
+    private Object[] args;&lt;br/&gt;
+&lt;br/&gt;
+    AvroRequestInputStream(@Nullable Object[] args, Protocol.Message message) {
+      this.args = args;
+      this.message = message;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public int drainTo(OutputStream target) throws IOException {&lt;br/&gt;
+      int written;&lt;br/&gt;
+      if (getPartial() != null) {
+        written = (int) IoUtils.copy(getPartial(), target);
+      } else {&lt;br/&gt;
+        Schema reqSchema = message.getRequest();&lt;br/&gt;
+        CountingOutputStream outputStream = new CountingOutputStream(target);&lt;br/&gt;
+        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(outputStream, null);&lt;br/&gt;
+        int i = 0;&lt;br/&gt;
+        for (Schema.Field param : reqSchema.getFields()) {
+          new SpecificDatumWriter&amp;lt;&amp;gt;(param.schema()).write(args[i++], out);
+        }&lt;br/&gt;
+        out.flush();&lt;br/&gt;
+        args = null;&lt;br/&gt;
+        written = outputStream.getWrittenCount();&lt;br/&gt;
+      }&lt;br/&gt;
+      return written;&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroResponseMarshaller.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroResponseMarshaller.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..f1f9b0145&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroResponseMarshaller.java&lt;br/&gt;
@@ -0,0 +1,133 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+import org.apache.avro.io.BinaryDecoder;&lt;br/&gt;
+import org.apache.avro.io.BinaryEncoder;&lt;br/&gt;
+import org.apache.avro.io.DecoderFactory;&lt;br/&gt;
+import org.apache.avro.io.EncoderFactory;&lt;br/&gt;
+import org.apache.avro.specific.SpecificDatumReader;&lt;br/&gt;
+import org.apache.avro.specific.SpecificDatumWriter;&lt;br/&gt;
+import org.apache.avro.util.Utf8;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.ByteArrayOutputStream;&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.io.OutputStream;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+import io.grpc.Status;&lt;br/&gt;
+import io.grpc.internal.IoUtils;&lt;br/&gt;
+&lt;br/&gt;
+/** Marshaller for Avro RPC response. */&lt;br/&gt;
+public class AvroResponseMarshaller implements MethodDescriptor.Marshaller&amp;lt;Object&amp;gt; {&lt;br/&gt;
+  private static final EncoderFactory ENCODER_FACTORY = new EncoderFactory();&lt;br/&gt;
+  private static final DecoderFactory DECODER_FACTORY = new DecoderFactory();&lt;br/&gt;
+  private final Protocol.Message message;&lt;br/&gt;
+&lt;br/&gt;
+  public AvroResponseMarshaller(Protocol.Message message) {+    this.message = message;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public InputStream stream(Object value) {
+    return new AvroResponseInputStream(value, message);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public Object parse(InputStream stream) {&lt;br/&gt;
+    try {&lt;br/&gt;
+      if (message.isOneWay()) return null;&lt;br/&gt;
+      BinaryDecoder in = DECODER_FACTORY.binaryDecoder(stream, null);&lt;br/&gt;
+      if (!in.readBoolean()) {
+        Object response = new SpecificDatumReader(message.getResponse()).read(null, in);
+        return response;
+      } else {&lt;br/&gt;
+        Object value = new SpecificDatumReader(message.getErrors()).read(null, in);&lt;br/&gt;
+        if (value instanceof Exception) {
+          return value;
+        }&lt;br/&gt;
+        return new AvroRuntimeException(value.toString());&lt;br/&gt;
+      }&lt;br/&gt;
+    } catch (IOException e) {
+      throw Status.INTERNAL.withCause(e).
+          withDescription(&quot;Error deserializing avro response&quot;).asRuntimeException();
+    } finally {
+      AvroGrpcUtils.skipAndCloseQuietly(stream);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private class AvroResponseInputStream extends AvroInputStream {&lt;br/&gt;
+    private final Protocol.Message message;&lt;br/&gt;
+    @Nullable&lt;br/&gt;
+    private Object response;&lt;br/&gt;
+&lt;br/&gt;
+    AvroResponseInputStream(@Nullable Object response, Protocol.Message message) {
+      this.response = response;
+      this.message = message;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public int drainTo(OutputStream target) throws IOException {&lt;br/&gt;
+      int written;&lt;br/&gt;
+      if (getPartial() != null) {
+        written = (int) IoUtils.copy(getPartial(), target);
+      } else {
+        written = writeResponse(target);
+      }&lt;br/&gt;
+      return written;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private int writeResponse(OutputStream target) throws IOException {&lt;br/&gt;
+      int written;&lt;br/&gt;
+      if (message.isOneWay()) {
+        written = 0;
+      } else if (response instanceof Exception) {&lt;br/&gt;
+        ByteArrayOutputStream bao = new ByteArrayOutputStream();&lt;br/&gt;
+        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(bao, null);&lt;br/&gt;
+        try {
+          out.writeBoolean(true);
+          new SpecificDatumWriter(message.getErrors()).write(response, out);
+        } catch (Exception e) {
+          bao = new ByteArrayOutputStream();
+          out = ENCODER_FACTORY.binaryEncoder(bao, null);
+          out.writeBoolean(true);
+          new SpecificDatumWriter(Protocol.SYSTEM_ERRORS).write(new Utf8(e.toString()), out);
+        }&lt;br/&gt;
+        out.flush();&lt;br/&gt;
+        byte[] serializedError = bao.toByteArray();&lt;br/&gt;
+        target.write(serializedError);&lt;br/&gt;
+        written = serializedError.length;&lt;br/&gt;
+      } else {
+        CountingOutputStream outputStream = new CountingOutputStream(target);
+        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(outputStream, null);
+        out.writeBoolean(false);
+        new SpecificDatumWriter(message.getResponse()).write(response, out);
+        out.flush();
+        written = outputStream.getWrittenCount();
+      }&lt;br/&gt;
+      response = null;&lt;br/&gt;
+      return written;&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/ServiceDescriptor.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/ServiceDescriptor.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..d9fa97ab6&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/ServiceDescriptor.java&lt;br/&gt;
@@ -0,0 +1,84 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.ConcurrentMap;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+&lt;br/&gt;
+import static io.grpc.MethodDescriptor.generateFullMethodName;&lt;br/&gt;
+&lt;br/&gt;
+/** Descriptor for a gRPC service based on a Avro interface. */&lt;br/&gt;
+class ServiceDescriptor {&lt;br/&gt;
+&lt;br/&gt;
+  // cache for service descriptors.&lt;br/&gt;
+  private static final ConcurrentMap&amp;lt;String, ServiceDescriptor&amp;gt; SERVICE_DESCRIPTORS =&lt;br/&gt;
+      new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+  private final Class iface;&lt;br/&gt;
+  private final String serviceName;&lt;br/&gt;
+  private final Protocol protocol;&lt;br/&gt;
+  // cache for method descriptors.&lt;br/&gt;
+  private final ConcurrentMap&amp;lt;String, MethodDescriptor&amp;lt;Object[], Object&amp;gt;&amp;gt; methods =&lt;br/&gt;
+      new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+  private ServiceDescriptor(Class iface, String serviceName) {
+    this.iface = iface;
+    this.serviceName = serviceName;
+    this.protocol = AvroGrpcUtils.getProtocol(iface);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates a Service Descriptor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface Avro RPC interface.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static ServiceDescriptor create(Class iface) {
+    String serviceName = AvroGrpcUtils.getServiceName(iface);
+    return SERVICE_DESCRIPTORS.computeIfAbsent(serviceName, key -&amp;gt; new ServiceDescriptor
+        (iface, serviceName));
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * provides name of the service.&lt;br/&gt;
+   */&lt;br/&gt;
+  public String getServiceName() {
+    return serviceName;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Provides a gRPC {@link MethodDescriptor} for a RPC method/message of Avro {@link Protocol}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param methodType gRPC type for the method.&lt;br/&gt;
+   * @return a &lt;/p&gt;
{@link MethodDescriptor}
&lt;p&gt;+   */&lt;br/&gt;
+  public MethodDescriptor&amp;lt;Object[], Object&amp;gt; getMethod(String methodName, MethodDescriptor&lt;br/&gt;
+      .MethodType methodType) &lt;/p&gt;
{
+    return methods.computeIfAbsent(methodName,
+        key -&amp;gt; MethodDescriptor.&amp;lt;Object[], Object&amp;gt;newBuilder()
+            .setFullMethodName(generateFullMethodName(serviceName, methodName))
+            .setType(methodType)
+            .setRequestMarshaller(new AvroRequestMarshaller(protocol.getMessages().get(methodName)))
+            .setResponseMarshaller(
+                new AvroResponseMarshaller(protocol.getMessages().get(methodName)))
+            .build());
+  }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/test/avro/TestService.avdl b/lang/java/grpc/src/test/avro/TestService.avdl&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..8a18db080&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/test/avro/TestService.avdl&lt;br/&gt;
@@ -0,0 +1,54 @@&lt;br/&gt;
+/**&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+/** An example protocol in Avro IDL */&lt;br/&gt;
+@namespace(&quot;org.apache.avro.grpc.test&quot;)&lt;br/&gt;
+protocol TestService {&lt;br/&gt;
+&lt;br/&gt;
+  enum Kind &lt;/p&gt;
{
+    FOO,
+    BAR,
+    BAZ
+  }
&lt;p&gt;+&lt;br/&gt;
+  fixed MD5(4);&lt;br/&gt;
+&lt;br/&gt;
+  record TestRecord {&lt;br/&gt;
+    @order(&quot;ignore&quot;)&lt;br/&gt;
+    string name;&lt;br/&gt;
+&lt;br/&gt;
+    @order(&quot;descending&quot;)&lt;br/&gt;
+    Kind kind;&lt;br/&gt;
+&lt;br/&gt;
+    MD5 hash;&lt;br/&gt;
+&lt;br/&gt;
+    union &lt;/p&gt;
{ MD5, null}
&lt;p&gt; @aliases(&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;hash&amp;quot;&amp;#93;&lt;/span&gt;) nullableHash;&lt;br/&gt;
+&lt;br/&gt;
+    array&amp;lt;long&amp;gt; arrayOfLongs;&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  error TestError &lt;/p&gt;
{
+    string message;
+  }
&lt;p&gt;+&lt;br/&gt;
+  TestRecord echo(TestRecord `record`);&lt;br/&gt;
+  int add(int arg1, int arg2, int arg3);&lt;br/&gt;
+  void `error`(boolean declared) throws TestError;&lt;br/&gt;
+  void ping() oneway;&lt;br/&gt;
+  union &lt;/p&gt;
{null, string}
&lt;p&gt; concatenate(string val1, boolean val2, long val3, int val4);&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroMarshaller.java b/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroMarshaller.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..2efb42f01&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroMarshaller.java&lt;br/&gt;
@@ -0,0 +1,84 @@&lt;br/&gt;
+/**&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+import org.apache.avro.grpc.test.Kind;&lt;br/&gt;
+import org.apache.avro.grpc.test.MD5;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestRecord;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestService;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.ByteArrayInputStream;&lt;br/&gt;
+import java.io.ByteArrayOutputStream;&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.io.OutputStream;&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+import java.util.Random;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.Drainable;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+&lt;br/&gt;
+public class TestAvroMarshaller {&lt;br/&gt;
+  private final TestRecord record = TestRecord.newBuilder().setName(&quot;foo&quot;).setKind(Kind.FOO)&lt;br/&gt;
+      .setArrayOfLongs(Arrays.asList(42L, 424L, 4242L)).setHash(new MD5(new byte[]&lt;/p&gt;
{4, 2, 4, 2}))&lt;br/&gt;
+      .setNullableHash(null).build();&lt;br/&gt;
+  private final Protocol.Message message = TestService.PROTOCOL.getMessages().get(&quot;echo&quot;);&lt;br/&gt;
+  private Random random = new Random();&lt;br/&gt;
+&lt;br/&gt;
+  private void readPratialAndDrain(int partialToRead, InputStream inputStream, OutputStream target)&lt;br/&gt;
+      throws IOException {&lt;br/&gt;
+    // read specified partial bytes from request InputStream to target and then drain the rest.&lt;br/&gt;
+    for (int i = 0; i &amp;lt; partialToRead; i++) {&lt;br/&gt;
+      int readByte = inputStream.read();&lt;br/&gt;
+      if (readByte &amp;gt;= 0) {
+        target.write(readByte);
+      } else {
+        break;
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+    Drainable drainableRequest = (Drainable) inputStream;&lt;br/&gt;
+    drainableRequest.drainTo(target);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testAvroRequestReadPartialAndDrain() throws IOException {&lt;br/&gt;
+    AvroRequestMarshaller requestMarshaller = new AvroRequestMarshaller(message);&lt;br/&gt;
+    InputStream requestInputStream = requestMarshaller.stream(new Object[]{record});&lt;br/&gt;
+    ByteArrayOutputStream requestOutputStream = new ByteArrayOutputStream();&lt;br/&gt;
+    readPratialAndDrain(random.nextInt(7) + 1, requestInputStream, requestOutputStream);&lt;br/&gt;
+    InputStream serialized = new ByteArrayInputStream(requestOutputStream.toByteArray());&lt;br/&gt;
+    Object[] parsedArgs = requestMarshaller.parse(serialized);&lt;br/&gt;
+    assertEquals(1, parsedArgs.length);&lt;br/&gt;
+    assertEquals(record, parsedArgs&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testAvroResponseReadPartialAndDrain() throws IOException {
+    AvroResponseMarshaller responseMarshaller = new AvroResponseMarshaller(message);
+    InputStream responseInputStream = responseMarshaller.stream(record);
+    ByteArrayOutputStream responseOutputStream = new ByteArrayOutputStream();
+    readPratialAndDrain(random.nextInt(7) + 1, responseInputStream, responseOutputStream);
+    InputStream serialized = new ByteArrayInputStream(responseOutputStream.toByteArray());
+    Object parsedResponse = responseMarshaller.parse(serialized);
+    assertEquals(record, parsedResponse);
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroProtocolGrpc.java b/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroProtocolGrpc.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..d11aa3d9b&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroProtocolGrpc.java&lt;br/&gt;
@@ -0,0 +1,267 @@&lt;br/&gt;
+/**&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.AvroRemoteException;&lt;br/&gt;
+import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
+import org.apache.avro.grpc.test.Kind;&lt;br/&gt;
+import org.apache.avro.grpc.test.MD5;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestError;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestRecord;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestService;&lt;br/&gt;
+import org.apache.avro.ipc.CallFuture;&lt;br/&gt;
+import org.junit.After;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+import java.util.concurrent.CountDownLatch;&lt;br/&gt;
+import java.util.concurrent.ExecutorService;&lt;br/&gt;
+import java.util.concurrent.Executors;&lt;br/&gt;
+import java.util.concurrent.Future;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.concurrent.atomic.AtomicInteger;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.ManagedChannel;&lt;br/&gt;
+import io.grpc.ManagedChannelBuilder;&lt;br/&gt;
+import io.grpc.Server;&lt;br/&gt;
+import io.grpc.ServerBuilder;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+import static org.junit.Assert.fail;&lt;br/&gt;
+&lt;br/&gt;
+public class TestAvroProtocolGrpc {&lt;br/&gt;
+  private final TestRecord record = TestRecord.newBuilder().setName(&quot;foo&quot;).setKind(Kind.FOO)&lt;br/&gt;
+      .setArrayOfLongs(Arrays.asList(42L, 424L, 4242L)).setHash(new MD5(new byte[]{4, 2, 4, 2}
&lt;p&gt;))&lt;br/&gt;
+      .setNullableHash(null).build();&lt;br/&gt;
+  private final String declaredErrMsg = &quot;Declared error&quot;;&lt;br/&gt;
+  private final String undeclaredErrMsg = &quot;Undeclared error&quot;;&lt;br/&gt;
+  private final TestError declaredError = TestError.newBuilder().setMessage$(declaredErrMsg).build();&lt;br/&gt;
+  private final RuntimeException undeclaredError = new RuntimeException(undeclaredErrMsg);&lt;br/&gt;
+  private CountDownLatch oneWayStart;&lt;br/&gt;
+  private CountDownLatch oneWayDone;&lt;br/&gt;
+  private AtomicInteger oneWayCount;&lt;br/&gt;
+  private TestService stub;&lt;br/&gt;
+  private TestService.Callback callbackStub;&lt;br/&gt;
+  private Server server;&lt;br/&gt;
+  private ManagedChannel channel;&lt;br/&gt;
+&lt;br/&gt;
+  @Before&lt;br/&gt;
+  public void setUp() throws IOException &lt;/p&gt;
{
+    TestService serviceImpl = new TestServiceImplBase();
+    setUpServerAndClient(serviceImpl);
+  }
&lt;p&gt;+&lt;br/&gt;
+  private void setUpServerAndClient(TestService serviceImpl) throws IOException {&lt;br/&gt;
+    if (server != null &amp;amp;&amp;amp; !server.isShutdown()) &lt;/p&gt;
{
+      server.shutdown();
+    }
&lt;p&gt;+    if (channel != null &amp;amp;&amp;amp; !channel.isShutdown()) &lt;/p&gt;
{
+      channel.shutdownNow();
+    }
&lt;p&gt;+    server = ServerBuilder.forPort(0)&lt;br/&gt;
+        .addService(AvroGrpcServer.createServiceDefinition(TestService.class, serviceImpl))&lt;br/&gt;
+        .build();&lt;br/&gt;
+    server.start();&lt;br/&gt;
+    int port = server.getPort();&lt;br/&gt;
+    channel = ManagedChannelBuilder.forAddress(&quot;localhost&quot;, port).usePlaintext(true).build();&lt;br/&gt;
+    stub = AvroGrpcClient.create(channel, TestService.class);&lt;br/&gt;
+    callbackStub = AvroGrpcClient.create(channel, TestService.Callback.class);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @After&lt;br/&gt;
+  public void cleanUp() &lt;/p&gt;
{
+    channel.shutdownNow();
+    server.shutdownNow();
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testEchoRecord() throws Exception &lt;/p&gt;
{
+    TestRecord echoedRecord = stub.echo(record);
+    assertEquals(record, echoedRecord);
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testMultipleArgsAdd() throws Exception &lt;/p&gt;
{
+    int result = stub.add(3, 5, 2);
+    assertEquals(10, result);
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testMultipleArgsConcatenate() throws Exception &lt;/p&gt;
{
+    String val1 = &quot;foo-bar&quot;;
+    Boolean val2 = true;
+    long val3 = 123321L;
+    int val4 = 42;
+    String result = stub.concatenate(val1, val2, val3, val4);
+    assertEquals(val1 + val2 + val3 + val4, result);
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testCallbackInterface() throws Exception &lt;/p&gt;
{
+    CallFuture&amp;lt;TestRecord&amp;gt; future = new CallFuture&amp;lt;TestRecord&amp;gt;();
+    callbackStub.echo(record, future);
+    assertEquals(record, future.get(1, TimeUnit.SECONDS));
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testOneWayRpc() throws Exception &lt;/p&gt;
{
+    oneWayStart = new CountDownLatch(1);
+    oneWayDone = new CountDownLatch(3);
+    oneWayCount = new AtomicInteger();
+    stub.ping();
+    stub.ping();
+    //client is not stalled while server is waiting for processing requests
+    assertEquals(0, oneWayCount.get());
+    oneWayStart.countDown();
+    stub.ping();
+    oneWayDone.await(1, TimeUnit.SECONDS);
+    assertEquals(3, oneWayCount.get());
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testDeclaredError() throws Exception {&lt;br/&gt;
+    try &lt;/p&gt;
{
+      stub.error(true);
+      fail(&quot;Expected exception but none thrown&quot;);
+    }
&lt;p&gt; catch (TestError te) &lt;/p&gt;
{
+      assertEquals(declaredErrMsg, te.getMessage$());
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testUndeclaredError() throws Exception {&lt;br/&gt;
+    try &lt;/p&gt;
{
+      stub.error(false);
+      fail(&quot;Expected exception but none thrown&quot;);
+    }
&lt;p&gt; catch (AvroRuntimeException e) &lt;/p&gt;
{
+      assertTrue(e.getMessage().contains(undeclaredErrMsg));
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testNullableResponse() throws Exception {&lt;br/&gt;
+    setUpServerAndClient(new TestServiceImplBase() {&lt;br/&gt;
+      @Override&lt;br/&gt;
+      public String concatenate(String val1, boolean val2, long val3, int val4)&lt;br/&gt;
+          throws AvroRemoteException &lt;/p&gt;
{
+        return null;
+      }
&lt;p&gt;+    });&lt;br/&gt;
+    String response = stub.concatenate(&quot;foo&quot;, true, 42L, 42);&lt;br/&gt;
+    assertEquals(null, response);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test(expected = AvroRuntimeException.class)&lt;br/&gt;
+  public void testGrpcConnectionError() throws Exception &lt;/p&gt;
{
+    //close the channel and initiate request
+    channel.shutdownNow();
+    stub.add(0, 1, 2);
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testRepeatedRequests() throws Exception {&lt;br/&gt;
+    TestRecord[] echoedRecords = new TestRecord&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    // validate results after all requests are done&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      echoedRecords[i] = stub.echo(record);
+    }
&lt;p&gt;+    for (TestRecord result : echoedRecords) &lt;/p&gt;
{
+      assertEquals(record, result);
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testConcurrentClientAccess() throws Exception {&lt;br/&gt;
+    ExecutorService es = Executors.newCachedThreadPool();&lt;br/&gt;
+    Future&amp;lt;TestRecord&amp;gt;[] records = new Future&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    Future&amp;lt;Integer&amp;gt;[] adds = new Future&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    //submit requests in parallel&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      records[i] = es.submit(() -&amp;gt; stub.echo(record));
+      int j = i;
+      adds[i] = es.submit(() -&amp;gt; stub.add(j, 2 * j, 3 * j));
+    }
&lt;p&gt;+    //validate all results&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      assertEquals(record, records[i].get());
+      assertEquals(6 * i, (long) adds[i].get());
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testConcurrentChannels() throws Exception {&lt;br/&gt;
+    ManagedChannel otherChannel = ManagedChannelBuilder.forAddress(&quot;localhost&quot;, server.getPort())&lt;br/&gt;
+        .usePlaintext(true).build();&lt;br/&gt;
+    TestService otherStub = AvroGrpcClient.create(otherChannel, TestService.class);&lt;br/&gt;
+    Future&amp;lt;Integer&amp;gt;[] adds = new Future&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    Future&amp;lt;Integer&amp;gt;[] otherAdds = new Future&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    ExecutorService es = Executors.newCachedThreadPool();&lt;br/&gt;
+    //submit requests on clients with different channels&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      int j = i;
+      adds[i] = es.submit(() -&amp;gt; stub.add(j, j - 1, j - 2));
+      otherAdds[i] = es.submit(() -&amp;gt; otherStub.add(j, j + 1, j + 2));
+    }
&lt;p&gt;+    //validate all results&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      assertEquals((3 * i) - 3, (long) adds[i].get());
+      assertEquals((3 * i) + 3, (long) otherAdds[i].get());
+    }
&lt;p&gt;+    otherChannel.shutdownNow();&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private class TestServiceImplBase implements TestService {&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public TestRecord echo(TestRecord record) throws AvroRemoteException &lt;/p&gt;
{
+      return record;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public int add(int arg1, int arg2, int arg3) throws AvroRemoteException &lt;/p&gt;
{
+      return arg1 + arg2 + arg3;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public Void error(boolean declared) throws AvroRemoteException, TestError {&lt;br/&gt;
+      if (declared) &lt;/p&gt;
{
+        throw declaredError;
+      }
&lt;p&gt;+      throw undeclaredError;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void ping() {&lt;br/&gt;
+      try &lt;/p&gt;
{
+        oneWayStart.await();
+        oneWayCount.incrementAndGet();
+        oneWayDone.countDown();
+      }
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
+        fail(&quot;thread interrupted when waiting for all one-way messages&quot;);
+      }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public String concatenate(String val1, boolean val2, long val3, int val4) throws AvroRemoteException &lt;/p&gt;
{
+      return val1 + val2 + val3 + val4;
+    }
&lt;p&gt;+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/pom.xml b/lang/java/pom.xml&lt;br/&gt;
index 2d1df1f1c..78abcdcbf 100644&lt;br/&gt;
&amp;#8212; a/lang/java/pom.xml&lt;br/&gt;
+++ b/lang/java/pom.xml&lt;br/&gt;
@@ -61,6 +61,7 @@&lt;br/&gt;
     &amp;lt;easymock.version&amp;gt;3.4&amp;lt;/easymock.version&amp;gt;&lt;br/&gt;
     &amp;lt;hamcrest.version&amp;gt;1.3&amp;lt;/hamcrest.version&amp;gt;&lt;br/&gt;
     &amp;lt;joda.version&amp;gt;2.9.7&amp;lt;/joda.version&amp;gt;&lt;br/&gt;
+    &amp;lt;grpc.version&amp;gt;1.7.0&amp;lt;/grpc.version&amp;gt;&lt;br/&gt;
     &amp;lt;!-- This Guava version should match Hadoop&apos;s Guava version. See &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1781&quot; title=&quot;Schema.parse is not thread safe&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1781&quot;&gt;&lt;del&gt;AVRO-1781&lt;/del&gt;&lt;/a&gt;. --&amp;gt;&lt;br/&gt;
     &amp;lt;guava.version&amp;gt;11.0.2&amp;lt;/guava.version&amp;gt;&lt;br/&gt;
     &amp;lt;findbugs-annotations.version&amp;gt;1.3.9-1&amp;lt;/findbugs-annotations.version&amp;gt;&lt;br/&gt;
@@ -94,6 +95,7 @@&lt;br/&gt;
     &amp;lt;module&amp;gt;protobuf&amp;lt;/module&amp;gt;&lt;br/&gt;
     &amp;lt;module&amp;gt;thrift&amp;lt;/module&amp;gt;&lt;br/&gt;
     &amp;lt;module&amp;gt;archetypes&amp;lt;/module&amp;gt;&lt;br/&gt;
+    &amp;lt;module&amp;gt;grpc&amp;lt;/module&amp;gt;&lt;br/&gt;
   &amp;lt;/modules&amp;gt;&lt;/p&gt;

&lt;p&gt;   &amp;lt;build&amp;gt;&lt;br/&gt;
@@ -464,6 +466,16 @@&lt;br/&gt;
         &amp;lt;artifactId&amp;gt;joda-time&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
         &amp;lt;version&amp;gt;${joda.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
       &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;dependency&amp;gt;&lt;br/&gt;
+        &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+        &amp;lt;artifactId&amp;gt;grpc-stub&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+        &amp;lt;version&amp;gt;${grpc.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+      &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;dependency&amp;gt;&lt;br/&gt;
+        &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+        &amp;lt;artifactId&amp;gt;grpc-netty&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+        &amp;lt;version&amp;gt;${grpc.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+      &amp;lt;/dependency&amp;gt;&lt;br/&gt;
     &amp;lt;/dependencies&amp;gt;&lt;br/&gt;
   &amp;lt;/dependencyManagement&amp;gt;&lt;/p&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16461370" author="githubbot" created="Wed, 2 May 2018 17:41:21 +0000"  >&lt;p&gt;srujann opened a new pull request #308: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2172&quot; title=&quot;Avro over gRPC (Java Implementation)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2172&quot;&gt;&lt;del&gt;AVRO-2172&lt;/del&gt;&lt;/a&gt;: Avro binding for gRPC (Java Implementation)&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/308&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/308&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   To enable avro based schema and RPC IDL to be transported over gRPC.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16461373" author="githubbot" created="Wed, 2 May 2018 17:41:50 +0000"  >&lt;p&gt;cutting closed pull request #308: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2172&quot; title=&quot;Avro over gRPC (Java Implementation)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2172&quot;&gt;&lt;del&gt;AVRO-2172&lt;/del&gt;&lt;/a&gt;: Avro binding for gRPC (Java Implementation)&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/308&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/308&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/lang/java/grpc/pom.xml b/lang/java/grpc/pom.xml&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..a64d8cd54&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/pom.xml&lt;br/&gt;
@@ -0,0 +1,109 @@&lt;br/&gt;
+&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;
+&amp;lt;!--&lt;br/&gt;
+   Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+   contributor license agreements.  See the NOTICE file distributed with&lt;br/&gt;
+   this work for additional information regarding copyright ownership.&lt;br/&gt;
+   The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+   (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+   the License.  You may obtain a copy of the License at&lt;br/&gt;
+&lt;br/&gt;
+       &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+&lt;br/&gt;
+   Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+   See the License for the specific language governing permissions and&lt;br/&gt;
+   limitations under the License.&lt;br/&gt;
+--&amp;gt;&lt;br/&gt;
+&amp;lt;project&lt;br/&gt;
+  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 &lt;a href=&quot;http://maven.apache.org/xsd/maven-4.0.0.xsd&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://maven.apache.org/xsd/maven-4.0.0.xsd&lt;/a&gt;&quot;&lt;br/&gt;
+  xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&amp;gt;&lt;br/&gt;
+  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;parent&amp;gt;&lt;br/&gt;
+    &amp;lt;groupId&amp;gt;org.apache.avro&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+    &amp;lt;artifactId&amp;gt;avro-parent&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+    &amp;lt;version&amp;gt;1.9.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;br/&gt;
+    &amp;lt;relativePath&amp;gt;../&amp;lt;/relativePath&amp;gt;&lt;br/&gt;
+  &amp;lt;/parent&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;artifactId&amp;gt;avro-grpc&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;name&amp;gt;Apache Avro gRPC&amp;lt;/name&amp;gt;&lt;br/&gt;
+  &amp;lt;description&amp;gt;Avro IDL based RPC and serialization over gRPC&amp;lt;/description&amp;gt;&lt;br/&gt;
+  &amp;lt;packaging&amp;gt;bundle&amp;lt;/packaging&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;properties&amp;gt;&lt;br/&gt;
+    &amp;lt;osgi.import&amp;gt;&lt;br/&gt;
+      !org.apache.avro.grpc*,&lt;br/&gt;
+      org.apache.avro*;version=&quot;${project.version}&quot;,&lt;br/&gt;
+      io.grpc*&lt;br/&gt;
+      *&lt;br/&gt;
+    &amp;lt;/osgi.import&amp;gt;&lt;br/&gt;
+    &amp;lt;osgi.export&amp;gt;org.apache.avro.grpc*;version=&quot;${project.version}&quot;&amp;lt;/osgi.export&amp;gt;&lt;br/&gt;
+  &amp;lt;/properties&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;build&amp;gt;&lt;br/&gt;
+    &amp;lt;resources&amp;gt;&lt;br/&gt;
+      &amp;lt;resource&amp;gt;&lt;br/&gt;
+        &amp;lt;directory&amp;gt;src/main/velocity&amp;lt;/directory&amp;gt;&lt;br/&gt;
+      &amp;lt;/resource&amp;gt;&lt;br/&gt;
+    &amp;lt;/resources&amp;gt;&lt;br/&gt;
+    &amp;lt;plugins&amp;gt;&lt;br/&gt;
+      &amp;lt;plugin&amp;gt;&lt;br/&gt;
+        &amp;lt;groupId&amp;gt;${project.groupId}&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+        &amp;lt;artifactId&amp;gt;avro-maven-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+        &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+        &amp;lt;executions&amp;gt;&lt;br/&gt;
+          &amp;lt;execution&amp;gt;&lt;br/&gt;
+            &amp;lt;id&amp;gt;schemas&amp;lt;/id&amp;gt;&lt;br/&gt;
+            &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;&lt;br/&gt;
+            &amp;lt;goals&amp;gt;&lt;br/&gt;
+              &amp;lt;goal&amp;gt;schema&amp;lt;/goal&amp;gt;&lt;br/&gt;
+              &amp;lt;goal&amp;gt;protocol&amp;lt;/goal&amp;gt;&lt;br/&gt;
+              &amp;lt;goal&amp;gt;idl-protocol&amp;lt;/goal&amp;gt;&lt;br/&gt;
+            &amp;lt;/goals&amp;gt;&lt;br/&gt;
+            &amp;lt;configuration&amp;gt;&lt;br/&gt;
+              &amp;lt;stringType&amp;gt;String&amp;lt;/stringType&amp;gt;&lt;br/&gt;
+              &amp;lt;testSourceDirectory&amp;gt;${project.basedir}/src/test/avro&amp;lt;/testSourceDirectory&amp;gt;&lt;br/&gt;
+              &amp;lt;testOutputDirectory&amp;gt;${project.build.directory}/generated-test-sources/java&amp;lt;/testOutputDirectory&amp;gt;&lt;br/&gt;
+            &amp;lt;/configuration&amp;gt;&lt;br/&gt;
+          &amp;lt;/execution&amp;gt;&lt;br/&gt;
+        &amp;lt;/executions&amp;gt;&lt;br/&gt;
+      &amp;lt;/plugin&amp;gt;&lt;br/&gt;
+    &amp;lt;/plugins&amp;gt;&lt;br/&gt;
+  &amp;lt;/build&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+  &amp;lt;dependencies&amp;gt;&lt;br/&gt;
+    &amp;lt;dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+      &amp;lt;artifactId&amp;gt;grpc-stub&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+      &amp;lt;version&amp;gt;${grpc.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+    &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+    &amp;lt;dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+      &amp;lt;artifactId&amp;gt;grpc-netty&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+      &amp;lt;version&amp;gt;${grpc.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+      &amp;lt;!-- use netty only for tests as user can use grpc transports other than Netty --&amp;gt;&lt;br/&gt;
+      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&lt;br/&gt;
+    &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+    &amp;lt;dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;groupId&amp;gt;${project.groupId}&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+      &amp;lt;artifactId&amp;gt;avro&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+      &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+    &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+    &amp;lt;dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;groupId&amp;gt;${project.groupId}&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+      &amp;lt;artifactId&amp;gt;avro-ipc&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+      &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+      &amp;lt;!-- exclude all dependencies from avro-ipc as only Callback class is needed --&amp;gt;&lt;br/&gt;
+      &amp;lt;exclusions&amp;gt;&lt;br/&gt;
+        &amp;lt;exclusion&amp;gt;&lt;br/&gt;
+          &amp;lt;groupId&amp;gt;*&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+          &amp;lt;artifactId&amp;gt;*&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+        &amp;lt;/exclusion&amp;gt;&lt;br/&gt;
+      &amp;lt;/exclusions&amp;gt;&lt;br/&gt;
+    &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+  &amp;lt;/dependencies&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+&amp;lt;/project&amp;gt;&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcClient.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcClient.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..f0e7d22f6&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcClient.java&lt;br/&gt;
@@ -0,0 +1,167 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import com.google.common.base.Throwables;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.AvroRemoteException;&lt;br/&gt;
+import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+import org.apache.avro.ipc.CallFuture;&lt;br/&gt;
+import org.apache.avro.ipc.Callback;&lt;br/&gt;
+&lt;br/&gt;
+import java.lang.reflect.InvocationHandler;&lt;br/&gt;
+import java.lang.reflect.Method;&lt;br/&gt;
+import java.lang.reflect.Proxy;&lt;br/&gt;
+import java.lang.reflect.Type;&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.CallOptions;&lt;br/&gt;
+import io.grpc.Channel;&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+import io.grpc.stub.ClientCalls;&lt;br/&gt;
+import io.grpc.stub.StreamObserver;&lt;br/&gt;
+&lt;br/&gt;
+/** Component that sets up a gRPC client for Avro&apos;s IDL and Serialization. */&lt;br/&gt;
+public abstract class AvroGrpcClient {&lt;br/&gt;
+&lt;br/&gt;
+  private AvroGrpcClient() &lt;/p&gt;
{
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates a gRPC client for Avro&apos;s interface with default {@link CallOptions}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param channel the channel used for gRPC {@link ClientCalls}.&lt;br/&gt;
+   * @param iface   Avro interface for which client is built.&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt;     type of Avro Interface.&lt;br/&gt;
+   * @return a new client proxy.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static &amp;lt;T&amp;gt; T create(Channel channel, Class&amp;lt;T&amp;gt; iface) {
+    return create(channel, iface, CallOptions.DEFAULT);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates a gRPC client for Avro&apos;s interface with provided {@link CallOptions}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param channel     the channel used for gRPC {@link ClientCalls}.&lt;br/&gt;
+   * @param iface       Avro interface for which client is built.&lt;br/&gt;
+   * @param callOptions client call options for gRPC.&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt;         type of Avro Interface.&lt;br/&gt;
+   * @return a new client proxy.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static &amp;lt;T&amp;gt; T create(Channel channel, Class&amp;lt;T&amp;gt; iface, CallOptions&lt;br/&gt;
+      callOptions) {&lt;br/&gt;
+    Protocol protocol = AvroGrpcUtils.getProtocol(iface);&lt;br/&gt;
+    ServiceDescriptor serviceDescriptor = ServiceDescriptor.create(iface);&lt;br/&gt;
+    ServiceInvocationHandler proxyHandler = new ServiceInvocationHandler(channel, callOptions,&lt;br/&gt;
+        protocol, serviceDescriptor);&lt;br/&gt;
+    return (T) Proxy.newProxyInstance(iface.getClassLoader(), new Class[]{iface}, proxyHandler);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private static class ServiceInvocationHandler implements InvocationHandler {&lt;br/&gt;
+    private final Channel channel;&lt;br/&gt;
+    private final CallOptions callOptions;&lt;br/&gt;
+    private final Protocol protocol;&lt;br/&gt;
+    private final ServiceDescriptor serviceDescriptor;&lt;br/&gt;
+&lt;br/&gt;
+    ServiceInvocationHandler(Channel channel, CallOptions callOptions, Protocol&lt;br/&gt;
+        protocol, ServiceDescriptor serviceDescriptor) {
+      this.channel = channel;
+      this.callOptions = callOptions;
+      this.protocol = protocol;
+      this.serviceDescriptor = serviceDescriptor;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {&lt;br/&gt;
+      try {
+        return invokeUnaryMethod(method, args);
+      } catch (Exception e) {&lt;br/&gt;
+        //throw any of the declared exceptions&lt;br/&gt;
+        for (Class&amp;lt;?&amp;gt; exceptionClass : method.getExceptionTypes()) {
+          Throwables.propagateIfInstanceOf(e, (Class&amp;lt;Exception&amp;gt;) exceptionClass);
+        }&lt;br/&gt;
+        //also throw if any runtime exception&lt;br/&gt;
+        Throwables.propagateIfInstanceOf(e, RuntimeException.class);&lt;br/&gt;
+        //wrap all other exceptions&lt;br/&gt;
+        throw new AvroRemoteException(e);&lt;br/&gt;
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private Object invokeUnaryMethod(Method method, Object[] args) throws Exception {&lt;br/&gt;
+      Type[] parameterTypes = method.getParameterTypes();&lt;br/&gt;
+      if ((parameterTypes.length &amp;gt; 0) &amp;amp;&amp;amp;&lt;br/&gt;
+          (parameterTypes&lt;span class=&quot;error&quot;&gt;&amp;#91;parameterTypes.length - 1&amp;#93;&lt;/span&gt; instanceof Class) &amp;amp;&amp;amp;&lt;br/&gt;
+          Callback.class.isAssignableFrom(((Class&amp;lt;?&amp;gt;) parameterTypes&lt;span class=&quot;error&quot;&gt;&amp;#91;parameterTypes.length - 1&amp;#93;&lt;/span&gt;))) {
+        // get the callback argument from the end
+        Object[] finalArgs = Arrays.copyOf(args, args.length - 1);
+        Callback&amp;lt;?&amp;gt; callback = (Callback&amp;lt;?&amp;gt;) args[args.length - 1];
+        unaryRequest(method.getName(), finalArgs, callback);
+        return null;
+      } else {
+        return unaryRequest(method.getName(), args);
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private Object unaryRequest(String methodName, Object[] args) throws Exception {&lt;br/&gt;
+      CallFuture&amp;lt;Object&amp;gt; callFuture = new CallFuture&amp;lt;&amp;gt;();&lt;br/&gt;
+      unaryRequest(methodName, args, callFuture);&lt;br/&gt;
+      try {
+        return callFuture.get();
+      } catch (Exception e) {
+        Throwables.propagateIfInstanceOf(e.getCause(), Exception.class);
+        throw new AvroRemoteException(e.getCause());
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private &amp;lt;RespT&amp;gt; void unaryRequest(String methodName, Object[] args, Callback&amp;lt;RespT&amp;gt; callback) throws&lt;br/&gt;
+        Exception {
+      StreamObserver&amp;lt;Object&amp;gt; observerAdpater = new CallbackToResponseStreamObserverAdpater&amp;lt;&amp;gt;
+          (callback);
+      ClientCalls.asyncUnaryCall(channel.newCall(serviceDescriptor.getMethod(methodName,
+          MethodDescriptor.MethodType.UNARY), callOptions), args, observerAdpater);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private static class CallbackToResponseStreamObserverAdpater&amp;lt;T&amp;gt; implements StreamObserver&amp;lt;Object&amp;gt; {&lt;br/&gt;
+      private final Callback&amp;lt;T&amp;gt; callback;&lt;br/&gt;
+&lt;br/&gt;
+      CallbackToResponseStreamObserverAdpater(Callback&amp;lt;T&amp;gt; callback) {
+        this.callback = callback;
+      }&lt;br/&gt;
+&lt;br/&gt;
+      @Override&lt;br/&gt;
+      public void onNext(Object value) {&lt;br/&gt;
+        if (value instanceof Throwable) {
+          callback.handleError((Throwable) value);
+        } else {
+          callback.handleResult((T) value);
+        }&lt;br/&gt;
+      }&lt;br/&gt;
+&lt;br/&gt;
+      @Override&lt;br/&gt;
+      public void onError(Throwable t) {
+        callback.handleError(new AvroRuntimeException(t));
+      }&lt;br/&gt;
+&lt;br/&gt;
+      @Override&lt;br/&gt;
+      public void onCompleted() {
+        // do nothing as there is no equivalent in Callback.
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcServer.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcServer.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..c18822ee4&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcServer.java&lt;br/&gt;
@@ -0,0 +1,120 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import com.google.common.base.Throwables;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+&lt;br/&gt;
+import java.lang.reflect.InvocationTargetException;&lt;br/&gt;
+import java.lang.reflect.Method;&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+import java.util.logging.Level;&lt;br/&gt;
+import java.util.logging.Logger;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+import io.grpc.ServerServiceDefinition;&lt;br/&gt;
+import io.grpc.stub.ServerCalls;&lt;br/&gt;
+import io.grpc.stub.StreamObserver;&lt;br/&gt;
+&lt;br/&gt;
+/** Provides components to set up a gRPC Server for Avro&apos;s IDL and serialization. */&lt;br/&gt;
+public abstract class AvroGrpcServer {&lt;br/&gt;
+&lt;br/&gt;
+  private AvroGrpcServer() {+  }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates a &lt;/p&gt;
{@link ServerServiceDefinition}
&lt;p&gt; for Avro Interface and its implementation that can&lt;br/&gt;
+   * be passed a gRPC Server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface Avro generated RPC service interface for which service defintion is created.&lt;br/&gt;
+   * @param impl  Implementation of the service interface to be invoked for requests.&lt;br/&gt;
+   * @return a new server service definition.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static ServerServiceDefinition createServiceDefinition(Class iface, Object impl) {&lt;br/&gt;
+    Protocol protocol = AvroGrpcUtils.getProtocol(iface);&lt;br/&gt;
+    ServiceDescriptor serviceDescriptor = ServiceDescriptor.create(iface);&lt;br/&gt;
+    ServerServiceDefinition.Builder serviceDefinitionBuilder = ServerServiceDefinition.builder&lt;br/&gt;
+        (serviceDescriptor.getServiceName());&lt;br/&gt;
+    Map&amp;lt;String, Protocol.Message&amp;gt; messages = protocol.getMessages();&lt;br/&gt;
+    for (Method method : iface.getMethods()) {&lt;br/&gt;
+      Protocol.Message msg = messages.get(method.getName());&lt;br/&gt;
+      //setup a method handler only if corresponding message exists in avro protocol.&lt;br/&gt;
+      if (msg != null) &lt;/p&gt;
{
+        UnaryMethodHandler methodHandler = msg.isOneWay() ? new OneWayUnaryMethodHandler(impl,
+            method) : new UnaryMethodHandler(impl, method);
+        serviceDefinitionBuilder.addMethod(serviceDescriptor.getMethod(method.getName(),
+            MethodDescriptor.MethodType.UNARY), ServerCalls.asyncUnaryCall(methodHandler));
+      }
&lt;p&gt;+    }&lt;br/&gt;
+    return serviceDefinitionBuilder.build();&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private static class UnaryMethodHandler implements ServerCalls.UnaryMethod&amp;lt;Object[], Object&amp;gt; {&lt;br/&gt;
+    private final Object serviceImpl;&lt;br/&gt;
+    private final Method method;&lt;br/&gt;
+&lt;br/&gt;
+    UnaryMethodHandler(Object serviceImpl, Method method) &lt;/p&gt;
{
+      this.serviceImpl = serviceImpl;
+      this.method = method;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public void invoke(Object[] request, StreamObserver&amp;lt;Object&amp;gt; responseObserver) {&lt;br/&gt;
+      Object methodResponse = null;&lt;br/&gt;
+      try &lt;/p&gt;
{
+        methodResponse = method.invoke(getServiceImpl(), request);
+      }
&lt;p&gt; catch (InvocationTargetException e) &lt;/p&gt;
{
+        methodResponse = e.getTargetException();
+      }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
+        methodResponse = e;
+      }
&lt;p&gt;+      responseObserver.onNext(methodResponse);&lt;br/&gt;
+      responseObserver.onCompleted();&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public Method getMethod() &lt;/p&gt;
{
+      return method;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public Object getServiceImpl() &lt;/p&gt;
{
+      return serviceImpl;
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  private static class OneWayUnaryMethodHandler extends UnaryMethodHandler {&lt;br/&gt;
+    private static final Logger LOG = Logger.getLogger(OneWayUnaryMethodHandler.class.getName());&lt;br/&gt;
+&lt;br/&gt;
+    OneWayUnaryMethodHandler(Object serviceImpl, Method method) &lt;/p&gt;
{
+      super(serviceImpl, method);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void invoke(Object[] request, StreamObserver&amp;lt;Object&amp;gt; responseObserver) {&lt;br/&gt;
+      //first respond back with a fixed void response in order for call to be complete&lt;br/&gt;
+      responseObserver.onNext(null);&lt;br/&gt;
+      responseObserver.onCompleted();&lt;br/&gt;
+      //process the rpc request&lt;br/&gt;
+      try &lt;/p&gt;
{
+        getMethod().invoke(getServiceImpl(), request);
+      }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
+        LOG.log(Level.WARNING, &quot;Error processing one-way rpc&quot;, Throwables.getRootCause(e));
+      }
&lt;p&gt;+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcUtils.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcUtils.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..f3ab07bc7&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroGrpcUtils.java&lt;br/&gt;
@@ -0,0 +1,85 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.util.logging.Level;&lt;br/&gt;
+import java.util.logging.Logger;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.KnownLength;&lt;br/&gt;
+&lt;br/&gt;
+/** Utility methods for using Avro IDL and serialization with gRPC. */&lt;br/&gt;
+public final class AvroGrpcUtils {&lt;br/&gt;
+  private static Logger log = Logger.getLogger(AvroGrpcUtils.class.getName());&lt;br/&gt;
+&lt;br/&gt;
+  private AvroGrpcUtils() &lt;/p&gt;
{
+  }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Provides a a unique gRPC service name for Avro RPC interface or its subclass Callback&lt;br/&gt;
+   * Interface.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface Avro RPC interface.&lt;br/&gt;
+   * @return unique service name for gRPC.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static String getServiceName(Class iface) &lt;/p&gt;
{
+    Protocol protocol = getProtocol(iface);
+    return protocol.getNamespace() + &quot;.&quot; + protocol.getName();
+  }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets the &lt;/p&gt;
{@link Protocol} from the Avro Interface.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static Protocol getProtocol(Class iface) {&lt;br/&gt;
+    try {
+      Protocol p = (Protocol) (iface.getDeclaredField(&quot;PROTOCOL&quot;).get(null));
+      return p;
+    } catch (NoSuchFieldException e) {
+      throw new AvroRuntimeException(&quot;Not a Specific protocol: &quot; + iface);
+    } catch (IllegalAccessException e) {
+      throw new AvroRuntimeException(e);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Skips any unread bytes from InputStream and closes it.&lt;br/&gt;
+   */&lt;br/&gt;
+  static void skipAndCloseQuietly(InputStream stream) {&lt;br/&gt;
+    try {&lt;br/&gt;
+      if (stream instanceof KnownLength &amp;amp;&amp;amp; stream.available() &amp;gt; 0) {
+        stream.skip(stream.available());
+      } else {&lt;br/&gt;
+        //don&apos;t expect this for an inputStream provided by gRPC but just to be on safe side.&lt;br/&gt;
+        byte[] skipBuffer = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;4096&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+        while (true) {&lt;br/&gt;
+          int read = stream.read(skipBuffer);&lt;br/&gt;
+          if (read &amp;lt; skipBuffer.length) {
+            break;
+          }&lt;br/&gt;
+        }&lt;br/&gt;
+      }&lt;br/&gt;
+      stream.close();&lt;br/&gt;
+    } catch (Exception e) {
+      log.log(Level.WARNING, &quot;failed to skip/close the input stream, may cause memory leak&quot;, e);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroInputStream.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroInputStream.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..79793ee6c&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroInputStream.java&lt;br/&gt;
@@ -0,0 +1,103 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.ByteArrayInputStream;&lt;br/&gt;
+import java.io.ByteArrayOutputStream;&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.io.OutputStream;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+import javax.annotation.concurrent.NotThreadSafe;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.Drainable;&lt;br/&gt;
+&lt;br/&gt;
+/** An {@link InputStream} backed by Avro RPC request/response that can drained to&lt;br/&gt;
+ * a{@link OutputStream}. */&lt;br/&gt;
+@NotThreadSafe&lt;br/&gt;
+public abstract class AvroInputStream extends InputStream implements Drainable {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Container to hold the serialized Avro payload when its read before draining it.&lt;br/&gt;
+   */&lt;br/&gt;
+  @Nullable&lt;br/&gt;
+  private ByteArrayInputStream partial;&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public int read(byte[] b, int off, int len) throws IOException {
+    return getPartialInternal().read(b, off, len);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public int read() throws IOException {
+    return getPartialInternal().read();
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private ByteArrayInputStream getPartialInternal() throws IOException {&lt;br/&gt;
+    if (partial == null) {
+      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+      drainTo(outputStream);
+      partial = new ByteArrayInputStream(outputStream.toByteArray());
+    }&lt;br/&gt;
+    return partial;&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  protected ByteArrayInputStream getPartial() {
+    return partial;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * An {@link OutputStream} that writes to a target {@link OutputStream} and provides total&lt;br/&gt;
+   * number of bytes written to it.&lt;br/&gt;
+   */&lt;br/&gt;
+  protected class CountingOutputStream extends OutputStream {&lt;br/&gt;
+    private final OutputStream target;&lt;br/&gt;
+    private int writtenCount = 0;&lt;br/&gt;
+&lt;br/&gt;
+    public CountingOutputStream(OutputStream target) {
+      this.target = target;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void write(byte[] b, int off, int len) throws IOException {
+      target.write(b, off, len);
+      writtenCount += len;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void write(int b) throws IOException {
+      target.write(b);
+      writtenCount += 1;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void flush() throws IOException {
+      target.flush();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void close() throws IOException {
+      target.close();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public int getWrittenCount() {
+      return writtenCount;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroRequestMarshaller.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroRequestMarshaller.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..618e2af5a&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroRequestMarshaller.java&lt;br/&gt;
@@ -0,0 +1,106 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+import org.apache.avro.Schema;&lt;br/&gt;
+import org.apache.avro.generic.GenericRecord;&lt;br/&gt;
+import org.apache.avro.io.BinaryDecoder;&lt;br/&gt;
+import org.apache.avro.io.BinaryEncoder;&lt;br/&gt;
+import org.apache.avro.io.DecoderFactory;&lt;br/&gt;
+import org.apache.avro.io.EncoderFactory;&lt;br/&gt;
+import org.apache.avro.specific.SpecificDatumReader;&lt;br/&gt;
+import org.apache.avro.specific.SpecificDatumWriter;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.io.OutputStream;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+import io.grpc.Status;&lt;br/&gt;
+import io.grpc.internal.IoUtils;&lt;br/&gt;
+&lt;br/&gt;
+/** Marshaller for Avro RPC request. */&lt;br/&gt;
+public class AvroRequestMarshaller implements MethodDescriptor.Marshaller&amp;lt;Object[]&amp;gt; {&lt;br/&gt;
+  private static final EncoderFactory ENCODER_FACTORY = new EncoderFactory();&lt;br/&gt;
+  private static final DecoderFactory DECODER_FACTORY = new DecoderFactory();&lt;br/&gt;
+  private final Protocol.Message message;&lt;br/&gt;
+&lt;br/&gt;
+  public AvroRequestMarshaller(Protocol.Message message) {
+    this.message = message;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public InputStream stream(Object[] value) {
+    return new AvroRequestInputStream(value, message);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public Object[] parse(InputStream stream) {&lt;br/&gt;
+    try {&lt;br/&gt;
+      BinaryDecoder in = DECODER_FACTORY.binaryDecoder(stream, null);&lt;br/&gt;
+      Schema reqSchema = message.getRequest();&lt;br/&gt;
+      GenericRecord request = (GenericRecord) new SpecificDatumReader&amp;lt;&amp;gt;(reqSchema).read(null, in);&lt;br/&gt;
+      Object[] args = new Object&lt;span class=&quot;error&quot;&gt;&amp;#91;reqSchema.getFields().size()&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+      int i = 0;&lt;br/&gt;
+      for (Schema.Field field : reqSchema.getFields()) {
+        args[i++] = request.get(field.name());
+      }&lt;br/&gt;
+      return args;&lt;br/&gt;
+    } catch (IOException e) {
+      throw Status.INTERNAL.withCause(e).
+          withDescription(&quot;Error deserializing avro request arguments&quot;).asRuntimeException();
+    } finally {
+      AvroGrpcUtils.skipAndCloseQuietly(stream);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private class AvroRequestInputStream extends AvroInputStream {&lt;br/&gt;
+    private final Protocol.Message message;&lt;br/&gt;
+    @Nullable&lt;br/&gt;
+    private Object[] args;&lt;br/&gt;
+&lt;br/&gt;
+    AvroRequestInputStream(@Nullable Object[] args, Protocol.Message message) {
+      this.args = args;
+      this.message = message;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public int drainTo(OutputStream target) throws IOException {&lt;br/&gt;
+      int written;&lt;br/&gt;
+      if (getPartial() != null) {
+        written = (int) IoUtils.copy(getPartial(), target);
+      } else {&lt;br/&gt;
+        Schema reqSchema = message.getRequest();&lt;br/&gt;
+        CountingOutputStream outputStream = new CountingOutputStream(target);&lt;br/&gt;
+        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(outputStream, null);&lt;br/&gt;
+        int i = 0;&lt;br/&gt;
+        for (Schema.Field param : reqSchema.getFields()) {
+          new SpecificDatumWriter&amp;lt;&amp;gt;(param.schema()).write(args[i++], out);
+        }&lt;br/&gt;
+        out.flush();&lt;br/&gt;
+        args = null;&lt;br/&gt;
+        written = outputStream.getWrittenCount();&lt;br/&gt;
+      }&lt;br/&gt;
+      return written;&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroResponseMarshaller.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroResponseMarshaller.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..f1f9b0145&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/AvroResponseMarshaller.java&lt;br/&gt;
@@ -0,0 +1,133 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+import org.apache.avro.io.BinaryDecoder;&lt;br/&gt;
+import org.apache.avro.io.BinaryEncoder;&lt;br/&gt;
+import org.apache.avro.io.DecoderFactory;&lt;br/&gt;
+import org.apache.avro.io.EncoderFactory;&lt;br/&gt;
+import org.apache.avro.specific.SpecificDatumReader;&lt;br/&gt;
+import org.apache.avro.specific.SpecificDatumWriter;&lt;br/&gt;
+import org.apache.avro.util.Utf8;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.ByteArrayOutputStream;&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.io.OutputStream;&lt;br/&gt;
+&lt;br/&gt;
+import javax.annotation.Nullable;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+import io.grpc.Status;&lt;br/&gt;
+import io.grpc.internal.IoUtils;&lt;br/&gt;
+&lt;br/&gt;
+/** Marshaller for Avro RPC response. */&lt;br/&gt;
+public class AvroResponseMarshaller implements MethodDescriptor.Marshaller&amp;lt;Object&amp;gt; {&lt;br/&gt;
+  private static final EncoderFactory ENCODER_FACTORY = new EncoderFactory();&lt;br/&gt;
+  private static final DecoderFactory DECODER_FACTORY = new DecoderFactory();&lt;br/&gt;
+  private final Protocol.Message message;&lt;br/&gt;
+&lt;br/&gt;
+  public AvroResponseMarshaller(Protocol.Message message) {+    this.message = message;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public InputStream stream(Object value) {
+    return new AvroResponseInputStream(value, message);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Override&lt;br/&gt;
+  public Object parse(InputStream stream) {&lt;br/&gt;
+    try {&lt;br/&gt;
+      if (message.isOneWay()) return null;&lt;br/&gt;
+      BinaryDecoder in = DECODER_FACTORY.binaryDecoder(stream, null);&lt;br/&gt;
+      if (!in.readBoolean()) {
+        Object response = new SpecificDatumReader(message.getResponse()).read(null, in);
+        return response;
+      } else {&lt;br/&gt;
+        Object value = new SpecificDatumReader(message.getErrors()).read(null, in);&lt;br/&gt;
+        if (value instanceof Exception) {
+          return value;
+        }&lt;br/&gt;
+        return new AvroRuntimeException(value.toString());&lt;br/&gt;
+      }&lt;br/&gt;
+    } catch (IOException e) {
+      throw Status.INTERNAL.withCause(e).
+          withDescription(&quot;Error deserializing avro response&quot;).asRuntimeException();
+    } finally {
+      AvroGrpcUtils.skipAndCloseQuietly(stream);
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private class AvroResponseInputStream extends AvroInputStream {&lt;br/&gt;
+    private final Protocol.Message message;&lt;br/&gt;
+    @Nullable&lt;br/&gt;
+    private Object response;&lt;br/&gt;
+&lt;br/&gt;
+    AvroResponseInputStream(@Nullable Object response, Protocol.Message message) {
+      this.response = response;
+      this.message = message;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public int drainTo(OutputStream target) throws IOException {&lt;br/&gt;
+      int written;&lt;br/&gt;
+      if (getPartial() != null) {
+        written = (int) IoUtils.copy(getPartial(), target);
+      } else {
+        written = writeResponse(target);
+      }&lt;br/&gt;
+      return written;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private int writeResponse(OutputStream target) throws IOException {&lt;br/&gt;
+      int written;&lt;br/&gt;
+      if (message.isOneWay()) {
+        written = 0;
+      } else if (response instanceof Exception) {&lt;br/&gt;
+        ByteArrayOutputStream bao = new ByteArrayOutputStream();&lt;br/&gt;
+        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(bao, null);&lt;br/&gt;
+        try {
+          out.writeBoolean(true);
+          new SpecificDatumWriter(message.getErrors()).write(response, out);
+        } catch (Exception e) {
+          bao = new ByteArrayOutputStream();
+          out = ENCODER_FACTORY.binaryEncoder(bao, null);
+          out.writeBoolean(true);
+          new SpecificDatumWriter(Protocol.SYSTEM_ERRORS).write(new Utf8(e.toString()), out);
+        }&lt;br/&gt;
+        out.flush();&lt;br/&gt;
+        byte[] serializedError = bao.toByteArray();&lt;br/&gt;
+        target.write(serializedError);&lt;br/&gt;
+        written = serializedError.length;&lt;br/&gt;
+      } else {
+        CountingOutputStream outputStream = new CountingOutputStream(target);
+        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(outputStream, null);
+        out.writeBoolean(false);
+        new SpecificDatumWriter(message.getResponse()).write(response, out);
+        out.flush();
+        written = outputStream.getWrittenCount();
+      }&lt;br/&gt;
+      response = null;&lt;br/&gt;
+      return written;&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/main/java/org/apache/avro/grpc/ServiceDescriptor.java b/lang/java/grpc/src/main/java/org/apache/avro/grpc/ServiceDescriptor.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..d9fa97ab6&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/main/java/org/apache/avro/grpc/ServiceDescriptor.java&lt;br/&gt;
@@ -0,0 +1,84 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.concurrent.ConcurrentHashMap;&lt;br/&gt;
+import java.util.concurrent.ConcurrentMap;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.MethodDescriptor;&lt;br/&gt;
+&lt;br/&gt;
+import static io.grpc.MethodDescriptor.generateFullMethodName;&lt;br/&gt;
+&lt;br/&gt;
+/** Descriptor for a gRPC service based on a Avro interface. */&lt;br/&gt;
+class ServiceDescriptor {&lt;br/&gt;
+&lt;br/&gt;
+  // cache for service descriptors.&lt;br/&gt;
+  private static final ConcurrentMap&amp;lt;String, ServiceDescriptor&amp;gt; SERVICE_DESCRIPTORS =&lt;br/&gt;
+      new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+  private final Class iface;&lt;br/&gt;
+  private final String serviceName;&lt;br/&gt;
+  private final Protocol protocol;&lt;br/&gt;
+  // cache for method descriptors.&lt;br/&gt;
+  private final ConcurrentMap&amp;lt;String, MethodDescriptor&amp;lt;Object[], Object&amp;gt;&amp;gt; methods =&lt;br/&gt;
+      new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+  private ServiceDescriptor(Class iface, String serviceName) {
+    this.iface = iface;
+    this.serviceName = serviceName;
+    this.protocol = AvroGrpcUtils.getProtocol(iface);
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates a Service Descriptor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface Avro RPC interface.&lt;br/&gt;
+   */&lt;br/&gt;
+  public static ServiceDescriptor create(Class iface) {
+    String serviceName = AvroGrpcUtils.getServiceName(iface);
+    return SERVICE_DESCRIPTORS.computeIfAbsent(serviceName, key -&amp;gt; new ServiceDescriptor
+        (iface, serviceName));
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * provides name of the service.&lt;br/&gt;
+   */&lt;br/&gt;
+  public String getServiceName() {
+    return serviceName;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Provides a gRPC {@link MethodDescriptor} for a RPC method/message of Avro {@link Protocol}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param methodType gRPC type for the method.&lt;br/&gt;
+   * @return a &lt;/p&gt;
{@link MethodDescriptor}
&lt;p&gt;+   */&lt;br/&gt;
+  public MethodDescriptor&amp;lt;Object[], Object&amp;gt; getMethod(String methodName, MethodDescriptor&lt;br/&gt;
+      .MethodType methodType) &lt;/p&gt;
{
+    return methods.computeIfAbsent(methodName,
+        key -&amp;gt; MethodDescriptor.&amp;lt;Object[], Object&amp;gt;newBuilder()
+            .setFullMethodName(generateFullMethodName(serviceName, methodName))
+            .setType(methodType)
+            .setRequestMarshaller(new AvroRequestMarshaller(protocol.getMessages().get(methodName)))
+            .setResponseMarshaller(
+                new AvroResponseMarshaller(protocol.getMessages().get(methodName)))
+            .build());
+  }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/test/avro/TestService.avdl b/lang/java/grpc/src/test/avro/TestService.avdl&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..8a18db080&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/test/avro/TestService.avdl&lt;br/&gt;
@@ -0,0 +1,54 @@&lt;br/&gt;
+/**&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+/** An example protocol in Avro IDL */&lt;br/&gt;
+@namespace(&quot;org.apache.avro.grpc.test&quot;)&lt;br/&gt;
+protocol TestService {&lt;br/&gt;
+&lt;br/&gt;
+  enum Kind &lt;/p&gt;
{
+    FOO,
+    BAR,
+    BAZ
+  }
&lt;p&gt;+&lt;br/&gt;
+  fixed MD5(4);&lt;br/&gt;
+&lt;br/&gt;
+  record TestRecord {&lt;br/&gt;
+    @order(&quot;ignore&quot;)&lt;br/&gt;
+    string name;&lt;br/&gt;
+&lt;br/&gt;
+    @order(&quot;descending&quot;)&lt;br/&gt;
+    Kind kind;&lt;br/&gt;
+&lt;br/&gt;
+    MD5 hash;&lt;br/&gt;
+&lt;br/&gt;
+    union &lt;/p&gt;
{ MD5, null}
&lt;p&gt; @aliases(&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;hash&amp;quot;&amp;#93;&lt;/span&gt;) nullableHash;&lt;br/&gt;
+&lt;br/&gt;
+    array&amp;lt;long&amp;gt; arrayOfLongs;&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  error TestError &lt;/p&gt;
{
+    string message;
+  }
&lt;p&gt;+&lt;br/&gt;
+  TestRecord echo(TestRecord `record`);&lt;br/&gt;
+  int add(int arg1, int arg2, int arg3);&lt;br/&gt;
+  void `error`(boolean declared) throws TestError;&lt;br/&gt;
+  void ping() oneway;&lt;br/&gt;
+  union &lt;/p&gt;
{null, string}
&lt;p&gt; concatenate(string val1, boolean val2, long val3, int val4);&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroMarshaller.java b/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroMarshaller.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..2efb42f01&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroMarshaller.java&lt;br/&gt;
@@ -0,0 +1,84 @@&lt;br/&gt;
+/**&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.Protocol;&lt;br/&gt;
+import org.apache.avro.grpc.test.Kind;&lt;br/&gt;
+import org.apache.avro.grpc.test.MD5;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestRecord;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestService;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.ByteArrayInputStream;&lt;br/&gt;
+import java.io.ByteArrayOutputStream;&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.io.InputStream;&lt;br/&gt;
+import java.io.OutputStream;&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+import java.util.Random;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.Drainable;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+&lt;br/&gt;
+public class TestAvroMarshaller {&lt;br/&gt;
+  private final TestRecord record = TestRecord.newBuilder().setName(&quot;foo&quot;).setKind(Kind.FOO)&lt;br/&gt;
+      .setArrayOfLongs(Arrays.asList(42L, 424L, 4242L)).setHash(new MD5(new byte[]&lt;/p&gt;
{4, 2, 4, 2}))&lt;br/&gt;
+      .setNullableHash(null).build();&lt;br/&gt;
+  private final Protocol.Message message = TestService.PROTOCOL.getMessages().get(&quot;echo&quot;);&lt;br/&gt;
+  private Random random = new Random();&lt;br/&gt;
+&lt;br/&gt;
+  private void readPratialAndDrain(int partialToRead, InputStream inputStream, OutputStream target)&lt;br/&gt;
+      throws IOException {&lt;br/&gt;
+    // read specified partial bytes from request InputStream to target and then drain the rest.&lt;br/&gt;
+    for (int i = 0; i &amp;lt; partialToRead; i++) {&lt;br/&gt;
+      int readByte = inputStream.read();&lt;br/&gt;
+      if (readByte &amp;gt;= 0) {
+        target.write(readByte);
+      } else {
+        break;
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+    Drainable drainableRequest = (Drainable) inputStream;&lt;br/&gt;
+    drainableRequest.drainTo(target);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testAvroRequestReadPartialAndDrain() throws IOException {&lt;br/&gt;
+    AvroRequestMarshaller requestMarshaller = new AvroRequestMarshaller(message);&lt;br/&gt;
+    InputStream requestInputStream = requestMarshaller.stream(new Object[]{record});&lt;br/&gt;
+    ByteArrayOutputStream requestOutputStream = new ByteArrayOutputStream();&lt;br/&gt;
+    readPratialAndDrain(random.nextInt(7) + 1, requestInputStream, requestOutputStream);&lt;br/&gt;
+    InputStream serialized = new ByteArrayInputStream(requestOutputStream.toByteArray());&lt;br/&gt;
+    Object[] parsedArgs = requestMarshaller.parse(serialized);&lt;br/&gt;
+    assertEquals(1, parsedArgs.length);&lt;br/&gt;
+    assertEquals(record, parsedArgs&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testAvroResponseReadPartialAndDrain() throws IOException {
+    AvroResponseMarshaller responseMarshaller = new AvroResponseMarshaller(message);
+    InputStream responseInputStream = responseMarshaller.stream(record);
+    ByteArrayOutputStream responseOutputStream = new ByteArrayOutputStream();
+    readPratialAndDrain(random.nextInt(7) + 1, responseInputStream, responseOutputStream);
+    InputStream serialized = new ByteArrayInputStream(responseOutputStream.toByteArray());
+    Object parsedResponse = responseMarshaller.parse(serialized);
+    assertEquals(record, parsedResponse);
+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroProtocolGrpc.java b/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroProtocolGrpc.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 000000000..d11aa3d9b&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/lang/java/grpc/src/test/java/org/apache/avro/grpc/TestAvroProtocolGrpc.java&lt;br/&gt;
@@ -0,0 +1,267 @@&lt;br/&gt;
+/**&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+ * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+ * distributed with this work for additional information&lt;br/&gt;
+ * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+ * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+ * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+ * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.avro.grpc;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.avro.AvroRemoteException;&lt;br/&gt;
+import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
+import org.apache.avro.grpc.test.Kind;&lt;br/&gt;
+import org.apache.avro.grpc.test.MD5;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestError;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestRecord;&lt;br/&gt;
+import org.apache.avro.grpc.test.TestService;&lt;br/&gt;
+import org.apache.avro.ipc.CallFuture;&lt;br/&gt;
+import org.junit.After;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+import java.util.concurrent.CountDownLatch;&lt;br/&gt;
+import java.util.concurrent.ExecutorService;&lt;br/&gt;
+import java.util.concurrent.Executors;&lt;br/&gt;
+import java.util.concurrent.Future;&lt;br/&gt;
+import java.util.concurrent.TimeUnit;&lt;br/&gt;
+import java.util.concurrent.atomic.AtomicInteger;&lt;br/&gt;
+&lt;br/&gt;
+import io.grpc.ManagedChannel;&lt;br/&gt;
+import io.grpc.ManagedChannelBuilder;&lt;br/&gt;
+import io.grpc.Server;&lt;br/&gt;
+import io.grpc.ServerBuilder;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+import static org.junit.Assert.fail;&lt;br/&gt;
+&lt;br/&gt;
+public class TestAvroProtocolGrpc {&lt;br/&gt;
+  private final TestRecord record = TestRecord.newBuilder().setName(&quot;foo&quot;).setKind(Kind.FOO)&lt;br/&gt;
+      .setArrayOfLongs(Arrays.asList(42L, 424L, 4242L)).setHash(new MD5(new byte[]{4, 2, 4, 2}
&lt;p&gt;))&lt;br/&gt;
+      .setNullableHash(null).build();&lt;br/&gt;
+  private final String declaredErrMsg = &quot;Declared error&quot;;&lt;br/&gt;
+  private final String undeclaredErrMsg = &quot;Undeclared error&quot;;&lt;br/&gt;
+  private final TestError declaredError = TestError.newBuilder().setMessage$(declaredErrMsg).build();&lt;br/&gt;
+  private final RuntimeException undeclaredError = new RuntimeException(undeclaredErrMsg);&lt;br/&gt;
+  private CountDownLatch oneWayStart;&lt;br/&gt;
+  private CountDownLatch oneWayDone;&lt;br/&gt;
+  private AtomicInteger oneWayCount;&lt;br/&gt;
+  private TestService stub;&lt;br/&gt;
+  private TestService.Callback callbackStub;&lt;br/&gt;
+  private Server server;&lt;br/&gt;
+  private ManagedChannel channel;&lt;br/&gt;
+&lt;br/&gt;
+  @Before&lt;br/&gt;
+  public void setUp() throws IOException &lt;/p&gt;
{
+    TestService serviceImpl = new TestServiceImplBase();
+    setUpServerAndClient(serviceImpl);
+  }
&lt;p&gt;+&lt;br/&gt;
+  private void setUpServerAndClient(TestService serviceImpl) throws IOException {&lt;br/&gt;
+    if (server != null &amp;amp;&amp;amp; !server.isShutdown()) &lt;/p&gt;
{
+      server.shutdown();
+    }
&lt;p&gt;+    if (channel != null &amp;amp;&amp;amp; !channel.isShutdown()) &lt;/p&gt;
{
+      channel.shutdownNow();
+    }
&lt;p&gt;+    server = ServerBuilder.forPort(0)&lt;br/&gt;
+        .addService(AvroGrpcServer.createServiceDefinition(TestService.class, serviceImpl))&lt;br/&gt;
+        .build();&lt;br/&gt;
+    server.start();&lt;br/&gt;
+    int port = server.getPort();&lt;br/&gt;
+    channel = ManagedChannelBuilder.forAddress(&quot;localhost&quot;, port).usePlaintext(true).build();&lt;br/&gt;
+    stub = AvroGrpcClient.create(channel, TestService.class);&lt;br/&gt;
+    callbackStub = AvroGrpcClient.create(channel, TestService.Callback.class);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @After&lt;br/&gt;
+  public void cleanUp() &lt;/p&gt;
{
+    channel.shutdownNow();
+    server.shutdownNow();
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testEchoRecord() throws Exception &lt;/p&gt;
{
+    TestRecord echoedRecord = stub.echo(record);
+    assertEquals(record, echoedRecord);
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testMultipleArgsAdd() throws Exception &lt;/p&gt;
{
+    int result = stub.add(3, 5, 2);
+    assertEquals(10, result);
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testMultipleArgsConcatenate() throws Exception &lt;/p&gt;
{
+    String val1 = &quot;foo-bar&quot;;
+    Boolean val2 = true;
+    long val3 = 123321L;
+    int val4 = 42;
+    String result = stub.concatenate(val1, val2, val3, val4);
+    assertEquals(val1 + val2 + val3 + val4, result);
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testCallbackInterface() throws Exception &lt;/p&gt;
{
+    CallFuture&amp;lt;TestRecord&amp;gt; future = new CallFuture&amp;lt;TestRecord&amp;gt;();
+    callbackStub.echo(record, future);
+    assertEquals(record, future.get(1, TimeUnit.SECONDS));
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testOneWayRpc() throws Exception &lt;/p&gt;
{
+    oneWayStart = new CountDownLatch(1);
+    oneWayDone = new CountDownLatch(3);
+    oneWayCount = new AtomicInteger();
+    stub.ping();
+    stub.ping();
+    //client is not stalled while server is waiting for processing requests
+    assertEquals(0, oneWayCount.get());
+    oneWayStart.countDown();
+    stub.ping();
+    oneWayDone.await(1, TimeUnit.SECONDS);
+    assertEquals(3, oneWayCount.get());
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testDeclaredError() throws Exception {&lt;br/&gt;
+    try &lt;/p&gt;
{
+      stub.error(true);
+      fail(&quot;Expected exception but none thrown&quot;);
+    }
&lt;p&gt; catch (TestError te) &lt;/p&gt;
{
+      assertEquals(declaredErrMsg, te.getMessage$());
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testUndeclaredError() throws Exception {&lt;br/&gt;
+    try &lt;/p&gt;
{
+      stub.error(false);
+      fail(&quot;Expected exception but none thrown&quot;);
+    }
&lt;p&gt; catch (AvroRuntimeException e) &lt;/p&gt;
{
+      assertTrue(e.getMessage().contains(undeclaredErrMsg));
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testNullableResponse() throws Exception {&lt;br/&gt;
+    setUpServerAndClient(new TestServiceImplBase() {&lt;br/&gt;
+      @Override&lt;br/&gt;
+      public String concatenate(String val1, boolean val2, long val3, int val4)&lt;br/&gt;
+          throws AvroRemoteException &lt;/p&gt;
{
+        return null;
+      }
&lt;p&gt;+    });&lt;br/&gt;
+    String response = stub.concatenate(&quot;foo&quot;, true, 42L, 42);&lt;br/&gt;
+    assertEquals(null, response);&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test(expected = AvroRuntimeException.class)&lt;br/&gt;
+  public void testGrpcConnectionError() throws Exception &lt;/p&gt;
{
+    //close the channel and initiate request
+    channel.shutdownNow();
+    stub.add(0, 1, 2);
+  }
&lt;p&gt;+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testRepeatedRequests() throws Exception {&lt;br/&gt;
+    TestRecord[] echoedRecords = new TestRecord&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    // validate results after all requests are done&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      echoedRecords[i] = stub.echo(record);
+    }
&lt;p&gt;+    for (TestRecord result : echoedRecords) &lt;/p&gt;
{
+      assertEquals(record, result);
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testConcurrentClientAccess() throws Exception {&lt;br/&gt;
+    ExecutorService es = Executors.newCachedThreadPool();&lt;br/&gt;
+    Future&amp;lt;TestRecord&amp;gt;[] records = new Future&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    Future&amp;lt;Integer&amp;gt;[] adds = new Future&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    //submit requests in parallel&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      records[i] = es.submit(() -&amp;gt; stub.echo(record));
+      int j = i;
+      adds[i] = es.submit(() -&amp;gt; stub.add(j, 2 * j, 3 * j));
+    }
&lt;p&gt;+    //validate all results&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      assertEquals(record, records[i].get());
+      assertEquals(6 * i, (long) adds[i].get());
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  public void testConcurrentChannels() throws Exception {&lt;br/&gt;
+    ManagedChannel otherChannel = ManagedChannelBuilder.forAddress(&quot;localhost&quot;, server.getPort())&lt;br/&gt;
+        .usePlaintext(true).build();&lt;br/&gt;
+    TestService otherStub = AvroGrpcClient.create(otherChannel, TestService.class);&lt;br/&gt;
+    Future&amp;lt;Integer&amp;gt;[] adds = new Future&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    Future&amp;lt;Integer&amp;gt;[] otherAdds = new Future&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    ExecutorService es = Executors.newCachedThreadPool();&lt;br/&gt;
+    //submit requests on clients with different channels&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      int j = i;
+      adds[i] = es.submit(() -&amp;gt; stub.add(j, j - 1, j - 2));
+      otherAdds[i] = es.submit(() -&amp;gt; otherStub.add(j, j + 1, j + 2));
+    }
&lt;p&gt;+    //validate all results&lt;br/&gt;
+    for (int i = 0; i &amp;lt; 5; i++) &lt;/p&gt;
{
+      assertEquals((3 * i) - 3, (long) adds[i].get());
+      assertEquals((3 * i) + 3, (long) otherAdds[i].get());
+    }
&lt;p&gt;+    otherChannel.shutdownNow();&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private class TestServiceImplBase implements TestService {&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public TestRecord echo(TestRecord record) throws AvroRemoteException &lt;/p&gt;
{
+      return record;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public int add(int arg1, int arg2, int arg3) throws AvroRemoteException &lt;/p&gt;
{
+      return arg1 + arg2 + arg3;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public Void error(boolean declared) throws AvroRemoteException, TestError {&lt;br/&gt;
+      if (declared) &lt;/p&gt;
{
+        throw declaredError;
+      }
&lt;p&gt;+      throw undeclaredError;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void ping() {&lt;br/&gt;
+      try &lt;/p&gt;
{
+        oneWayStart.await();
+        oneWayCount.incrementAndGet();
+        oneWayDone.countDown();
+      }
&lt;p&gt; catch (InterruptedException e) &lt;/p&gt;
{
+        fail(&quot;thread interrupted when waiting for all one-way messages&quot;);
+      }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public String concatenate(String val1, boolean val2, long val3, int val4) throws AvroRemoteException &lt;/p&gt;
{
+      return val1 + val2 + val3 + val4;
+    }
&lt;p&gt;+  }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/lang/java/pom.xml b/lang/java/pom.xml&lt;br/&gt;
index 2d1df1f1c..78abcdcbf 100644&lt;br/&gt;
&amp;#8212; a/lang/java/pom.xml&lt;br/&gt;
+++ b/lang/java/pom.xml&lt;br/&gt;
@@ -61,6 +61,7 @@&lt;br/&gt;
     &amp;lt;easymock.version&amp;gt;3.4&amp;lt;/easymock.version&amp;gt;&lt;br/&gt;
     &amp;lt;hamcrest.version&amp;gt;1.3&amp;lt;/hamcrest.version&amp;gt;&lt;br/&gt;
     &amp;lt;joda.version&amp;gt;2.9.7&amp;lt;/joda.version&amp;gt;&lt;br/&gt;
+    &amp;lt;grpc.version&amp;gt;1.7.0&amp;lt;/grpc.version&amp;gt;&lt;br/&gt;
     &amp;lt;!-- This Guava version should match Hadoop&apos;s Guava version. See &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1781&quot; title=&quot;Schema.parse is not thread safe&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1781&quot;&gt;&lt;del&gt;AVRO-1781&lt;/del&gt;&lt;/a&gt;. --&amp;gt;&lt;br/&gt;
     &amp;lt;guava.version&amp;gt;11.0.2&amp;lt;/guava.version&amp;gt;&lt;br/&gt;
     &amp;lt;findbugs-annotations.version&amp;gt;1.3.9-1&amp;lt;/findbugs-annotations.version&amp;gt;&lt;br/&gt;
@@ -94,6 +95,7 @@&lt;br/&gt;
     &amp;lt;module&amp;gt;protobuf&amp;lt;/module&amp;gt;&lt;br/&gt;
     &amp;lt;module&amp;gt;thrift&amp;lt;/module&amp;gt;&lt;br/&gt;
     &amp;lt;module&amp;gt;archetypes&amp;lt;/module&amp;gt;&lt;br/&gt;
+    &amp;lt;module&amp;gt;grpc&amp;lt;/module&amp;gt;&lt;br/&gt;
   &amp;lt;/modules&amp;gt;&lt;/p&gt;

&lt;p&gt;   &amp;lt;build&amp;gt;&lt;br/&gt;
@@ -464,6 +466,16 @@&lt;br/&gt;
         &amp;lt;artifactId&amp;gt;joda-time&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
         &amp;lt;version&amp;gt;${joda.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
       &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;dependency&amp;gt;&lt;br/&gt;
+        &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+        &amp;lt;artifactId&amp;gt;grpc-stub&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+        &amp;lt;version&amp;gt;${grpc.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+      &amp;lt;/dependency&amp;gt;&lt;br/&gt;
+      &amp;lt;dependency&amp;gt;&lt;br/&gt;
+        &amp;lt;groupId&amp;gt;io.grpc&amp;lt;/groupId&amp;gt;&lt;br/&gt;
+        &amp;lt;artifactId&amp;gt;grpc-netty&amp;lt;/artifactId&amp;gt;&lt;br/&gt;
+        &amp;lt;version&amp;gt;${grpc.version}&amp;lt;/version&amp;gt;&lt;br/&gt;
+      &amp;lt;/dependency&amp;gt;&lt;br/&gt;
     &amp;lt;/dependencies&amp;gt;&lt;br/&gt;
   &amp;lt;/dependencyManagement&amp;gt;&lt;/p&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16461374" author="jira-bot" created="Wed, 2 May 2018 17:41:51 +0000"  >&lt;p&gt;Commit 0f25ed1f6a78ad0356f4d0202f570cf09ed3f601 in avro&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=srujann&quot; class=&quot;user-hover&quot; rel=&quot;srujann&quot;&gt;Srujan Narkedamalli&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=avro.git;h=0f25ed1&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://gitbox.apache.org/repos/asf?p=avro.git;h=0f25ed1&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2172&quot; title=&quot;Avro over gRPC (Java Implementation)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2172&quot;&gt;&lt;del&gt;AVRO-2172&lt;/del&gt;&lt;/a&gt;: Avro binding for gRPC to enable avro based schema and RPC IDL to be transported over gRPC.&lt;/p&gt;</comment>
                            <comment id="16461375" author="jira-bot" created="Wed, 2 May 2018 17:41:52 +0000"  >&lt;p&gt;Commit d5eeeed469fc7de4e141042da9b347d18c084b9e in avro&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cutting&quot; class=&quot;user-hover&quot; rel=&quot;cutting&quot;&gt;Doug Cutting&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=avro.git;h=d5eeeed&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://gitbox.apache.org/repos/asf?p=avro.git;h=d5eeeed&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;Merge pull request #308 from wavefrontHQ/avro-grpc&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2172&quot; title=&quot;Avro over gRPC (Java Implementation)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2172&quot;&gt;&lt;del&gt;AVRO-2172&lt;/del&gt;&lt;/a&gt;: Avro binding for gRPC (Java Implementation)&lt;/p&gt;</comment>
                            <comment id="16461377" author="cutting" created="Wed, 2 May 2018 17:42:23 +0000"  >&lt;p&gt;I committed this. Thanks, Srujan!&lt;/p&gt;</comment>
                            <comment id="16461482" author="srujann" created="Wed, 2 May 2018 18:41:03 +0000"  >&lt;p&gt;Thanks for accepting this contribution. We are very excited to have&#160;this on Avro.&lt;/p&gt;

&lt;p&gt;A question on when we can being to use the avro-grpc artifact,&#160;do you know the release date for Avro 1.9.0?&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="16463024" author="cutting" created="Thu, 3 May 2018 20:45:50 +0000"  >&lt;p&gt;I hope we can get a 1.9.0 release out soon.&#160; Watch the dev list for details.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 1 May 2018 16:31:12 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            37 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3t4ef:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>
