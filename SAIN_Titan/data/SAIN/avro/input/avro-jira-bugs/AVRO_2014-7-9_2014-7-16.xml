<!--
RSS generated by JIRA (7.6.3#76005-sha1:8a4e38d34af948780dbf52044e7aafb13a7cae58) at Mon Jan 21 19:20:33 UTC 2019

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<!-- If you wish to do custom client-side styling of RSS, uncomment this:
<?xml-stylesheet href="https://issues.apache.org/jira/styles/jiraxml2html.xsl" type="text/xsl"?>
-->
<rss version="0.92">
    <channel>
        <title>ASF JIRA</title>
        <link>https://issues.apache.org/jira/issues/?jql=project+%3D+AVRO+AND+created+%3E%3D+2014-7-9+AND+created+%3C%3D+2014-7-16+ORDER+BY+key+ASC</link>
        <description>An XML representation of a search request</description>
                <language>en-uk</language>
                        <issue start="0" end="6" total="6"/>
                <build-info>
            <version>7.6.3</version>
            <build-number>76005</build-number>
            <build-date>09-01-2018</build-date>
        </build-info>

<item>
            <title>[AVRO-1540] C++ doesn&apos;t build in Ubuntu</title>
                <link>https://issues.apache.org/jira/browse/AVRO-1540</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;It is because &lt;tt&gt;uint8_t&lt;/tt&gt; type is not available in GenericDatum.hh&lt;/p&gt;</description>
                <environment></environment>
        <key id="12726750">AVRO-1540</key>
            <summary>C++ doesn&apos;t build in Ubuntu</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="thiru_mg">Thiruvalluvan M. G.</assignee>
                                    <reporter username="thiru_mg">Thiruvalluvan M. G.</reporter>
                        <labels>
                    </labels>
                <created>Fri, 11 Jul 2014 08:12:09 +0000</created>
                <updated>Thu, 24 Jul 2014 20:16:24 +0000</updated>
                            <resolved>Tue, 15 Jul 2014 18:33:42 +0000</resolved>
                                                    <fixVersion>1.7.7</fixVersion>
                                    <component>c++</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="14058571" author="thiru_mg" created="Fri, 11 Jul 2014 09:03:35 +0000"  >&lt;p&gt;Tested the patch on Ubuntu 13.04 and Macos 10.9.4.&lt;/p&gt;</comment>
                            <comment id="14062267" author="cutting" created="Tue, 15 Jul 2014 16:27:34 +0000"  >&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;This patch fixes Avro C++ so that it compiles and tests pass on Ubuntu 12.04.&lt;/p&gt;</comment>
                            <comment id="14062457" author="thiru_mg" created="Tue, 15 Jul 2014 18:33:42 +0000"  >&lt;p&gt;Committed revision 1610798.&lt;/p&gt;

&lt;p&gt;Thank you Doug.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12655179" name="AVRO-1540.patch" size="876" author="thiru_mg" created="Fri, 11 Jul 2014 08:57:54 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 15 Jul 2014 16:27:34 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>404857</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 27 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1xocn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>404895</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>


<item>
            <title>[AVRO-1541] Specific.hh is over-specialized for standard C++ containers</title>
                <link>https://issues.apache.org/jira/browse/AVRO-1541</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;The encoders in Specific.hh for the C++ stdlib types like string, vector, etc. are over-specialized and take only specific variations of these templated templates. The specializations of codec_traits should be partial specializations to support std::string, std::vector, std::map, and so on using user-specific allocators and (for std:set and std::map) a user-specific comparator, as Avro has absolutely no reason to care about these details.&lt;/p&gt;

&lt;p&gt;These partial specializations will not require any API incompatible breaks.  They&apos;d look something like:&lt;/p&gt;

&lt;p&gt;template &amp;lt;typename T, typename Allocator&amp;gt;&lt;br/&gt;
template &amp;lt;&amp;gt;&lt;br/&gt;
struct codec_traits&amp;lt;std::vector&amp;lt;T, Allocator&amp;gt; &amp;gt; {&lt;br/&gt;
  void encode(Encoder&amp;amp; e, const std::vector&amp;lt;T, Allocator&amp;gt;&amp;amp; s) &lt;/p&gt;
{
    // ... 
  }&lt;br/&gt;
  void encode(Encoder&amp;amp; d, std::vector&amp;lt;T, Allocator&amp;gt;&amp;amp; s) {    // ...   }
&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;std::string could be the trickier one since it should probably be a partial specialization over the supported variants of basic_string, though partial specialization of std::string, std::u16string, std::u32string, and std::wstring (which can all have custom allocators).&lt;/p&gt;

&lt;p&gt;Don&apos;t forget that std::set and std::map can have both a custom allocator and a custom comparator.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12726912">AVRO-1541</key>
            <summary>Specific.hh is over-specialized for standard C++ containers</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21140&amp;avatarType=issuetype">Improvement</type>
                                            <priority id="5" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.svg">Trivial</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="thiru_mg">Thiruvalluvan M. G.</assignee>
                                    <reporter username="wgs_smiddleditch">Sean Middleditch</reporter>
                        <labels>
                    </labels>
                <created>Sat, 12 Jul 2014 00:56:38 +0000</created>
                <updated>Thu, 17 Jan 2019 02:21:42 +0000</updated>
                                            <version>1.7.6</version>
                                                    <component>c++</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="16727994" author="thiru_mg" created="Sun, 23 Dec 2018 16:31:14 +0000"  >&lt;p&gt;Good observation.&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;Specifc.hh&lt;/tt&gt; kind of fixes&#160;C++ types for various Avro types. Apart from obvious mappings for &lt;tt&gt;bool&lt;/tt&gt;, &lt;tt&gt;int&lt;/tt&gt;, &lt;tt&gt;long&lt;/tt&gt; etc, it fixes &lt;tt&gt;std::string&lt;/tt&gt; for Avro string, &lt;tt&gt;std::vector&amp;lt;uint8_t&amp;gt;&lt;/tt&gt; for Avro bytes and &lt;tt&gt;boost::array&amp;lt;uint8_t, &amp;gt;&lt;/tt&gt; for Avro fixed. For composite types - Avro array and map - it uses &lt;tt&gt;std::vector&amp;lt;T&amp;gt;&lt;/tt&gt; and &lt;tt&gt;std::map&amp;lt;std::string, T&amp;gt;&lt;/tt&gt;. The user has no control over the choice of these C++ types when generating code using &lt;tt&gt;avrogencpp&lt;/tt&gt; tool. It will be an interesting project to generalize this to allow the user to specify a compatible C++ while generating the code.&lt;/p&gt;

&lt;p&gt;Now &lt;tt&gt;codec_traits&lt;/tt&gt; exists to enable easy compile-time support for the generated code and since the C++ types corresponding to Avro types is fixed, the specializations for &lt;tt&gt;codec_traits&lt;/tt&gt; are sufficient. But as &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=wgs_smiddleditch&quot; class=&quot;user-hover&quot; rel=&quot;wgs_smiddleditch&quot;&gt;Sean Middleditch&lt;/a&gt; points out, these specializations are too narrow and if widened, they can be used for other purposes even if we do not allow the user to choose C++ types during code generation.&lt;/p&gt;

&lt;p&gt;The above observation is true for &lt;tt&gt;Generic.hh&lt;/tt&gt; as well, except that for Avro record and other types, it does not have specific generated classes but rather uses &lt;tt&gt;GenericRecord&lt;/tt&gt; and so on. But given the nature of use of &lt;tt&gt;Generic.hh&lt;/tt&gt;, customizability will not be of great use and hence no further work is needed.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 23 Dec 2018 16:31:14 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405019</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1xpc7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405055</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>


<item>
            <title>[AVRO-1542] std::auto_ptr</title>
                <link>https://issues.apache.org/jira/browse/AVRO-1542</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;std::auto_ptr is deprecated, meaning that it may be removed from a future version of the C++ standard (though vendors would not likely remove it... probably).&lt;/p&gt;

&lt;p&gt;Avro should at its next API-breaking opportunity replace its use of auto_ptr with std::unique_ptr or shared_ptr or a custom smart pointer.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12726915">AVRO-1542</key>
            <summary>std::auto_ptr</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21140&amp;avatarType=issuetype">Improvement</type>
                                            <priority id="5" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.svg">Trivial</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dkulp">Daniel Kulp</assignee>
                                    <reporter username="wgs_smiddleditch">Sean Middleditch</reporter>
                        <labels>
                    </labels>
                <created>Sat, 12 Jul 2014 01:01:49 +0000</created>
                <updated>Tue, 4 Dec 2018 17:01:40 +0000</updated>
                            <resolved>Tue, 4 Dec 2018 17:01:40 +0000</resolved>
                                    <version>1.7.6</version>
                                    <fixVersion>1.9.0</fixVersion>
                                    <component>c++</component>
                        <due></due>
                            <votes>3</votes>
                                    <watches>7</watches>
                                                                <comments>
                            <comment id="15667573" author="githubbot" created="Tue, 15 Nov 2016 16:27:00 +0000"  >&lt;p&gt;GitHub user sanjosh opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/avro/pull/157&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/157&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt; replacing auto_ptr by unique_ptr &amp;amp; std::move&lt;/p&gt;


&lt;p&gt;    Please verify &lt;br/&gt;
    1) addition of flags to CMakeLists.txt and &lt;br/&gt;
    2) one case where auto_ptr was being passed by reference but is now changed to pass unique_ptr by value in lang/c++/impl/FileStream.cc  : 193&lt;/p&gt;

&lt;p&gt;    all tests passed in my local build&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/sanjosh/avro&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/sanjosh/avro&lt;/a&gt; master&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/avro/pull/157.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/157.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #157&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit b26e3431bcbde97470d38bdb0e5470b0f1a60086&lt;br/&gt;
Author: Sandeep Joshi &amp;lt;sanjos100@gmail.com&amp;gt;&lt;br/&gt;
Date:   2016-09-20T07:30:27Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt; replacing auto_ptr by unique_ptr &amp;amp; std::move&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15897217" author="githubbot" created="Mon, 6 Mar 2017 12:51:23 +0000"  >&lt;p&gt;GitHub user ecatmur opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/avro/pull/203&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;/p&gt;

&lt;p&gt;    Replace deprecated std::auto_ptr with boost::movelib::unique_ptr.&lt;/p&gt;

&lt;p&gt;    &amp;gt; boost::movelib::unique_ptr is a drop-in replacement for std::unique_ptr, usable also from C++03 compilers.&lt;/p&gt;

&lt;p&gt;    This supersedes &lt;a href=&quot;https://github.com/apache/avro/pull/157&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/157&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Note that some deprecation warnings remain because of transitive includes through Boost libraries (ptr_vector, iostreams) depending on Boost version.&lt;/p&gt;

&lt;p&gt;    Tested in C+&lt;ins&gt;11 mode with gcc 5.4.0, in C&lt;/ins&gt;+03 mode with gcc 4.9.2.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/ecatmur/avro&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/ecatmur/avro&lt;/a&gt; avro-1542&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/avro/pull/203.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #203&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit a985b4daa8ee309948e6470ab64207ddf31bdea7&lt;br/&gt;
Author: Edward Catmur &amp;lt;edward.catmur@mavensecurities.com&amp;gt;&lt;br/&gt;
Date:   2017-03-06T11:53:05Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr with boost::movelib::unique_ptr&lt;/p&gt;

&lt;p&gt;commit 86a84f6b3ddd4d0fd8b3a28acd124a9dab8e4600&lt;br/&gt;
Author: Edward Catmur &amp;lt;edward.catmur@mavensecurities.com&amp;gt;&lt;br/&gt;
Date:   2017-03-06T12:35:19Z&lt;/p&gt;

&lt;p&gt;    Missed some cases&lt;/p&gt;

&lt;p&gt;commit ec225fba9dc57e19f6af26876d261dacf9c0775a&lt;br/&gt;
Author: Edward Catmur &amp;lt;edward.catmur@mavensecurities.com&amp;gt;&lt;br/&gt;
Date:   2017-03-06T12:38:36Z&lt;/p&gt;

&lt;p&gt;    Missed some cases&lt;/p&gt;

&lt;p&gt;commit ff3ddcd9e2697b299181eaca8b3a7607ac9ef8f1&lt;br/&gt;
Author: Edward Catmur &amp;lt;edward.catmur@mavensecurities.com&amp;gt;&lt;br/&gt;
Date:   2017-03-06T12:50:21Z&lt;/p&gt;

&lt;p&gt;    C++03 fix&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16416377" author="githubbot" created="Tue, 27 Mar 2018 22:54:36 +0000"  >&lt;p&gt;dbenson2000 commented on issue #203: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/203#issuecomment-376702050&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203#issuecomment-376702050&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Is there a plan to move forward with this change or &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;?&lt;br/&gt;
   Not sure why in 2018 Avro is concerned about supporting compilers which don&apos;t support C+&lt;ins&gt;11. By doing nothing you&apos;re preventing users from adopting C&lt;/ins&gt;+17.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16469302" author="githubbot" created="Wed, 9 May 2018 18:56:22 +0000"  >&lt;p&gt;dbenson2000 commented on issue #203: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/203#issuecomment-387840665&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203#issuecomment-387840665&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   @ecatmur which version of Boost did you build with?&lt;/p&gt;

&lt;p&gt;   I&apos;m attempting to use Boost 1.66 from vcpkg. I can build avro cpp library ok, but when building a project which utilizes Avro in VS2017, I get errors from boost about using auto_ptr&lt;/p&gt;

&lt;p&gt;   1&amp;gt;...\include\boost\ptr_container\detail\reversible_ptr_container.hpp(350): error C2061: syntax error: identifier &apos;auto_ptr&apos;&lt;/p&gt;

&lt;p&gt;   My code pulls in avro/DataFile.hh, which references ultimately includes #include &amp;lt;boost/ptr_container/ptr_vector.hpp&amp;gt;&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16469409" author="githubbot" created="Wed, 9 May 2018 20:13:43 +0000"  >&lt;p&gt;dbenson2000 commented on issue #203: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/203#issuecomment-387840665&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203#issuecomment-387840665&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   @ecatmur which version of Boost did you build with?&lt;/p&gt;

&lt;p&gt;   I&apos;m attempting to use Boost 1.66 from vcpkg. I can build avro cpp library ok, but when building a project which utilizes Avro in VS2017, I get errors from boost about using auto_ptr&lt;/p&gt;

&lt;p&gt;   1&amp;gt;...\include\boost\ptr_container\detail\reversible_ptr_container.hpp(350): error C2061: syntax error: identifier &apos;auto_ptr&apos;&lt;/p&gt;

&lt;p&gt;   My code pulls in avro/DataFile.hh, which references ultimately includes #include &amp;lt;boost/ptr_container/ptr_vector.hpp&amp;gt;&lt;/p&gt;

&lt;p&gt;   Edit: I set AVRO_BOOST_NO_PTRVECTOR to avoid this issue for now&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16470963" author="githubbot" created="Thu, 10 May 2018 19:04:52 +0000"  >&lt;p&gt;ecatmur commented on issue #203: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/203#issuecomment-388153429&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203#issuecomment-388153429&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   @dbenson2000 yes, that would work. VS2017 in C+&lt;ins&gt;17 mode removes `auto_ptr`, but it is present (though deprecated) in C&lt;/ins&gt;&lt;ins&gt;14 mode (`/std:c&lt;/ins&gt;&lt;ins&gt;14`). Boost.PtrContainer supports C&lt;/ins&gt;+17 removal of `auto_ptr` from Boost 1.67, after &lt;a href=&quot;https://github.com/boostorg/ptr_container/pull/8&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/boostorg/ptr_container/pull/8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16533818" author="githubbot" created="Thu, 5 Jul 2018 15:36:59 +0000"  >&lt;p&gt;gnarlie commented on issue #203: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/203#issuecomment-402763927&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203#issuecomment-402763927&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Are there any plans to go forward with this patch to remove obsolete usages of auto_ptr? Compiling with C++17 (clang, and I assume gcc) requires some nasty work-arounds compiling from master.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16561201" author="githubbot" created="Sun, 29 Jul 2018 17:37:00 +0000"  >&lt;p&gt;thiru-apache commented on issue #203: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/203#issuecomment-408693212&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203#issuecomment-408693212&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   The patch looks good. Since this is backwards incompatible change, we can merge this for Avro 1.9.0.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16708986" author="jira-bot" created="Tue, 4 Dec 2018 16:59:01 +0000"  >&lt;p&gt;Commit 0e6df4837b1032a51e7fd85c95451781991d4856 in avro&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=sanjosh&quot; class=&quot;user-hover&quot; rel=&quot;sanjosh&quot;&gt;Sandeep Joshi&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=avro.git;h=0e6df48&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://gitbox.apache.org/repos/asf?p=avro.git;h=0e6df48&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt; replacing auto_ptr by unique_ptr &amp;amp; std::move&lt;br/&gt;
This closes #157&lt;/p&gt;</comment>
                            <comment id="16708987" author="githubbot" created="Tue, 4 Dec 2018 16:59:09 +0000"  >&lt;p&gt;dkulp closed pull request #157: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt; replacing auto_ptr by unique_ptr &amp;amp; std::move&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/157&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/157&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/CMakeLists.txt b/lang/c&lt;/ins&gt;+/CMakeLists.txt&lt;br/&gt;
index e8efe86dd..70dc7c719 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/CMakeLists.txt&lt;br/&gt;
+++ b/lang/c++/CMakeLists.txt&lt;br/&gt;
@@ -37,6 +37,8 @@ set (AVRO_VERSION_MINOR &quot;0&quot;)&lt;/p&gt;

&lt;p&gt; project (Avro-cpp)&lt;/p&gt;

&lt;p&gt;&lt;ins&gt;add_definitions(-std=c&lt;/ins&gt;+11 -fPIC)&lt;br/&gt;
+&lt;br/&gt;
 if (WIN32 AND NOT CYGWIN AND NOT MSYS)&lt;br/&gt;
 add_definitions (/EHa)&lt;br/&gt;
 add_definitions (&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/api/DataFile.hh b/lang/c&lt;/ins&gt;+/api/DataFile.hh&lt;br/&gt;
index 98779b6b1..7047cc87b 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/api/DataFile.hh&lt;br/&gt;
+++ b/lang/c++/api/DataFile.hh&lt;br/&gt;
@@ -60,8 +60,8 @@ class AVRO_DECL DataFileWriterBase : boost::noncopyable {&lt;br/&gt;
     const size_t syncInterval_;&lt;br/&gt;
     Codec codec_;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; stream_;&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; buffer_;&lt;br/&gt;
+    std::unique_ptr&amp;lt;OutputStream&amp;gt; stream_;&lt;br/&gt;
+    std::unique_ptr&amp;lt;OutputStream&amp;gt; buffer_;&lt;br/&gt;
     const DataFileSync sync_;&lt;br/&gt;
     int64_t objectCount_;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -69,7 +69,7 @@ class AVRO_DECL DataFileWriterBase : boost::noncopyable {&lt;/p&gt;

&lt;p&gt;     Metadata metadata_;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;static std::auto_ptr&amp;lt;OutputStream&amp;gt; makeStream(const char* filename);&lt;br/&gt;
+    static std::unique_ptr&amp;lt;OutputStream&amp;gt; makeStream(const char* filename);&lt;br/&gt;
     static DataFileSync makeSync();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     void writeHeader();&lt;br/&gt;
@@ -127,7 +127,7 @@ public:&lt;br/&gt;
  */&lt;br/&gt;
 template &amp;lt;typename T&amp;gt;&lt;br/&gt;
 class DataFileWriter : boost::noncopyable {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;DataFileWriterBase&amp;gt; base_;&lt;br/&gt;
+    std::unique_ptr&amp;lt;DataFileWriterBase&amp;gt; base_;&lt;br/&gt;
 public:&lt;br/&gt;
     /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs a new data file.&lt;br/&gt;
@@ -167,7 +167,7 @@ public:&lt;br/&gt;
  */&lt;br/&gt;
 class AVRO_DECL DataFileReaderBase : boost::noncopyable {&lt;br/&gt;
     const std::string filename_;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;const std::auto_ptr&amp;lt;InputStream&amp;gt; stream_;&lt;br/&gt;
+    const std::unique_ptr&amp;lt;InputStream&amp;gt; stream_;&lt;br/&gt;
     const DecoderPtr decoder_;&lt;br/&gt;
     int64_t objectCount_;&lt;br/&gt;
     bool eof_;&lt;br/&gt;
@@ -176,7 +176,7 @@ class AVRO_DECL DataFileReaderBase : boost::noncopyable {&lt;br/&gt;
     ValidSchema readerSchema_;&lt;br/&gt;
     ValidSchema dataSchema_;&lt;br/&gt;
     DecoderPtr dataDecoder_;&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; dataStream_;&lt;br/&gt;
+    std::unique_ptr&amp;lt;InputStream&amp;gt; dataStream_;&lt;br/&gt;
     typedef std::map&amp;lt;std::string, std::vector&amp;lt;uint8_t&amp;gt; &amp;gt; Metadata;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     Metadata metadata_;&lt;br/&gt;
@@ -249,7 +249,7 @@ public:&lt;br/&gt;
  */&lt;br/&gt;
 template &amp;lt;typename T&amp;gt;&lt;br/&gt;
 class DataFileReader : boost::noncopyable {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;DataFileReaderBase&amp;gt; base_;&lt;br/&gt;
+    std::unique_ptr&amp;lt;DataFileReaderBase&amp;gt; base_;&lt;br/&gt;
 public:&lt;br/&gt;
     /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs the reader for the given file and the reader is&lt;br/&gt;
@@ -279,7 +279,7 @@ public:&lt;/li&gt;
	&lt;li&gt;The schema present in the data file will be used for reading&lt;/li&gt;
	&lt;li&gt;from this reader.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DataFileReader(std::auto_ptr&amp;lt;DataFileReaderBase&amp;gt; base) : base_(base) {&lt;br/&gt;
+    DataFileReader(std::unique_ptr&amp;lt;DataFileReaderBase&amp;gt; base) : base_(std::move(base)) 
{
         base_-&amp;gt;init();
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -292,8 +292,8 @@ public:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The argument readerSchema will be used for reading&lt;/li&gt;
	&lt;li&gt;from this reader.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DataFileReader(std::auto_ptr&amp;lt;DataFileReaderBase&amp;gt; base,&lt;/li&gt;
	&lt;li&gt;const ValidSchema&amp;amp; readerSchema) : base_(base) {&lt;br/&gt;
+    DataFileReader(std::unique_ptr&amp;lt;DataFileReaderBase&amp;gt; base,&lt;br/&gt;
+        const ValidSchema&amp;amp; readerSchema) : base_(std::move(base)) 
{
         base_-&amp;gt;init(readerSchema);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/api/Stream.hh b/lang/c&lt;/ins&gt;+/api/Stream.hh&lt;br/&gt;
index 92b2334d2..2ca84c078 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/api/Stream.hh&lt;br/&gt;
+++ b/lang/c++/api/Stream.hh&lt;br/&gt;
@@ -122,14 +122,14 @@ public:&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a new OutputStream, which grows in memory chunks of specified size.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;OutputStream&amp;gt; memoryOutputStream(size_t chunkSize = 4 * 1024);&lt;br/&gt;
+AVRO_DECL std::unique_ptr&amp;lt;OutputStream&amp;gt; memoryOutputStream(size_t chunkSize = 4 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a new InputStream, with the data from the given byte array.&lt;/li&gt;
	&lt;li&gt;It does not copy the data, the byte array should remain valid&lt;/li&gt;
	&lt;li&gt;until the InputStream is used.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size_t len);&lt;br/&gt;
+AVRO_DECL std::unique_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size_t len);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a new InputStream with the contents written into an&lt;br/&gt;
@@ -138,7 +138,7 @@ AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size&lt;/li&gt;
	&lt;li&gt;input stream are the snapshot of the outputstream. One can construct&lt;/li&gt;
	&lt;li&gt;any number of memory input stream from a single memory output stream.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const OutputStream&amp;amp; source);&lt;br/&gt;
+AVRO_DECL std::unique_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const OutputStream&amp;amp; source);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns the contents written so far into the output stream, which should&lt;br/&gt;
@@ -154,14 +154,14 @@ AVRO_DECL boost::shared_ptr&amp;lt;std::vector&amp;lt;uint8_t&amp;gt; &amp;gt; snapshot(const OutputStream&amp;amp;&lt;/li&gt;
	&lt;li&gt;If there is a file with the given name, it is truncated and overwritten.&lt;/li&gt;
	&lt;li&gt;If there is no file with the given name, it is created.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;OutputStream&amp;gt; fileOutputStream(const char* filename,&lt;br/&gt;
+AVRO_DECL std::unique_ptr&amp;lt;OutputStream&amp;gt; fileOutputStream(const char* filename,&lt;br/&gt;
     size_t bufferSize = 8 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a new InputStream whose contents come from the given file.&lt;/li&gt;
	&lt;li&gt;Data is read in chunks of given buffer size.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;br/&gt;
+AVRO_DECL std::unique_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;br/&gt;
     size_t bufferSize = 8 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;br/&gt;
@@ -169,7 +169,7 @@ AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;std::ostream. The std::ostream object should outlive the returned&lt;/li&gt;
	&lt;li&gt;OutputStream.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(std::ostream&amp;amp; os,&lt;br/&gt;
+AVRO_DECL std::unique_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(std::ostream&amp;amp; os,&lt;br/&gt;
     size_t bufferSize = 8 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;br/&gt;
@@ -177,7 +177,7 @@ AVRO_DECL std::auto_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(std::ostream&amp;amp; os,&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;std::istream. The std::istream object should outlive the returned&lt;/li&gt;
	&lt;li&gt;InputStream.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; istreamInputStream(std::istream&amp;amp; in,&lt;br/&gt;
+AVRO_DECL std::unique_ptr&amp;lt;InputStream&amp;gt; istreamInputStream(std::istream&amp;amp; in,&lt;br/&gt;
     size_t bufferSize = 8 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /** A convenience class for reading from an InputStream */&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/examples/custom.cc b/lang/c&lt;/ins&gt;+/examples/custom.cc&lt;br/&gt;
index cfdbeab96..4f6fdb2eb 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/examples/custom.cc&lt;br/&gt;
+++ b/lang/c++/examples/custom.cc&lt;br/&gt;
@@ -42,13 +42,13 @@ struct codec_traits&amp;lt;std::complex&amp;lt;T&amp;gt; &amp;gt; {&lt;br/&gt;
 int&lt;br/&gt;
 main()&lt;br/&gt;
 {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::binaryEncoder();&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     std::complex&amp;lt;double&amp;gt; c1(1.0, 2.0);&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::binaryDecoder();&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/examples/generated.cc b/lang/c&lt;/ins&gt;+/examples/generated.cc&lt;br/&gt;
index ab93ad209..6a07a7bb9 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/examples/generated.cc&lt;br/&gt;
+++ b/lang/c++/examples/generated.cc&lt;br/&gt;
@@ -24,7 +24,7 @@&lt;br/&gt;
 int&lt;br/&gt;
 main()&lt;br/&gt;
 {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::binaryEncoder();&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     c::cpx c1;&lt;br/&gt;
@@ -32,7 +32,7 @@ main()&lt;br/&gt;
     c1.im = 2.13;&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::binaryDecoder();&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/examples/generic.cc b/lang/c&lt;/ins&gt;+/examples/generic.cc&lt;br/&gt;
index 12c171fe5..63d707884 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/examples/generic.cc&lt;br/&gt;
+++ b/lang/c++/examples/generic.cc&lt;br/&gt;
@@ -35,7 +35,7 @@ main()&lt;br/&gt;
     avro::ValidSchema cpxSchema;&lt;br/&gt;
     avro::compileJsonSchema(ifs, cpxSchema);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::binaryEncoder();&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     c::cpx c1;&lt;br/&gt;
@@ -43,7 +43,7 @@ main()&lt;br/&gt;
     c1.im = 105.77;&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::binaryDecoder();&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/examples/resolving.cc b/lang/c&lt;/ins&gt;+/examples/resolving.cc&lt;br/&gt;
index a35eb344b..94efade8a 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/examples/resolving.cc&lt;br/&gt;
+++ b/lang/c++/examples/resolving.cc&lt;br/&gt;
@@ -43,7 +43,7 @@ main()&lt;br/&gt;
     avro::ValidSchema cpxSchema = load(&quot;cpx.json&quot;);&lt;br/&gt;
     avro::ValidSchema imaginarySchema = load(&quot;imaginary.json&quot;);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::binaryEncoder();&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     c::cpx c1;&lt;br/&gt;
@@ -51,7 +51,7 @@ main()&lt;br/&gt;
     c1.im = 105.77;&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::resolvingDecoder(cpxSchema, imaginarySchema,&lt;br/&gt;
         avro::binaryDecoder());&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/examples/validating.cc b/lang/c&lt;/ins&gt;+/examples/validating.cc&lt;br/&gt;
index b44555ecc..fa5d34744 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/examples/validating.cc&lt;br/&gt;
+++ b/lang/c++/examples/validating.cc&lt;br/&gt;
@@ -49,14 +49,14 @@ main()&lt;br/&gt;
     avro::ValidSchema cpxSchema;&lt;br/&gt;
     avro::compileJsonSchema(ifs, cpxSchema);&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::validatingEncoder(cpxSchema,&lt;br/&gt;
         avro::binaryEncoder());&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     std::complex&amp;lt;double&amp;gt; c1(1.0, 2.0);&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    std::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::validatingDecoder(cpxSchema,&lt;br/&gt;
         avro::binaryDecoder());&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/impl/Compiler.cc b/lang/c&lt;/ins&gt;+/impl/Compiler.cc&lt;br/&gt;
index 96708449d..3f05f5c3f 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/impl/Compiler.cc&lt;br/&gt;
+++ b/lang/c++/impl/Compiler.cc&lt;br/&gt;
@@ -481,7 +481,7 @@ AVRO_DECL ValidSchema compileJsonSchemaFromStream(InputStream&amp;amp; is)&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; AVRO_DECL ValidSchema compileJsonSchemaFromFile(const char* filename)&lt;/p&gt;
 {
-    std::auto_ptr&amp;lt;InputStream&amp;gt; s = fileInputStream(filename);
+    std::unique_ptr&amp;lt;InputStream&amp;gt; s = fileInputStream(filename);
     return compileJsonSchemaFromStream(*s);
 }

&lt;p&gt;@@ -504,7 +504,7 @@ AVRO_DECL ValidSchema compileJsonSchemaFromString(const std::string&amp;amp; input)&lt;/p&gt;

&lt;p&gt; static ValidSchema compile(std::istream&amp;amp; is)&lt;/p&gt;
 {
-    std::auto_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(is);
+    std::unique_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(is);
     return compileJsonSchemaFromStream(*in);
 }

&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/impl/DataFile.cc b/lang/c&lt;/ins&gt;+/impl/DataFile.cc&lt;br/&gt;
index 035dd2740..43a76c0b0 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/impl/DataFile.cc&lt;br/&gt;
+++ b/lang/c++/impl/DataFile.cc&lt;br/&gt;
@@ -28,7 +28,7 @@&lt;br/&gt;
 #include &amp;lt;boost/iostreams/filter/zlib.hpp&amp;gt;&lt;/p&gt;

&lt;p&gt; namespace avro {&lt;br/&gt;
-using std::auto_ptr;&lt;br/&gt;
+using std::unique_ptr;&lt;br/&gt;
 using std::ostringstream;&lt;br/&gt;
 using std::istringstream;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
@@ -69,7 +69,7 @@ DataFileWriterBase::DataFileWriterBase(const char* filename,&lt;br/&gt;
     syncInterval_(syncInterval),&lt;br/&gt;
     codec_(codec),&lt;br/&gt;
     stream_(fileOutputStream(filename)),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;buffer_(memoryOutputStream()),&lt;br/&gt;
+    buffer_(std::move(memoryOutputStream())),&lt;br/&gt;
     sync_(makeSync()), objectCount_(0)&lt;br/&gt;
 {&lt;br/&gt;
     if (syncInterval &amp;lt; minSyncInterval || syncInterval &amp;gt; maxSyncInterval) 
{
@@ -115,7 +115,7 @@ void DataFileWriterBase::sync()
         int64_t byteCount = buffer_-&amp;gt;byteCount();
         avro::encode(*encoderPtr_, byteCount);
         encoderPtr_-&amp;gt;flush();
-        std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*buffer_);
+        std::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*buffer_);
         copy(*in, *stream_);
     }
&lt;p&gt; else {&lt;br/&gt;
         std::vector&amp;lt;char&amp;gt; buf;&lt;br/&gt;
@@ -128,12 +128,12 @@ void DataFileWriterBase::sync()&lt;br/&gt;
             const uint8_t* data;&lt;br/&gt;
             size_t len;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; input = memoryInputStream(*buffer_);&lt;br/&gt;
+            std::unique_ptr&amp;lt;InputStream&amp;gt; input = memoryInputStream(*buffer_);&lt;br/&gt;
             while (input-&amp;gt;next(&amp;amp;data, &amp;amp;len)) 
{
                 boost::iostreams::write(os, reinterpret_cast&amp;lt;const char*&amp;gt;(data), len);
             }
&lt;p&gt;         } // make sure all is flushed&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(&lt;br/&gt;
+        std::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(&lt;br/&gt;
            reinterpret_cast&amp;lt;const uint8_t*&amp;gt;(&amp;amp;buf&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;), buf.size());&lt;br/&gt;
         int64_t byteCount = buf.size();&lt;br/&gt;
         avro::encode(*encoderPtr_, byteCount);&lt;br/&gt;
@@ -146,7 +146,7 @@ void DataFileWriterBase::sync()&lt;br/&gt;
     encoderPtr_-&amp;gt;flush();&lt;/li&gt;
&lt;/ul&gt;



&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;buffer_ = memoryOutputStream();&lt;br/&gt;
+    buffer_ = std::move(memoryOutputStream());&lt;br/&gt;
     encoderPtr_-&amp;gt;init(*buffer_);&lt;br/&gt;
     objectCount_ = 0;&lt;br/&gt;
 }&lt;br/&gt;
@@ -296,9 +296,9 @@ class BoundedInputStream : public InputStream {&lt;br/&gt;
         in_(in), limit_(limit) { }&lt;br/&gt;
 };&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-auto_ptr&amp;lt;InputStream&amp;gt; boundedInputStream(InputStream&amp;amp; in, size_t limit)&lt;br/&gt;
+unique_ptr&amp;lt;InputStream&amp;gt; boundedInputStream(InputStream&amp;amp; in, size_t limit)&lt;/p&gt;
 {
-    return auto_ptr&amp;lt;InputStream&amp;gt;(new BoundedInputStream(in, limit));
+    return unique_ptr&amp;lt;InputStream&amp;gt;(new BoundedInputStream(in, limit));
 }

&lt;p&gt; bool DataFileReaderBase::readDataBlock()&lt;br/&gt;
@@ -316,10 +316,10 @@ bool DataFileReaderBase::readDataBlock()&lt;br/&gt;
     avro::decode(*decoder_, byteCount);&lt;br/&gt;
     decoder_-&amp;gt;init(*stream_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; st = boundedInputStream(*stream_, static_cast&amp;lt;size_t&amp;gt;(byteCount));&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; st = boundedInputStream(*stream_, static_cast&amp;lt;size_t&amp;gt;(byteCount));&lt;br/&gt;
     if (codec_ == NULL_CODEC) 
{
         dataDecoder_-&amp;gt;init(*st);
-        dataStream_ = st;
+        dataStream_ = std::move(st);
     }
&lt;p&gt; else &lt;/p&gt;
{
         compressed_.clear();
         const uint8_t* data;
@@ -337,9 +337,9 @@ bool DataFileReaderBase::readDataBlock()
         os_-&amp;gt;push(boost::iostreams::basic_array_source&amp;lt;char&amp;gt;(
             &amp;amp;compressed_[0], compressed_.size()));
 
-        std::auto_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(*os_);
+        std::unique_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(*os_);
         dataDecoder_-&amp;gt;init(*in);
-        dataStream_ = in;
+        dataStream_ = std::move(in);
     }
&lt;p&gt;     return true;&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/impl/FileStream.cc b/lang/c&lt;/ins&gt;+/impl/FileStream.cc&lt;br/&gt;
index 39c5af23c..d6397a2db 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/impl/FileStream.cc&lt;br/&gt;
+++ b/lang/c++/impl/FileStream.cc&lt;br/&gt;
@@ -34,7 +34,7 @@&lt;br/&gt;
 #endif&lt;br/&gt;
 #endif&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using std::unique_ptr;&lt;br/&gt;
 using std::istream;&lt;br/&gt;
 using std::ostream;&lt;/p&gt;

&lt;p&gt;@@ -138,7 +138,7 @@ struct IStreamBufferCopyIn : public BufferCopyIn {&lt;br/&gt;
 class BufferCopyInInputStream : public InputStream {&lt;br/&gt;
     const size_t bufferSize_;&lt;br/&gt;
     uint8_t* const buffer_;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;BufferCopyIn&amp;gt; in_;&lt;br/&gt;
+    unique_ptr&amp;lt;BufferCopyIn&amp;gt; in_;&lt;br/&gt;
     size_t byteCount_;&lt;br/&gt;
     uint8_t* next_;&lt;br/&gt;
     size_t available_;&lt;br/&gt;
@@ -190,10 +190,10 @@ class BufferCopyInInputStream : public InputStream {&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt; public:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferCopyInInputStream(auto_ptr&amp;lt;BufferCopyIn&amp;gt;&amp;amp; in, size_t bufferSize) :&lt;br/&gt;
+    BufferCopyInInputStream(unique_ptr&amp;lt;BufferCopyIn&amp;gt; in, size_t bufferSize) :&lt;br/&gt;
         bufferSize_(bufferSize),&lt;br/&gt;
         buffer_(new uint8_t&lt;span class=&quot;error&quot;&gt;&amp;#91;bufferSize&amp;#93;&lt;/span&gt;),&lt;/li&gt;
	&lt;li&gt;in_(in),&lt;br/&gt;
+        in_(std::move(in)),&lt;br/&gt;
         byteCount_(0),&lt;br/&gt;
         next_(buffer_),&lt;br/&gt;
         available_(0) { }&lt;br/&gt;
@@ -276,7 +276,7 @@ struct OStreamBufferCopyOut : public BufferCopyOut {&lt;br/&gt;
 class BufferCopyOutputStream : public OutputStream {&lt;br/&gt;
     size_t bufferSize_;&lt;br/&gt;
     uint8_t* const buffer_;&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;BufferCopyOut&amp;gt; out_;&lt;br/&gt;
+    unique_ptr&amp;lt;BufferCopyOut&amp;gt; out_;&lt;br/&gt;
     uint8_t* next_;&lt;br/&gt;
     size_t available_;&lt;br/&gt;
     size_t byteCount_;&lt;br/&gt;
@@ -311,10 +311,10 @@ class BufferCopyOutputStream : public OutputStream {&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; public:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferCopyOutputStream(auto_ptr&amp;lt;BufferCopyOut&amp;gt; out, size_t bufferSize) :&lt;br/&gt;
+    BufferCopyOutputStream(unique_ptr&amp;lt;BufferCopyOut&amp;gt; out, size_t bufferSize) :&lt;br/&gt;
         bufferSize_(bufferSize),&lt;br/&gt;
         buffer_(new uint8_t&lt;span class=&quot;error&quot;&gt;&amp;#91;bufferSize&amp;#93;&lt;/span&gt;),&lt;/li&gt;
	&lt;li&gt;out_(out),&lt;br/&gt;
+        out_(std::move(out)),&lt;br/&gt;
         next_(buffer_),&lt;br/&gt;
         available_(bufferSize_), byteCount_(0) { }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -323,32 +323,32 @@ class BufferCopyOutputStream : public OutputStream {&lt;br/&gt;
     }&lt;br/&gt;
 };&lt;/p&gt;

&lt;p&gt;-auto_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;br/&gt;
+unique_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;br/&gt;
     size_t bufferSize)&lt;/p&gt;
 {
-    auto_ptr&amp;lt;BufferCopyIn&amp;gt; in(new FileBufferCopyIn(filename));
-    return auto_ptr&amp;lt;InputStream&amp;gt;( new BufferCopyInInputStream(in, bufferSize));
+    unique_ptr&amp;lt;BufferCopyIn&amp;gt; in(new FileBufferCopyIn(filename));
+    return unique_ptr&amp;lt;InputStream&amp;gt;( new BufferCopyInInputStream(std::move(in), bufferSize));
 }

&lt;p&gt;-auto_ptr&amp;lt;InputStream&amp;gt; istreamInputStream(istream&amp;amp; is,&lt;br/&gt;
+unique_ptr&amp;lt;InputStream&amp;gt; istreamInputStream(istream&amp;amp; is,&lt;br/&gt;
     size_t bufferSize)&lt;/p&gt;
 {
-    auto_ptr&amp;lt;BufferCopyIn&amp;gt; in(new IStreamBufferCopyIn(is));
-    return auto_ptr&amp;lt;InputStream&amp;gt;( new BufferCopyInInputStream(in, bufferSize));
+    unique_ptr&amp;lt;BufferCopyIn&amp;gt; in(new IStreamBufferCopyIn(is));
+    return unique_ptr&amp;lt;InputStream&amp;gt;( new BufferCopyInInputStream(std::move(in), bufferSize));
 }

&lt;p&gt;-auto_ptr&amp;lt;OutputStream&amp;gt; fileOutputStream(const char* filename,&lt;br/&gt;
+unique_ptr&amp;lt;OutputStream&amp;gt; fileOutputStream(const char* filename,&lt;br/&gt;
     size_t bufferSize)&lt;/p&gt;
 {
-    auto_ptr&amp;lt;BufferCopyOut&amp;gt; out(new FileBufferCopyOut(filename));
-    return auto_ptr&amp;lt;OutputStream&amp;gt;(new BufferCopyOutputStream(out, bufferSize));
+    unique_ptr&amp;lt;BufferCopyOut&amp;gt; out(new FileBufferCopyOut(filename));
+    return unique_ptr&amp;lt;OutputStream&amp;gt;(new BufferCopyOutputStream(std::move(out), bufferSize));
 }

&lt;p&gt;-auto_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(ostream&amp;amp; os,&lt;br/&gt;
+unique_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(ostream&amp;amp; os,&lt;br/&gt;
     size_t bufferSize)&lt;/p&gt;
 {
-    auto_ptr&amp;lt;BufferCopyOut&amp;gt; out(new OStreamBufferCopyOut(os));
-    return auto_ptr&amp;lt;OutputStream&amp;gt;(new BufferCopyOutputStream(out, bufferSize));
+    unique_ptr&amp;lt;BufferCopyOut&amp;gt; out(new OStreamBufferCopyOut(os));
+    return unique_ptr&amp;lt;OutputStream&amp;gt;(new BufferCopyOutputStream(std::move(out), bufferSize));
 }


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/impl/Stream.cc b/lang/c&lt;/ins&gt;+/impl/Stream.cc&lt;br/&gt;
index 5da5edbcc..da1212fa7 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/impl/Stream.cc&lt;br/&gt;
+++ b/lang/c++/impl/Stream.cc&lt;br/&gt;
@@ -157,23 +157,23 @@ class MemoryOutputStream : public OutputStream {&lt;br/&gt;
     void flush() { }&lt;br/&gt;
 };&lt;/p&gt;

&lt;p&gt;-std::auto_ptr&amp;lt;OutputStream&amp;gt; memoryOutputStream(size_t chunkSize)&lt;br/&gt;
+std::unique_ptr&amp;lt;OutputStream&amp;gt; memoryOutputStream(size_t chunkSize)&lt;/p&gt;
 {
-    return std::auto_ptr&amp;lt;OutputStream&amp;gt;(new MemoryOutputStream(chunkSize));
+    return std::unique_ptr&amp;lt;OutputStream&amp;gt;(new MemoryOutputStream(chunkSize));
 }

&lt;p&gt;-std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size_t len)&lt;br/&gt;
+std::unique_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size_t len)&lt;/p&gt;
 {
-    return std::auto_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream2(data, len));
+    return std::unique_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream2(data, len));
 }

&lt;p&gt;-std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const OutputStream&amp;amp; source)&lt;br/&gt;
+std::unique_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const OutputStream&amp;amp; source)&lt;/p&gt;
 {
     const MemoryOutputStream&amp;amp; mos =
         dynamic_cast&amp;lt;const MemoryOutputStream&amp;amp;&amp;gt;(source);
     return (mos.data_.empty()) ?
-        std::auto_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream2(0, 0)) :
-        std::auto_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream(mos.data_,
+        std::unique_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream2(0, 0)) :
+        std::unique_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream(mos.data_,
             mos.chunkSize_,
             (mos.chunkSize_ - mos.available_)));
 }
&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/impl/json/JsonDom.cc b/lang/c&lt;/ins&gt;+/impl/json/JsonDom.cc&lt;br/&gt;
index 3f52f363b..3c2080482 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/impl/json/JsonDom.cc&lt;br/&gt;
+++ b/lang/c++/impl/json/JsonDom.cc&lt;br/&gt;
@@ -106,7 +106,7 @@ Entity loadEntity(InputStream&amp;amp; in)&lt;/p&gt;

&lt;p&gt; Entity loadEntity(const uint8_t* text, size_t len)&lt;/p&gt;
 {
-    std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(text, len);
+    std::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(text, len);
     return loadEntity(*in);
 }

&lt;p&gt;@@ -165,12 +165,12 @@ void Entity::ensureType(EntityType type) const&lt;/p&gt;

&lt;p&gt; std::string Entity::toString() const&lt;br/&gt;
 {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; out = memoryOutputStream();&lt;br/&gt;
+    std::unique_ptr&amp;lt;OutputStream&amp;gt; out = memoryOutputStream();&lt;br/&gt;
     JsonGenerator&amp;lt;JsonNullFormatter&amp;gt; g;&lt;br/&gt;
     g.init(*out);&lt;br/&gt;
     writeEntity(g, *this);&lt;br/&gt;
     g.flush();&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*out);&lt;br/&gt;
+    std::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*out);&lt;br/&gt;
     const uint8_t *p = 0;&lt;br/&gt;
     size_t n = 0;&lt;br/&gt;
     size_t c = 0;&lt;br/&gt;
@@ -180,7 +180,7 @@ std::string Entity::toString() const&lt;br/&gt;
     std::string result;&lt;br/&gt;
     result.resize(c);&lt;br/&gt;
     c = 0;&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*out);&lt;br/&gt;
+    std::unique_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*out);&lt;br/&gt;
     while (in2-&amp;gt;next(&amp;amp;p, &amp;amp;n)) {&lt;br/&gt;
         ::memcpy(&amp;amp;result&lt;span class=&quot;error&quot;&gt;&amp;#91;c&amp;#93;&lt;/span&gt;, p, n);&lt;br/&gt;
         c += n;&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/impl/parsing/ResolvingDecoder.cc b/lang/c&lt;/ins&gt;+/impl/parsing/ResolvingDecoder.cc&lt;br/&gt;
index e0d25edfd..d37cc7399 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/impl/parsing/ResolvingDecoder.cc&lt;br/&gt;
+++ b/lang/c++/impl/parsing/ResolvingDecoder.cc&lt;br/&gt;
@@ -49,7 +49,7 @@ using boost::shared_ptr;&lt;br/&gt;
 using boost::static_pointer_cast;&lt;br/&gt;
 using boost::make_shared;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using std::unique_ptr;&lt;br/&gt;
 using std::map;&lt;br/&gt;
 using std::pair;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
@@ -156,7 +156,7 @@ static shared_ptr&amp;lt;vector&amp;lt;uint8_t&amp;gt; &amp;gt; getAvroBinary(&lt;br/&gt;
     const GenericDatum&amp;amp; defaultValue)&lt;br/&gt;
 {&lt;br/&gt;
     EncoderPtr e = binaryEncoder();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
     e-&amp;gt;init(*os);&lt;br/&gt;
     GenericWriter::write(*e, defaultValue);&lt;br/&gt;
     e-&amp;gt;flush();&lt;br/&gt;
@@ -447,7 +447,7 @@ ProductionPtr ResolvingGrammarGenerator::doGenerate2(&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; class ResolvingDecoderHandler {&lt;br/&gt;
     shared_ptr&amp;lt;vector&amp;lt;uint8_t&amp;gt; &amp;gt; defaultData_;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; inp_;&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; inp_;&lt;br/&gt;
     DecoderPtr backup_;&lt;br/&gt;
     DecoderPtr&amp;amp; base_;&lt;br/&gt;
     const DecoderPtr binDecoder;&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/test/AvrogencppTests.cc b/lang/c&lt;/ins&gt;+/test/AvrogencppTests.cc&lt;br/&gt;
index 26d015599..26c460763 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/test/AvrogencppTests.cc&lt;br/&gt;
+++ b/lang/c++/test/AvrogencppTests.cc&lt;br/&gt;
@@ -41,7 +41,7 @@&lt;br/&gt;
 #endif&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using std::unique_ptr;&lt;br/&gt;
 using std::map;&lt;br/&gt;
 using std::string;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
@@ -143,7 +143,7 @@ void testEncoding()&lt;br/&gt;
     ValidSchema s;&lt;br/&gt;
     ifstream ifs(&quot;jsonschemas/bigrecord&quot;);&lt;br/&gt;
     compileJsonSchema(ifs, s);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
     EncoderPtr e = validatingEncoder(s, binaryEncoder());&lt;br/&gt;
     e-&amp;gt;init(*os);&lt;br/&gt;
     testgen::RootRecord t1;&lt;br/&gt;
@@ -152,7 +152,7 @@ void testEncoding()&lt;br/&gt;
     e-&amp;gt;flush();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     DecoderPtr d = validatingDecoder(s, binaryDecoder());&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
     d-&amp;gt;init(*is);&lt;br/&gt;
     testgen::RootRecord t2;&lt;br/&gt;
     avro::decode(*d, t2);&lt;br/&gt;
@@ -165,7 +165,7 @@ void testResolution()&lt;br/&gt;
     ValidSchema s_w;&lt;br/&gt;
     ifstream ifs_w(&quot;jsonschemas/bigrecord&quot;);&lt;br/&gt;
     compileJsonSchema(ifs_w, s_w);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
     EncoderPtr e = validatingEncoder(s_w, binaryEncoder());&lt;br/&gt;
     e-&amp;gt;init(*os);&lt;br/&gt;
     testgen::RootRecord t1;&lt;br/&gt;
@@ -177,7 +177,7 @@ void testResolution()&lt;br/&gt;
     ifstream ifs_r(&quot;jsonschemas/bigrecord_r&quot;);&lt;br/&gt;
     compileJsonSchema(ifs_r, s_r);&lt;br/&gt;
     DecoderPtr dd = binaryDecoder();&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
     dd-&amp;gt;init(*is);&lt;br/&gt;
     DecoderPtr rd = resolvingDecoder(s_w, s_r, dd);&lt;br/&gt;
     testgen_r::RootRecord t2;&lt;br/&gt;
@@ -187,7 +187,7 @@ void testResolution()&lt;br/&gt;
     checkDefaultValues(t2);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     //Re-use the resolving decoder to decode again.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; is1 = memoryInputStream(*os);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; is1 = memoryInputStream(*os);&lt;br/&gt;
     rd-&amp;gt;init(*is1);&lt;br/&gt;
     testgen_r::RootRecord t3;&lt;br/&gt;
     avro::decode(*rd, t3);&lt;br/&gt;
@@ -246,7 +246,7 @@ void testEncoding2()&lt;br/&gt;
     ifstream ifs(schemaFilename&amp;lt;T&amp;gt;::value);&lt;br/&gt;
     compileJsonSchema(ifs, s);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
     EncoderPtr e = validatingEncoder(s, binaryEncoder());&lt;br/&gt;
     e-&amp;gt;init(*os);&lt;br/&gt;
     T t1;&lt;br/&gt;
@@ -255,7 +255,7 @@ void testEncoding2()&lt;br/&gt;
     e-&amp;gt;flush();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     DecoderPtr d = validatingDecoder(s, binaryDecoder());&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
     d-&amp;gt;init(*is);&lt;br/&gt;
     T t2;&lt;br/&gt;
     avro::decode(*d, t2);&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/test/CodecTests.cc b/lang/c&lt;/ins&gt;+/test/CodecTests.cc&lt;br/&gt;
index c0ca1e05b..32f4c42f0 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/test/CodecTests.cc&lt;br/&gt;
+++ b/lang/c++/test/CodecTests.cc&lt;br/&gt;
@@ -43,7 +43,7 @@ namespace avro {&lt;br/&gt;
 /*&lt;br/&gt;
 void dump(const OutputStream&amp;amp; os)
 {
-    std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(os);
+    std::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(os);
     const char *b;
     size_t n;
     std::cout &amp;lt;&amp;lt; os.byteCount() &amp;lt;&amp;lt; std::endl;
@@ -91,7 +91,7 @@ using std::istringstream;
 using std::ostringstream;
 using std::back_inserter;
 using std::copy;
-using std::auto_ptr;
+using std::unique_ptr;
 
 template &amp;lt;typename T&amp;gt;
 T from_string(const std::string&amp;amp; s)
@@ -230,12 +230,12 @@ static vector&amp;lt;string&amp;gt; randomValues(const char* calls)
     return result;
 }&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-static auto_ptr&amp;lt;OutputStream&amp;gt; generate(Encoder&amp;amp; e, const char* calls,&lt;br/&gt;
+static unique_ptr&amp;lt;OutputStream&amp;gt; generate(Encoder&amp;amp; e, const char* calls,&lt;br/&gt;
     const vector&amp;lt;string&amp;gt;&amp;amp; values)&lt;br/&gt;
 {&lt;br/&gt;
     Scanner sc(calls);&lt;br/&gt;
     vector&amp;lt;string&amp;gt;::const_iterator it = values.begin();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
     e.init(*ob);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     while (! sc.isDone()) &lt;/p&gt;
{
@@ -537,7 +537,7 @@ ValidSchema makeValidSchema(const char* schema)
 }

&lt;p&gt; void testEncoder(const EncoderPtr&amp;amp; e, const char* writerCalls,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;vector&amp;lt;string&amp;gt;&amp;amp; v, auto_ptr&amp;lt;OutputStream&amp;gt;&amp;amp; p)&lt;br/&gt;
+    vector&amp;lt;string&amp;gt;&amp;amp; v, unique_ptr&amp;lt;OutputStream&amp;gt;&amp;amp; p)&lt;br/&gt;
 {&lt;br/&gt;
     v = randomValues(writerCalls);&lt;br/&gt;
     p = generate(*e, writerCalls, v);&lt;br/&gt;
@@ -615,7 +615,7 @@ void testCodec(const TestData&amp;amp; td) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     for (unsigned int i = 0; i &amp;lt; count; ++i) {&lt;br/&gt;
         vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
         testEncoder(CodecFactory::newEncoder(vs), td.calls, v, p);&lt;br/&gt;
         // dump(*p);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -631,7 +631,7 @@ void testCodec(const TestData&amp;amp; td) &lt;/p&gt;
{
                 &amp;lt;&amp;lt; &quot; schema: &quot; &amp;lt;&amp;lt; td.schema
                 &amp;lt;&amp;lt; &quot; calls: &quot; &amp;lt;&amp;lt; td.calls
                 &amp;lt;&amp;lt; &quot; skip-level: &quot; &amp;lt;&amp;lt; skipLevel);
-            auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
+            unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
             testDecoder(CodecFactory::newDecoder(vs), v, *in,
                 td.calls, skipLevel);
         }
&lt;p&gt;@@ -653,7 +653,7 @@ void testCodecResolving(const TestData3&amp;amp; td) {&lt;/p&gt;

&lt;p&gt;     for (unsigned int i = 0; i &amp;lt; count; ++i) {&lt;br/&gt;
         vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
         testEncoder(CodecFactory::newEncoder(vs), td.writerCalls, v, p);&lt;br/&gt;
         // dump(*p);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -666,7 +666,7 @@ void testCodecResolving(const TestData3&amp;amp; td) &lt;/p&gt;
{
                 &amp;lt;&amp;lt; &quot; reader schema: &quot; &amp;lt;&amp;lt; td.readerSchema
                 &amp;lt;&amp;lt; &quot; reader calls: &quot; &amp;lt;&amp;lt; td.readerCalls
                 &amp;lt;&amp;lt; &quot; skip-level: &quot; &amp;lt;&amp;lt; skipLevel);
-            auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
+            unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
             testDecoder(CodecFactory::newDecoder(vs, rvs), v, *in,
                 td.readerCalls, skipLevel);
         }
&lt;p&gt;@@ -696,7 +696,7 @@ void testCodecResolving2(const TestData4&amp;amp; td) {&lt;br/&gt;
     ValidSchema vs = makeValidSchema(td.writerSchema);&lt;/p&gt;

&lt;p&gt;     vector&amp;lt;string&amp;gt; wd = mkValues(td.writerValues);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p =&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; p =&lt;br/&gt;
         generate(*CodecFactory::newEncoder(vs), td.writerCalls, wd);&lt;br/&gt;
     // dump(*p);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -710,7 +710,7 @@ void testCodecResolving2(const TestData4&amp;amp; td) &lt;/p&gt;
{
             &amp;lt;&amp;lt; &quot; reader schema: &quot; &amp;lt;&amp;lt; td.readerSchema
             &amp;lt;&amp;lt; &quot; reader calls: &quot; &amp;lt;&amp;lt; td.readerCalls
             &amp;lt;&amp;lt; &quot; skip-level: &quot; &amp;lt;&amp;lt; skipLevel);
-        auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
+        unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
         testDecoder(CodecFactory::newDecoder(vs, rvs), rd, *in,
             td.readerCalls, skipLevel);
     }
&lt;p&gt;@@ -728,9 +728,9 @@ void testReaderFail(const TestData2&amp;amp; td) {&lt;br/&gt;
     ValidSchema vs = makeValidSchema(td.schema);&lt;/p&gt;

&lt;p&gt;     vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
     testEncoder(CodecFactory::newEncoder(vs), td.correctCalls, v, p);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);&lt;br/&gt;
     BOOST_CHECK_THROW(&lt;br/&gt;
         testDecoder(CodecFactory::newDecoder(vs), v, *in,&lt;br/&gt;
             td.incorrectCalls, td.depth), Exception);&lt;br/&gt;
@@ -746,7 +746,7 @@ void testWriterFail(const TestData2&amp;amp; td) 
{
     ValidSchema vs = makeValidSchema(td.schema);
 
     vector&amp;lt;string&amp;gt; v;
-    auto_ptr&amp;lt;OutputStream&amp;gt; p;
+    unique_ptr&amp;lt;OutputStream&amp;gt; p;
     BOOST_CHECK_THROW(testEncoder(CodecFactory::newEncoder(vs),
         td.incorrectCalls, v, p), Exception);
 }
&lt;p&gt;@@ -763,17 +763,17 @@ void testGeneric(const TestData&amp;amp; td) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     for (unsigned int i = 0; i &amp;lt; count; ++i) {&lt;br/&gt;
         vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
         testEncoder(CodecFactory::newEncoder(vs), td.calls, v, p);&lt;br/&gt;
         // dump(*p);&lt;br/&gt;
         DecoderPtr d1 = CodecFactory::newDecoder(vs);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
+        unique_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
         d1-&amp;gt;init(*in1);&lt;br/&gt;
         GenericDatum datum(vs);&lt;br/&gt;
         avro::decode(*d1, datum);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         EncoderPtr e2 = CodecFactory::newEncoder(vs);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
         e2-&amp;gt;init(*ob);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         avro::encode(*e2, datum);&lt;br/&gt;
@@ -782,7 +782,7 @@ void testGeneric(const TestData&amp;amp; td) &lt;/p&gt;
{
         BOOST_TEST_CHECKPOINT(&quot;Test: &quot; &amp;lt;&amp;lt; testNo &amp;lt;&amp;lt; &apos; &apos;
             &amp;lt;&amp;lt; &quot; schema: &quot; &amp;lt;&amp;lt; td.schema
             &amp;lt;&amp;lt; &quot; calls: &quot; &amp;lt;&amp;lt; td.calls);
-        auto_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*ob);
+        unique_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*ob);
         testDecoder(CodecFactory::newDecoder(vs), v, *in2,
             td.calls, td.depth);
     }
&lt;p&gt;@@ -804,11 +804,11 @@ void testGenericResolving(const TestData3&amp;amp; td) {&lt;/p&gt;

&lt;p&gt;     for (unsigned int i = 0; i &amp;lt; count; ++i) {&lt;br/&gt;
         vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
         testEncoder(CodecFactory::newEncoder(wvs), td.writerCalls, v, p);&lt;br/&gt;
         // dump(*p);&lt;br/&gt;
         DecoderPtr d1 = CodecFactory::newDecoder(wvs);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
+        unique_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
         d1-&amp;gt;init(*in1);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         GenericReader gr(wvs, rvs, d1);&lt;br/&gt;
@@ -816,7 +816,7 @@ void testGenericResolving(const TestData3&amp;amp; td) {&lt;br/&gt;
         gr.read(datum);&lt;/p&gt;

&lt;p&gt;         EncoderPtr e2 = CodecFactory::newEncoder(rvs);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
         e2-&amp;gt;init(*ob);&lt;br/&gt;
         avro::encode(*e2, datum);&lt;br/&gt;
         e2-&amp;gt;flush();&lt;br/&gt;
@@ -826,7 +826,7 @@ void testGenericResolving(const TestData3&amp;amp; td) 
{
             &amp;lt;&amp;lt; &quot; writer-calls: &quot; &amp;lt;&amp;lt; td.writerCalls 
             &amp;lt;&amp;lt; &quot; reader-schema: &quot; &amp;lt;&amp;lt; td.readerSchema
             &amp;lt;&amp;lt; &quot; calls: &quot; &amp;lt;&amp;lt; td.readerCalls);
-        auto_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*ob);
+        unique_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*ob);
         testDecoder(CodecFactory::newDecoder(rvs), v, *in2,
             td.readerCalls, td.depth);
     }
&lt;p&gt;@@ -848,11 +848,11 @@ void testGenericResolving2(const TestData4&amp;amp; td) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     const vector&amp;lt;string&amp;gt; wd = mkValues(td.writerValues);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p = generate(*CodecFactory::newEncoder(wvs),&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; p = generate(*CodecFactory::newEncoder(wvs),&lt;br/&gt;
         td.writerCalls, wd);&lt;br/&gt;
     // dump(*p);&lt;br/&gt;
     DecoderPtr d1 = CodecFactory::newDecoder(wvs);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
     d1-&amp;gt;init(*in1);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     GenericReader gr(wvs, rvs, d1);&lt;br/&gt;
@@ -860,7 +860,7 @@ void testGenericResolving2(const TestData4&amp;amp; td) {&lt;br/&gt;
     gr.read(datum);&lt;/p&gt;

&lt;p&gt;     EncoderPtr e2 = CodecFactory::newEncoder(rvs);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
     e2-&amp;gt;init(*ob);&lt;br/&gt;
     avro::encode(*e2, datum);&lt;br/&gt;
     e2-&amp;gt;flush();&lt;br/&gt;
@@ -1446,7 +1446,7 @@ static void testStreamLifetimes()&lt;br/&gt;
 {&lt;br/&gt;
     EncoderPtr e = binaryEncoder();
     {
-        std::auto_ptr&amp;lt;OutputStream&amp;gt; s1 = memoryOutputStream();
+        std::unique_ptr&amp;lt;OutputStream&amp;gt; s1 = memoryOutputStream();
         e-&amp;gt;init(*s1);
         e-&amp;gt;encodeInt(100);
         e-&amp;gt;encodeDouble(4.73);
@@ -1454,7 +1454,7 @@ static void testStreamLifetimes()
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; s2 = memoryOutputStream();&lt;br/&gt;
+        std::unique_ptr&amp;lt;OutputStream&amp;gt; s2 = memoryOutputStream();&lt;br/&gt;
         e-&amp;gt;init(*s2);&lt;br/&gt;
         e-&amp;gt;encodeDouble(3.14);&lt;br/&gt;
         e-&amp;gt;flush();&lt;br/&gt;
@@ -1464,7 +1464,7 @@ static void testStreamLifetimes()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; static void testLimits(const EncoderPtr&amp;amp; e, const DecoderPtr&amp;amp; d)&lt;br/&gt;
 {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; s1 = memoryOutputStream();&lt;br/&gt;
+    std::unique_ptr&amp;lt;OutputStream&amp;gt; s1 = memoryOutputStream();
     {
         e-&amp;gt;init(*s1);
         e-&amp;gt;encodeDouble(std::numeric_limits&amp;lt;double&amp;gt;::infinity());
@@ -1477,7 +1477,7 @@ static void testLimits(const EncoderPtr&amp;amp; e, const DecoderPtr&amp;amp; d)
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; s2 = memoryInputStream(*s1);&lt;br/&gt;
+        std::unique_ptr&amp;lt;InputStream&amp;gt; s2 = memoryInputStream(*s1);&lt;br/&gt;
         d-&amp;gt;init(*s2);&lt;br/&gt;
         BOOST_CHECK_EQUAL(d-&amp;gt;decodeDouble(),&lt;br/&gt;
             std::numeric_limits&amp;lt;double&amp;gt;::infinity());&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/test/DataFileTests.cc b/lang/c&lt;/ins&gt;+/test/DataFileTests.cc&lt;br/&gt;
index 95e80b1bc..1382b7296 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/test/DataFileTests.cc&lt;br/&gt;
+++ b/lang/c++/test/DataFileTests.cc&lt;br/&gt;
@@ -27,7 +27,7 @@&lt;br/&gt;
 #include &quot;Stream.hh&quot;&lt;br/&gt;
 #include &quot;Compiler.hh&quot;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using std::unique_ptr;&lt;br/&gt;
 using std::string;&lt;br/&gt;
 using std::pair;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
@@ -360,9 +360,9 @@ class DataFileTest {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs the DataFileReader in two steps.&lt;br/&gt;
      */&lt;br/&gt;
     void testReadDoubleTwoStep() {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;avro::DataFileReaderBase&amp;gt;&lt;br/&gt;
+        unique_ptr&amp;lt;avro::DataFileReaderBase&amp;gt;&lt;br/&gt;
             base(new avro::DataFileReaderBase(filename));&lt;/li&gt;
	&lt;li&gt;avro::DataFileReader&amp;lt;ComplexDouble&amp;gt; df(base);&lt;br/&gt;
+        avro::DataFileReader&amp;lt;ComplexDouble&amp;gt; df(std::move(base));&lt;br/&gt;
         BOOST_CHECK_EQUAL(toString(writerSchema), toString(df.readerSchema()));&lt;br/&gt;
         BOOST_CHECK_EQUAL(toString(writerSchema), toString(df.dataSchema()));&lt;br/&gt;
         int i = 0;&lt;br/&gt;
@@ -384,9 +384,9 @@ class DataFileTest {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;reader schema.&lt;br/&gt;
      */&lt;br/&gt;
     void testReadDoubleTwoStepProject() {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;avro::DataFileReaderBase&amp;gt;&lt;br/&gt;
+        unique_ptr&amp;lt;avro::DataFileReaderBase&amp;gt;&lt;br/&gt;
             base(new avro::DataFileReaderBase(filename));&lt;/li&gt;
	&lt;li&gt;avro::DataFileReader&amp;lt;Double&amp;gt; df(base, readerSchema);&lt;br/&gt;
+        avro::DataFileReader&amp;lt;Double&amp;gt; df(std::move(base), readerSchema);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         BOOST_CHECK_EQUAL(toString(readerSchema), toString(df.readerSchema()));&lt;br/&gt;
         BOOST_CHECK_EQUAL(toString(writerSchema), toString(df.dataSchema()));&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/test/SpecificTests.cc b/lang/c&lt;/ins&gt;+/test/SpecificTests.cc&lt;br/&gt;
index aec338ca0..98a003128 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/test/SpecificTests.cc&lt;br/&gt;
+++ b/lang/c++/test/SpecificTests.cc&lt;br/&gt;
@@ -22,7 +22,7 @@&lt;br/&gt;
 #include &quot;Specific.hh&quot;&lt;br/&gt;
 #include &quot;Stream.hh&quot;&lt;/p&gt;

&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using std::unique_ptr;&lt;br/&gt;
 using std::string;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
 using std::map;&lt;br/&gt;
@@ -61,7 +61,7 @@ template &amp;lt;&amp;gt; struct codec_traits&amp;lt;C&amp;gt; {&lt;br/&gt;
 namespace specific {&lt;/p&gt;

&lt;p&gt; class Test {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os;&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os;&lt;br/&gt;
     EncoderPtr e;&lt;br/&gt;
     DecoderPtr d;&lt;br/&gt;
 public:&lt;br/&gt;
@@ -75,7 +75,7 @@ class Test {&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     template &amp;lt;typename T&amp;gt; void decode(T&amp;amp; t) &lt;/p&gt;
{
-        auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
+        unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
         d-&amp;gt;init(*is);
         avro::decode(*d, t);
     }
&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/test/StreamTests.cc b/lang/c&lt;/ins&gt;+/test/StreamTests.cc&lt;br/&gt;
index 2504207eb..1ff6ef954 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/test/StreamTests.cc&lt;br/&gt;
+++ b/lang/c++/test/StreamTests.cc&lt;br/&gt;
@@ -105,18 +105,18 @@ struct Verify2 {&lt;/p&gt;

&lt;p&gt; template &amp;lt;typename V&amp;gt;&lt;br/&gt;
 void testEmpty_memoryStream() &lt;/p&gt;
{
-    std::auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();
-    std::auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
+    std::unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();
+    std::unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
     V()(*is);
 }

&lt;p&gt; template &amp;lt;typename F, typename V&amp;gt;&lt;br/&gt;
 void testNonEmpty_memoryStream(const TestData&amp;amp; td)&lt;/p&gt;
 {
-    std::auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream(td.chunkSize);
+    std::unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream(td.chunkSize);
     F()(*os, td.dataSize);
 
-    std::auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
+    std::unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
     V()(*is, td.dataSize);
 }

&lt;p&gt;@@ -127,7 +127,7 @@ void testNonEmpty2(const TestData&amp;amp; td) {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     uint8_t v2 = 0;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(v.empty() ? &amp;amp;v2 : &amp;amp;v&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, v.size());&lt;br/&gt;
+    std::unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(v.empty() ? &amp;amp;v2 : &amp;amp;v&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, v.size());&lt;br/&gt;
     Verify1()(*is, td.dataSize);&lt;br/&gt;
 }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -143,9 +143,9 @@ template &amp;lt;typename V&amp;gt;&lt;br/&gt;
 void testEmpty_fileStream() {&lt;br/&gt;
     FileRemover fr(filename);&lt;/p&gt;
     {
-        std::auto_ptr&amp;lt;OutputStream&amp;gt; os = fileOutputStream(filename);
+        std::unique_ptr&amp;lt;OutputStream&amp;gt; os = fileOutputStream(filename);
     }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; is = fileInputStream(filename);&lt;br/&gt;
+    std::unique_ptr&amp;lt;InputStream&amp;gt; is = fileInputStream(filename);&lt;br/&gt;
     V()(*is);&lt;br/&gt;
 }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -154,12 +154,12 @@ void testNonEmpty_fileStream(const TestData&amp;amp; td)&lt;br/&gt;
 {&lt;br/&gt;
     FileRemover fr(filename);&lt;/p&gt;
     {
-        std::auto_ptr&amp;lt;OutputStream&amp;gt; os = fileOutputStream(filename,
+        std::unique_ptr&amp;lt;OutputStream&amp;gt; os = fileOutputStream(filename,
             td.chunkSize);
         F()(*os, td.dataSize);
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; is = fileInputStream(filename, td.chunkSize);&lt;br/&gt;
+    std::unique_ptr&amp;lt;InputStream&amp;gt; is = fileInputStream(filename, td.chunkSize);&lt;br/&gt;
     V()(*is, td.dataSize);&lt;br/&gt;
 }&lt;/li&gt;
&lt;/ul&gt;






&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16708990" author="githubbot" created="Tue, 4 Dec 2018 17:01:03 +0000"  >&lt;p&gt;dkulp commented on issue #203: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/203#issuecomment-444175491&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203#issuecomment-444175491&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Avro has decided to require c++ 11 for 1.9. Thus, I&apos;ve merge #157 (with updates) that use the std::unique_ptr.   This will require migration for users.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16708991" author="githubbot" created="Tue, 4 Dec 2018 17:01:04 +0000"  >&lt;p&gt;dkulp closed pull request #203: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1542&quot; title=&quot;std::auto_ptr&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1542&quot;&gt;&lt;del&gt;AVRO-1542&lt;/del&gt;&lt;/a&gt;: Replace deprecated std::auto_ptr&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/203&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/203&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/api/DataFile.hh b/lang/c&lt;/ins&gt;+/api/DataFile.hh&lt;br/&gt;
index bff309770..e3b602583 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/api/DataFile.hh&lt;br/&gt;
+++ b/lang/c++/api/DataFile.hh&lt;br/&gt;
@@ -65,8 +65,8 @@ class AVRO_DECL DataFileWriterBase : boost::noncopyable {&lt;br/&gt;
     const size_t syncInterval_;&lt;br/&gt;
     Codec codec_;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; stream_;&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; buffer_;&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; stream_;&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; buffer_;&lt;br/&gt;
     const DataFileSync sync_;&lt;br/&gt;
     int64_t objectCount_;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -74,7 +74,7 @@ class AVRO_DECL DataFileWriterBase : boost::noncopyable {&lt;/p&gt;

&lt;p&gt;     Metadata metadata_;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;static std::auto_ptr&amp;lt;OutputStream&amp;gt; makeStream(const char* filename);&lt;br/&gt;
+    static boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; makeStream(const char* filename);&lt;br/&gt;
     static DataFileSync makeSync();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     void writeHeader();&lt;br/&gt;
@@ -132,7 +132,7 @@ public:&lt;br/&gt;
  */&lt;br/&gt;
 template &amp;lt;typename T&amp;gt;&lt;br/&gt;
 class DataFileWriter : boost::noncopyable {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;DataFileWriterBase&amp;gt; base_;&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;DataFileWriterBase&amp;gt; base_;&lt;br/&gt;
 public:&lt;br/&gt;
     /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs a new data file.&lt;br/&gt;
@@ -172,7 +172,7 @@ public:&lt;br/&gt;
  */&lt;br/&gt;
 class AVRO_DECL DataFileReaderBase : boost::noncopyable {&lt;br/&gt;
     const std::string filename_;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;const std::auto_ptr&amp;lt;InputStream&amp;gt; stream_;&lt;br/&gt;
+    const boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; stream_;&lt;br/&gt;
     const DecoderPtr decoder_;&lt;br/&gt;
     int64_t objectCount_;&lt;br/&gt;
     bool eof_;&lt;br/&gt;
@@ -181,7 +181,7 @@ class AVRO_DECL DataFileReaderBase : boost::noncopyable {&lt;br/&gt;
     ValidSchema readerSchema_;&lt;br/&gt;
     ValidSchema dataSchema_;&lt;br/&gt;
     DecoderPtr dataDecoder_;&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; dataStream_;&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; dataStream_;&lt;br/&gt;
     typedef std::map&amp;lt;std::string, std::vector&amp;lt;uint8_t&amp;gt; &amp;gt; Metadata;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     Metadata metadata_;&lt;br/&gt;
@@ -254,7 +254,7 @@ public:&lt;br/&gt;
  */&lt;br/&gt;
 template &amp;lt;typename T&amp;gt;&lt;br/&gt;
 class DataFileReader : boost::noncopyable {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;DataFileReaderBase&amp;gt; base_;&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;DataFileReaderBase&amp;gt; base_;&lt;br/&gt;
 public:&lt;br/&gt;
     /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs the reader for the given file and the reader is&lt;br/&gt;
@@ -284,7 +284,8 @@ public:&lt;/li&gt;
	&lt;li&gt;The schema present in the data file will be used for reading&lt;/li&gt;
	&lt;li&gt;from this reader.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DataFileReader(std::auto_ptr&amp;lt;DataFileReaderBase&amp;gt; base) : base_(base) {&lt;br/&gt;
+    DataFileReader(boost::movelib::unique_ptr&amp;lt;DataFileReaderBase&amp;gt; base) :&lt;br/&gt;
+        base_(boost::move(base)) 
{
         base_-&amp;gt;init();
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -297,8 +298,8 @@ public:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The argument readerSchema will be used for reading&lt;/li&gt;
	&lt;li&gt;from this reader.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DataFileReader(std::auto_ptr&amp;lt;DataFileReaderBase&amp;gt; base,&lt;/li&gt;
	&lt;li&gt;const ValidSchema&amp;amp; readerSchema) : base_(base) {&lt;br/&gt;
+    DataFileReader(boost::movelib::unique_ptr&amp;lt;DataFileReaderBase&amp;gt; base,&lt;br/&gt;
+        const ValidSchema&amp;amp; readerSchema) : base_(boost::move(base)) 
{
         base_-&amp;gt;init(readerSchema);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/api/Stream.hh b/lang/c&lt;/ins&gt;+/api/Stream.hh&lt;br/&gt;
index 92b2334d2..e2f14c741 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/api/Stream.hh&lt;br/&gt;
+++ b/lang/c++/api/Stream.hh&lt;br/&gt;
@@ -19,10 +19,10 @@&lt;br/&gt;
 #ifndef avro_Stream_hh__&lt;br/&gt;
 #define avro_Stream_hh__&lt;/p&gt;

&lt;p&gt;-#include &amp;lt;memory&amp;gt;&lt;br/&gt;
 #include &amp;lt;string.h&amp;gt;&lt;br/&gt;
 #include &amp;lt;stdint.h&amp;gt;&lt;/p&gt;

&lt;p&gt;+#include &amp;lt;boost/move/unique_ptr.hpp&amp;gt;&lt;br/&gt;
 #include &quot;boost/utility.hpp&quot;&lt;/p&gt;

&lt;p&gt; #include &quot;Config.hh&quot;&lt;br/&gt;
@@ -122,14 +122,14 @@ public:&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a new OutputStream, which grows in memory chunks of specified size.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;OutputStream&amp;gt; memoryOutputStream(size_t chunkSize = 4 * 1024);&lt;br/&gt;
+AVRO_DECL boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; memoryOutputStream(size_t chunkSize = 4 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a new InputStream, with the data from the given byte array.&lt;/li&gt;
	&lt;li&gt;It does not copy the data, the byte array should remain valid&lt;/li&gt;
	&lt;li&gt;until the InputStream is used.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size_t len);&lt;br/&gt;
+AVRO_DECL boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size_t len);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a new InputStream with the contents written into an&lt;br/&gt;
@@ -138,7 +138,7 @@ AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size&lt;/li&gt;
	&lt;li&gt;input stream are the snapshot of the outputstream. One can construct&lt;/li&gt;
	&lt;li&gt;any number of memory input stream from a single memory output stream.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const OutputStream&amp;amp; source);&lt;br/&gt;
+AVRO_DECL boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const OutputStream&amp;amp; source);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns the contents written so far into the output stream, which should&lt;br/&gt;
@@ -154,14 +154,14 @@ AVRO_DECL boost::shared_ptr&amp;lt;std::vector&amp;lt;uint8_t&amp;gt; &amp;gt; snapshot(const OutputStream&amp;amp;&lt;/li&gt;
	&lt;li&gt;If there is a file with the given name, it is truncated and overwritten.&lt;/li&gt;
	&lt;li&gt;If there is no file with the given name, it is created.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;OutputStream&amp;gt; fileOutputStream(const char* filename,&lt;br/&gt;
+AVRO_DECL boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; fileOutputStream(const char* filename,&lt;br/&gt;
     size_t bufferSize = 8 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a new InputStream whose contents come from the given file.&lt;/li&gt;
	&lt;li&gt;Data is read in chunks of given buffer size.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;br/&gt;
+AVRO_DECL boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;br/&gt;
     size_t bufferSize = 8 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;br/&gt;
@@ -169,7 +169,7 @@ AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;std::ostream. The std::ostream object should outlive the returned&lt;/li&gt;
	&lt;li&gt;OutputStream.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(std::ostream&amp;amp; os,&lt;br/&gt;
+AVRO_DECL boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(std::ostream&amp;amp; os,&lt;br/&gt;
     size_t bufferSize = 8 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;br/&gt;
@@ -177,7 +177,7 @@ AVRO_DECL std::auto_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(std::ostream&amp;amp; os,&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;std::istream. The std::istream object should outlive the returned&lt;/li&gt;
	&lt;li&gt;InputStream.&lt;br/&gt;
  */&lt;br/&gt;
-AVRO_DECL std::auto_ptr&amp;lt;InputStream&amp;gt; istreamInputStream(std::istream&amp;amp; in,&lt;br/&gt;
+AVRO_DECL boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; istreamInputStream(std::istream&amp;amp; in,&lt;br/&gt;
     size_t bufferSize = 8 * 1024);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /** A convenience class for reading from an InputStream */&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/examples/custom.cc b/lang/c&lt;/ins&gt;+/examples/custom.cc&lt;br/&gt;
index cfdbeab96..23d722124 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/examples/custom.cc&lt;br/&gt;
+++ b/lang/c++/examples/custom.cc&lt;br/&gt;
@@ -42,13 +42,13 @@ struct codec_traits&amp;lt;std::complex&amp;lt;T&amp;gt; &amp;gt; {&lt;br/&gt;
 int&lt;br/&gt;
 main()&lt;br/&gt;
 {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::binaryEncoder();&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     std::complex&amp;lt;double&amp;gt; c1(1.0, 2.0);&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::binaryDecoder();&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/examples/generated.cc b/lang/c&lt;/ins&gt;+/examples/generated.cc&lt;br/&gt;
index ab93ad209..39359fb4f 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/examples/generated.cc&lt;br/&gt;
+++ b/lang/c++/examples/generated.cc&lt;br/&gt;
@@ -24,7 +24,7 @@&lt;br/&gt;
 int&lt;br/&gt;
 main()&lt;br/&gt;
 {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::binaryEncoder();&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     c::cpx c1;&lt;br/&gt;
@@ -32,7 +32,7 @@ main()&lt;br/&gt;
     c1.im = 2.13;&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::binaryDecoder();&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/examples/generic.cc b/lang/c&lt;/ins&gt;+/examples/generic.cc&lt;br/&gt;
index 12c171fe5..721a6c218 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/examples/generic.cc&lt;br/&gt;
+++ b/lang/c++/examples/generic.cc&lt;br/&gt;
@@ -35,7 +35,7 @@ main()&lt;br/&gt;
     avro::ValidSchema cpxSchema;&lt;br/&gt;
     avro::compileJsonSchema(ifs, cpxSchema);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::binaryEncoder();&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     c::cpx c1;&lt;br/&gt;
@@ -43,7 +43,7 @@ main()&lt;br/&gt;
     c1.im = 105.77;&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::binaryDecoder();&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/examples/resolving.cc b/lang/c&lt;/ins&gt;+/examples/resolving.cc&lt;br/&gt;
index a35eb344b..4c58f6db9 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/examples/resolving.cc&lt;br/&gt;
+++ b/lang/c++/examples/resolving.cc&lt;br/&gt;
@@ -43,7 +43,7 @@ main()&lt;br/&gt;
     avro::ValidSchema cpxSchema = load(&quot;cpx.json&quot;);&lt;br/&gt;
     avro::ValidSchema imaginarySchema = load(&quot;imaginary.json&quot;);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::binaryEncoder();&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     c::cpx c1;&lt;br/&gt;
@@ -51,7 +51,7 @@ main()&lt;br/&gt;
     c1.im = 105.77;&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::resolvingDecoder(cpxSchema, imaginarySchema,&lt;br/&gt;
         avro::binaryDecoder());&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/examples/validating.cc b/lang/c&lt;/ins&gt;+/examples/validating.cc&lt;br/&gt;
index b44555ecc..029d243bc 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/examples/validating.cc&lt;br/&gt;
+++ b/lang/c++/examples/validating.cc&lt;br/&gt;
@@ -49,14 +49,14 @@ main()&lt;br/&gt;
     avro::ValidSchema cpxSchema;&lt;br/&gt;
     avro::compileJsonSchema(ifs, cpxSchema);&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::OutputStream&amp;gt; out = avro::memoryOutputStream();&lt;br/&gt;
     avro::EncoderPtr e = avro::validatingEncoder(cpxSchema,&lt;br/&gt;
         avro::binaryEncoder());&lt;br/&gt;
     e-&amp;gt;init(*out);&lt;br/&gt;
     std::complex&amp;lt;double&amp;gt; c1(1.0, 2.0);&lt;br/&gt;
     avro::encode(*e, c1);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;avro::InputStream&amp;gt; in = avro::memoryInputStream(*out);&lt;br/&gt;
     avro::DecoderPtr d = avro::validatingDecoder(cpxSchema,&lt;br/&gt;
         avro::binaryDecoder());&lt;br/&gt;
     d-&amp;gt;init(*in);&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/impl/Compiler.cc b/lang/c&lt;/ins&gt;+/impl/Compiler.cc&lt;br/&gt;
index be5fe3f86..5153f4909 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/impl/Compiler.cc&lt;br/&gt;
+++ b/lang/c++/impl/Compiler.cc&lt;br/&gt;
@@ -458,7 +458,7 @@ AVRO_DECL ValidSchema compileJsonSchemaFromStream(InputStream&amp;amp; is)&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; AVRO_DECL ValidSchema compileJsonSchemaFromFile(const char* filename)&lt;/p&gt;
 {
-    std::auto_ptr&amp;lt;InputStream&amp;gt; s = fileInputStream(filename);
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; s = fileInputStream(filename);
     return compileJsonSchemaFromStream(*s);
 }

&lt;p&gt;@@ -481,7 +481,7 @@ AVRO_DECL ValidSchema compileJsonSchemaFromString(const std::string&amp;amp; input)&lt;/p&gt;

&lt;p&gt; static ValidSchema compile(std::istream&amp;amp; is)&lt;/p&gt;
 {
-    std::auto_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(is);
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(is);
     return compileJsonSchemaFromStream(*in);
 }

&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/impl/DataFile.cc b/lang/c&lt;/ins&gt;+/impl/DataFile.cc&lt;br/&gt;
index ee8f62c6a..d33c2d54b 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/impl/DataFile.cc&lt;br/&gt;
+++ b/lang/c++/impl/DataFile.cc&lt;br/&gt;
@@ -33,7 +33,7 @@&lt;br/&gt;
 #endif&lt;/p&gt;

&lt;p&gt; namespace avro &lt;/p&gt;
{
-using std::auto_ptr;
+using boost::movelib::unique_ptr;
 using std::ostringstream;
 using std::istringstream;
 using std::vector;
@@ -128,7 +128,7 @@ void DataFileWriterBase::sync()
         int64_t byteCount = buffer_-&amp;gt;byteCount();
         avro::encode(*encoderPtr_, byteCount);
         encoderPtr_-&amp;gt;flush();
-        std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*buffer_);
+        boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*buffer_);
         copy(*in, *stream_);
     }
&lt;p&gt; else if (codec_ == DEFLATE_CODEC) {&lt;br/&gt;
         std::vector&amp;lt;char&amp;gt; buf;&lt;br/&gt;
@@ -139,12 +139,12 @@ void DataFileWriterBase::sync()&lt;br/&gt;
             const uint8_t* data;&lt;br/&gt;
             size_t len;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; input = memoryInputStream(*buffer_);&lt;br/&gt;
+            boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; input = memoryInputStream(*buffer_);&lt;br/&gt;
             while (input-&amp;gt;next(&amp;amp;data, &amp;amp;len)) 
{
                 boost::iostreams::write(os, reinterpret_cast&amp;lt;const char*&amp;gt;(data), len);
             }
&lt;p&gt;         } // make sure all is flushed&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(&lt;br/&gt;
+        boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(&lt;br/&gt;
            reinterpret_cast&amp;lt;const uint8_t*&amp;gt;(&amp;amp;buf&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;), buf.size());&lt;br/&gt;
         int64_t byteCount = buf.size();&lt;br/&gt;
         avro::encode(*encoderPtr_, byteCount);&lt;br/&gt;
@@ -161,7 +161,7 @@ void DataFileWriterBase::sync()&lt;br/&gt;
             const uint8_t* data;&lt;br/&gt;
             size_t len;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; input = memoryInputStream(*buffer_);&lt;br/&gt;
+            boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; input = memoryInputStream(*buffer_);&lt;br/&gt;
             while (input-&amp;gt;next(&amp;amp;data, &amp;amp;len)) {&lt;br/&gt;
                 boost::iostreams::write(os, reinterpret_cast&amp;lt;const char*&amp;gt;(data),&lt;br/&gt;
                         len);&lt;br/&gt;
@@ -186,7 +186,7 @@ void DataFileWriterBase::sync()&lt;br/&gt;
         temp.push_back((checksum &amp;gt;&amp;gt; 16) &amp;amp; 0xFF);&lt;br/&gt;
         temp.push_back((checksum &amp;gt;&amp;gt; 8) &amp;amp; 0xFF);&lt;br/&gt;
         temp.push_back(checksum &amp;amp; 0xFF);&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(&lt;br/&gt;
+        boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(&lt;br/&gt;
                 reinterpret_cast&amp;lt;const uint8_t*&amp;gt;(&amp;amp;temp&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;), temp.size());&lt;br/&gt;
         int64_t byteCount = temp.size();&lt;br/&gt;
         avro::encode(*encoderPtr_, byteCount);&lt;br/&gt;
@@ -350,9 +350,9 @@ class BoundedInputStream : public InputStream {&lt;br/&gt;
         in_(in), limit_(limit) { }&lt;br/&gt;
 };&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-auto_ptr&amp;lt;InputStream&amp;gt; boundedInputStream(InputStream&amp;amp; in, size_t limit)&lt;br/&gt;
+unique_ptr&amp;lt;InputStream&amp;gt; boundedInputStream(InputStream&amp;amp; in, size_t limit)&lt;/p&gt;
 {
-    return auto_ptr&amp;lt;InputStream&amp;gt;(new BoundedInputStream(in, limit));
+    return unique_ptr&amp;lt;InputStream&amp;gt;(new BoundedInputStream(in, limit));
 }

&lt;p&gt; bool DataFileReaderBase::readDataBlock()&lt;br/&gt;
@@ -370,10 +370,10 @@ bool DataFileReaderBase::readDataBlock()&lt;br/&gt;
     avro::decode(*decoder_, byteCount);&lt;br/&gt;
     decoder_-&amp;gt;init(*stream_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; st = boundedInputStream(*stream_, static_cast&amp;lt;size_t&amp;gt;(byteCount));&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; st = boundedInputStream(*stream_, static_cast&amp;lt;size_t&amp;gt;(byteCount));&lt;br/&gt;
     if (codec_ == NULL_CODEC) 
{
         dataDecoder_-&amp;gt;init(*st);
-        dataStream_ = st;
+        dataStream_ = boost::move(st);
     }
&lt;p&gt; else if (codec_ == DEFLATE_CODEC) &lt;/p&gt;
{
         compressed_.clear();
         const uint8_t* data;
@@ -387,9 +387,9 @@ bool DataFileReaderBase::readDataBlock()
         os_-&amp;gt;push(boost::iostreams::basic_array_source&amp;lt;char&amp;gt;(
             &amp;amp;compressed_[0], compressed_.size()));
 
-        std::auto_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(*os_);
+        boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(*os_);
         dataDecoder_-&amp;gt;init(*in);
-        dataStream_ = in;
+        dataStream_ = boost::move(in);
 #ifdef SNAPPY_CODEC_AVAILABLE
     }
&lt;p&gt; else if (codec_ == SNAPPY_CODEC) &lt;/p&gt;
{
         boost::crc_32_type crc;
@@ -422,10 +422,10 @@ bool DataFileReaderBase::readDataBlock()
         os_-&amp;gt;push(
                 boost::iostreams::basic_array_source&amp;lt;char&amp;gt;(uncompressed.c_str(),
                         uncompressed.size()));
-        std::auto_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(*os_);
+        boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = istreamInputStream(*os_);
 
         dataDecoder_-&amp;gt;init(*in);
-        dataStream_ = in;
+        dataStream_ = boost::move(in);
 #endif
     }
&lt;p&gt; else {&lt;br/&gt;
         throw Exception(&quot;Bad codec&quot;);&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/impl/FileStream.cc b/lang/c&lt;/ins&gt;+/impl/FileStream.cc&lt;br/&gt;
index 39c5af23c..48f038864 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/impl/FileStream.cc&lt;br/&gt;
+++ b/lang/c++/impl/FileStream.cc&lt;br/&gt;
@@ -34,7 +34,7 @@&lt;br/&gt;
 #endif&lt;br/&gt;
 #endif&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using boost::movelib::unique_ptr;&lt;br/&gt;
 using std::istream;&lt;br/&gt;
 using std::ostream;&lt;/p&gt;

&lt;p&gt;@@ -138,7 +138,7 @@ struct IStreamBufferCopyIn : public BufferCopyIn {&lt;br/&gt;
 class BufferCopyInInputStream : public InputStream {&lt;br/&gt;
     const size_t bufferSize_;&lt;br/&gt;
     uint8_t* const buffer_;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;BufferCopyIn&amp;gt; in_;&lt;br/&gt;
+    unique_ptr&amp;lt;BufferCopyIn&amp;gt; in_;&lt;br/&gt;
     size_t byteCount_;&lt;br/&gt;
     uint8_t* next_;&lt;br/&gt;
     size_t available_;&lt;br/&gt;
@@ -190,10 +190,10 @@ class BufferCopyInInputStream : public InputStream {&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt; public:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferCopyInInputStream(auto_ptr&amp;lt;BufferCopyIn&amp;gt;&amp;amp; in, size_t bufferSize) :&lt;br/&gt;
+    BufferCopyInInputStream(unique_ptr&amp;lt;BufferCopyIn&amp;gt; in, size_t bufferSize) :&lt;br/&gt;
         bufferSize_(bufferSize),&lt;br/&gt;
         buffer_(new uint8_t&lt;span class=&quot;error&quot;&gt;&amp;#91;bufferSize&amp;#93;&lt;/span&gt;),&lt;/li&gt;
	&lt;li&gt;in_(in),&lt;br/&gt;
+        in_(boost::move(in)),&lt;br/&gt;
         byteCount_(0),&lt;br/&gt;
         next_(buffer_),&lt;br/&gt;
         available_(0) { }&lt;br/&gt;
@@ -276,7 +276,7 @@ struct OStreamBufferCopyOut : public BufferCopyOut {&lt;br/&gt;
 class BufferCopyOutputStream : public OutputStream {&lt;br/&gt;
     size_t bufferSize_;&lt;br/&gt;
     uint8_t* const buffer_;&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;BufferCopyOut&amp;gt; out_;&lt;br/&gt;
+    unique_ptr&amp;lt;BufferCopyOut&amp;gt; out_;&lt;br/&gt;
     uint8_t* next_;&lt;br/&gt;
     size_t available_;&lt;br/&gt;
     size_t byteCount_;&lt;br/&gt;
@@ -311,10 +311,10 @@ class BufferCopyOutputStream : public OutputStream {&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; public:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BufferCopyOutputStream(auto_ptr&amp;lt;BufferCopyOut&amp;gt; out, size_t bufferSize) :&lt;br/&gt;
+    BufferCopyOutputStream(unique_ptr&amp;lt;BufferCopyOut&amp;gt; out, size_t bufferSize) :&lt;br/&gt;
         bufferSize_(bufferSize),&lt;br/&gt;
         buffer_(new uint8_t&lt;span class=&quot;error&quot;&gt;&amp;#91;bufferSize&amp;#93;&lt;/span&gt;),&lt;/li&gt;
	&lt;li&gt;out_(out),&lt;br/&gt;
+        out_(boost::move(out)),&lt;br/&gt;
         next_(buffer_),&lt;br/&gt;
         available_(bufferSize_), byteCount_(0) { }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -323,32 +323,32 @@ class BufferCopyOutputStream : public OutputStream {&lt;br/&gt;
     }&lt;br/&gt;
 };&lt;/p&gt;

&lt;p&gt;-auto_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;br/&gt;
+unique_ptr&amp;lt;InputStream&amp;gt; fileInputStream(const char* filename,&lt;br/&gt;
     size_t bufferSize)&lt;/p&gt;
 {
-    auto_ptr&amp;lt;BufferCopyIn&amp;gt; in(new FileBufferCopyIn(filename));
-    return auto_ptr&amp;lt;InputStream&amp;gt;( new BufferCopyInInputStream(in, bufferSize));
+    unique_ptr&amp;lt;BufferCopyIn&amp;gt; in(new FileBufferCopyIn(filename));
+    return unique_ptr&amp;lt;InputStream&amp;gt;( new BufferCopyInInputStream(boost::move(in), bufferSize));
 }

&lt;p&gt;-auto_ptr&amp;lt;InputStream&amp;gt; istreamInputStream(istream&amp;amp; is,&lt;br/&gt;
+unique_ptr&amp;lt;InputStream&amp;gt; istreamInputStream(istream&amp;amp; is,&lt;br/&gt;
     size_t bufferSize)&lt;/p&gt;
 {
-    auto_ptr&amp;lt;BufferCopyIn&amp;gt; in(new IStreamBufferCopyIn(is));
-    return auto_ptr&amp;lt;InputStream&amp;gt;( new BufferCopyInInputStream(in, bufferSize));
+    unique_ptr&amp;lt;BufferCopyIn&amp;gt; in(new IStreamBufferCopyIn(is));
+    return unique_ptr&amp;lt;InputStream&amp;gt;( new BufferCopyInInputStream(boost::move(in), bufferSize));
 }

&lt;p&gt;-auto_ptr&amp;lt;OutputStream&amp;gt; fileOutputStream(const char* filename,&lt;br/&gt;
+unique_ptr&amp;lt;OutputStream&amp;gt; fileOutputStream(const char* filename,&lt;br/&gt;
     size_t bufferSize)&lt;/p&gt;
 {
-    auto_ptr&amp;lt;BufferCopyOut&amp;gt; out(new FileBufferCopyOut(filename));
-    return auto_ptr&amp;lt;OutputStream&amp;gt;(new BufferCopyOutputStream(out, bufferSize));
+    unique_ptr&amp;lt;BufferCopyOut&amp;gt; out(new FileBufferCopyOut(filename));
+    return unique_ptr&amp;lt;OutputStream&amp;gt;(new BufferCopyOutputStream(boost::move(out), bufferSize));
 }

&lt;p&gt;-auto_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(ostream&amp;amp; os,&lt;br/&gt;
+unique_ptr&amp;lt;OutputStream&amp;gt; ostreamOutputStream(ostream&amp;amp; os,&lt;br/&gt;
     size_t bufferSize)&lt;/p&gt;
 {
-    auto_ptr&amp;lt;BufferCopyOut&amp;gt; out(new OStreamBufferCopyOut(os));
-    return auto_ptr&amp;lt;OutputStream&amp;gt;(new BufferCopyOutputStream(out, bufferSize));
+    unique_ptr&amp;lt;BufferCopyOut&amp;gt; out(new OStreamBufferCopyOut(os));
+    return unique_ptr&amp;lt;OutputStream&amp;gt;(new BufferCopyOutputStream(boost::move(out), bufferSize));
 }


&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/impl/Stream.cc b/lang/c&lt;/ins&gt;+/impl/Stream.cc&lt;br/&gt;
index 5da5edbcc..263410932 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/impl/Stream.cc&lt;br/&gt;
+++ b/lang/c++/impl/Stream.cc&lt;br/&gt;
@@ -157,23 +157,23 @@ class MemoryOutputStream : public OutputStream {&lt;br/&gt;
     void flush() { }&lt;br/&gt;
 };&lt;/p&gt;

&lt;p&gt;-std::auto_ptr&amp;lt;OutputStream&amp;gt; memoryOutputStream(size_t chunkSize)&lt;br/&gt;
+boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; memoryOutputStream(size_t chunkSize)&lt;/p&gt;
 {
-    return std::auto_ptr&amp;lt;OutputStream&amp;gt;(new MemoryOutputStream(chunkSize));
+    return boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt;(new MemoryOutputStream(chunkSize));
 }

&lt;p&gt;-std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size_t len)&lt;br/&gt;
+boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const uint8_t* data, size_t len)&lt;/p&gt;
 {
-    return std::auto_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream2(data, len));
+    return boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream2(data, len));
 }

&lt;p&gt;-std::auto_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const OutputStream&amp;amp; source)&lt;br/&gt;
+boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; memoryInputStream(const OutputStream&amp;amp; source)&lt;/p&gt;
 {
     const MemoryOutputStream&amp;amp; mos =
         dynamic_cast&amp;lt;const MemoryOutputStream&amp;amp;&amp;gt;(source);
     return (mos.data_.empty()) ?
-        std::auto_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream2(0, 0)) :
-        std::auto_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream(mos.data_,
+        boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream2(0, 0)) :
+        boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt;(new MemoryInputStream(mos.data_,
             mos.chunkSize_,
             (mos.chunkSize_ - mos.available_)));
 }
&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/impl/json/JsonDom.cc b/lang/c&lt;/ins&gt;+/impl/json/JsonDom.cc&lt;br/&gt;
index 3f52f363b..96ccf6006 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/impl/json/JsonDom.cc&lt;br/&gt;
+++ b/lang/c++/impl/json/JsonDom.cc&lt;br/&gt;
@@ -106,7 +106,7 @@ Entity loadEntity(InputStream&amp;amp; in)&lt;/p&gt;

&lt;p&gt; Entity loadEntity(const uint8_t* text, size_t len)&lt;/p&gt;
 {
-    std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(text, len);
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(text, len);
     return loadEntity(*in);
 }

&lt;p&gt;@@ -165,12 +165,12 @@ void Entity::ensureType(EntityType type) const&lt;/p&gt;

&lt;p&gt; std::string Entity::toString() const&lt;br/&gt;
 {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; out = memoryOutputStream();&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; out = memoryOutputStream();&lt;br/&gt;
     JsonGenerator&amp;lt;JsonNullFormatter&amp;gt; g;&lt;br/&gt;
     g.init(*out);&lt;br/&gt;
     writeEntity(g, *this);&lt;br/&gt;
     g.flush();&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*out);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*out);&lt;br/&gt;
     const uint8_t *p = 0;&lt;br/&gt;
     size_t n = 0;&lt;br/&gt;
     size_t c = 0;&lt;br/&gt;
@@ -180,7 +180,7 @@ std::string Entity::toString() const&lt;br/&gt;
     std::string result;&lt;br/&gt;
     result.resize(c);&lt;br/&gt;
     c = 0;&lt;/li&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*out);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*out);&lt;br/&gt;
     while (in2-&amp;gt;next(&amp;amp;p, &amp;amp;n)) {&lt;br/&gt;
         ::memcpy(&amp;amp;result&lt;span class=&quot;error&quot;&gt;&amp;#91;c&amp;#93;&lt;/span&gt;, p, n);&lt;br/&gt;
         c += n;&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/impl/parsing/ResolvingDecoder.cc b/lang/c&lt;/ins&gt;+/impl/parsing/ResolvingDecoder.cc&lt;br/&gt;
index e0d25edfd..1a9cbe3b8 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/impl/parsing/ResolvingDecoder.cc&lt;br/&gt;
+++ b/lang/c++/impl/parsing/ResolvingDecoder.cc&lt;br/&gt;
@@ -49,7 +49,7 @@ using boost::shared_ptr;&lt;br/&gt;
 using boost::static_pointer_cast;&lt;br/&gt;
 using boost::make_shared;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using boost::movelib::unique_ptr;&lt;br/&gt;
 using std::map;&lt;br/&gt;
 using std::pair;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
@@ -156,7 +156,7 @@ static shared_ptr&amp;lt;vector&amp;lt;uint8_t&amp;gt; &amp;gt; getAvroBinary(&lt;br/&gt;
     const GenericDatum&amp;amp; defaultValue)&lt;br/&gt;
 {&lt;br/&gt;
     EncoderPtr e = binaryEncoder();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
     e-&amp;gt;init(*os);&lt;br/&gt;
     GenericWriter::write(*e, defaultValue);&lt;br/&gt;
     e-&amp;gt;flush();&lt;br/&gt;
@@ -447,7 +447,7 @@ ProductionPtr ResolvingGrammarGenerator::doGenerate2(&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; class ResolvingDecoderHandler {&lt;br/&gt;
     shared_ptr&amp;lt;vector&amp;lt;uint8_t&amp;gt; &amp;gt; defaultData_;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; inp_;&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; inp_;&lt;br/&gt;
     DecoderPtr backup_;&lt;br/&gt;
     DecoderPtr&amp;amp; base_;&lt;br/&gt;
     const DecoderPtr binDecoder;&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/test/AvrogencppTests.cc b/lang/c&lt;/ins&gt;+/test/AvrogencppTests.cc&lt;br/&gt;
index 1b429433c..c009739b4 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/test/AvrogencppTests.cc&lt;br/&gt;
+++ b/lang/c++/test/AvrogencppTests.cc&lt;br/&gt;
@@ -45,7 +45,7 @@&lt;br/&gt;
 #endif&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using boost::movelib::unique_ptr;&lt;br/&gt;
 using std::map;&lt;br/&gt;
 using std::string;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
@@ -147,7 +147,7 @@ void testEncoding()&lt;br/&gt;
     ValidSchema s;&lt;br/&gt;
     ifstream ifs(&quot;jsonschemas/bigrecord&quot;);&lt;br/&gt;
     compileJsonSchema(ifs, s);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
     EncoderPtr e = validatingEncoder(s, binaryEncoder());&lt;br/&gt;
     e-&amp;gt;init(*os);&lt;br/&gt;
     testgen::RootRecord t1;&lt;br/&gt;
@@ -156,7 +156,7 @@ void testEncoding()&lt;br/&gt;
     e-&amp;gt;flush();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     DecoderPtr d = validatingDecoder(s, binaryDecoder());&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
     d-&amp;gt;init(*is);&lt;br/&gt;
     testgen::RootRecord t2;&lt;br/&gt;
     avro::decode(*d, t2);&lt;br/&gt;
@@ -169,7 +169,7 @@ void testResolution()&lt;br/&gt;
     ValidSchema s_w;&lt;br/&gt;
     ifstream ifs_w(&quot;jsonschemas/bigrecord&quot;);&lt;br/&gt;
     compileJsonSchema(ifs_w, s_w);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
     EncoderPtr e = validatingEncoder(s_w, binaryEncoder());&lt;br/&gt;
     e-&amp;gt;init(*os);&lt;br/&gt;
     testgen::RootRecord t1;&lt;br/&gt;
@@ -181,7 +181,7 @@ void testResolution()&lt;br/&gt;
     ifstream ifs_r(&quot;jsonschemas/bigrecord_r&quot;);&lt;br/&gt;
     compileJsonSchema(ifs_r, s_r);&lt;br/&gt;
     DecoderPtr dd = binaryDecoder();&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
     dd-&amp;gt;init(*is);&lt;br/&gt;
     DecoderPtr rd = resolvingDecoder(s_w, s_r, dd);&lt;br/&gt;
     testgen_r::RootRecord t2;&lt;br/&gt;
@@ -191,7 +191,7 @@ void testResolution()&lt;br/&gt;
     checkDefaultValues(t2);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     //Re-use the resolving decoder to decode again.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; is1 = memoryInputStream(*os);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; is1 = memoryInputStream(*os);&lt;br/&gt;
     rd-&amp;gt;init(*is1);&lt;br/&gt;
     testgen_r::RootRecord t3;&lt;br/&gt;
     avro::decode(*rd, t3);&lt;br/&gt;
@@ -250,7 +250,7 @@ void testEncoding2()&lt;br/&gt;
     ifstream ifs(schemaFilename&amp;lt;T&amp;gt;::value);&lt;br/&gt;
     compileJsonSchema(ifs, s);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();&lt;br/&gt;
     EncoderPtr e = validatingEncoder(s, binaryEncoder());&lt;br/&gt;
     e-&amp;gt;init(*os);&lt;br/&gt;
     T t1;&lt;br/&gt;
@@ -259,7 +259,7 @@ void testEncoding2()&lt;br/&gt;
     e-&amp;gt;flush();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     DecoderPtr d = validatingDecoder(s, binaryDecoder());&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);&lt;br/&gt;
     d-&amp;gt;init(*is);&lt;br/&gt;
     T t2;&lt;br/&gt;
     avro::decode(*d, t2);&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/test/CodecTests.cc b/lang/c&lt;/ins&gt;+/test/CodecTests.cc&lt;br/&gt;
index f8bbe84d0..04870aa25 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/test/CodecTests.cc&lt;br/&gt;
+++ b/lang/c++/test/CodecTests.cc&lt;br/&gt;
@@ -43,7 +43,7 @@ namespace avro {&lt;br/&gt;
 /*&lt;br/&gt;
 void dump(const OutputStream&amp;amp; os)
 {
-    std::auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(os);
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(os);
     const char *b;
     size_t n;
     std::cout &amp;lt;&amp;lt; os.byteCount() &amp;lt;&amp;lt; std::endl;
@@ -91,7 +91,7 @@ using std::istringstream;
 using std::ostringstream;
 using std::back_inserter;
 using std::copy;
-using std::auto_ptr;
+using boost::movelib::unique_ptr;
 
 template &amp;lt;typename T&amp;gt;
 T from_string(const std::string&amp;amp; s)
@@ -230,12 +230,12 @@ static vector&amp;lt;string&amp;gt; randomValues(const char* calls)
     return result;
 }&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-static auto_ptr&amp;lt;OutputStream&amp;gt; generate(Encoder&amp;amp; e, const char* calls,&lt;br/&gt;
+static unique_ptr&amp;lt;OutputStream&amp;gt; generate(Encoder&amp;amp; e, const char* calls,&lt;br/&gt;
     const vector&amp;lt;string&amp;gt;&amp;amp; values)&lt;br/&gt;
 {&lt;br/&gt;
     Scanner sc(calls);&lt;br/&gt;
     vector&amp;lt;string&amp;gt;::const_iterator it = values.begin();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
     e.init(*ob);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     while (! sc.isDone()) &lt;/p&gt;
{
@@ -302,7 +302,7 @@ static auto_ptr&amp;lt;OutputStream&amp;gt; generate(Encoder&amp;amp; e, const char* calls,
         }
&lt;p&gt;     }&lt;br/&gt;
     e.flush();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return ob;&lt;br/&gt;
+    return boost::move(ob);&lt;br/&gt;
 }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; namespace &lt;/p&gt;
{
@@ -537,7 +537,7 @@ ValidSchema makeValidSchema(const char* schema)
 }

&lt;p&gt; void testEncoder(const EncoderPtr&amp;amp; e, const char* writerCalls,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;vector&amp;lt;string&amp;gt;&amp;amp; v, auto_ptr&amp;lt;OutputStream&amp;gt;&amp;amp; p)&lt;br/&gt;
+    vector&amp;lt;string&amp;gt;&amp;amp; v, unique_ptr&amp;lt;OutputStream&amp;gt;&amp;amp; p)&lt;br/&gt;
 {&lt;br/&gt;
     v = randomValues(writerCalls);&lt;br/&gt;
     p = generate(*e, writerCalls, v);&lt;br/&gt;
@@ -615,7 +615,7 @@ void testCodec(const TestData&amp;amp; td) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     for (unsigned int i = 0; i &amp;lt; count; ++i) {&lt;br/&gt;
         vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
         testEncoder(CodecFactory::newEncoder(vs), td.calls, v, p);&lt;br/&gt;
         // dump(*p);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -631,7 +631,7 @@ void testCodec(const TestData&amp;amp; td) &lt;/p&gt;
{
                 &amp;lt;&amp;lt; &quot; schema: &quot; &amp;lt;&amp;lt; td.schema
                 &amp;lt;&amp;lt; &quot; calls: &quot; &amp;lt;&amp;lt; td.calls
                 &amp;lt;&amp;lt; &quot; skip-level: &quot; &amp;lt;&amp;lt; skipLevel);
-            auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
+            unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
             testDecoder(CodecFactory::newDecoder(vs), v, *in,
                 td.calls, skipLevel);
         }
&lt;p&gt;@@ -653,7 +653,7 @@ void testCodecResolving(const TestData3&amp;amp; td) {&lt;/p&gt;

&lt;p&gt;     for (unsigned int i = 0; i &amp;lt; count; ++i) {&lt;br/&gt;
         vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
         testEncoder(CodecFactory::newEncoder(vs), td.writerCalls, v, p);&lt;br/&gt;
         // dump(*p);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -666,7 +666,7 @@ void testCodecResolving(const TestData3&amp;amp; td) &lt;/p&gt;
{
                 &amp;lt;&amp;lt; &quot; reader schema: &quot; &amp;lt;&amp;lt; td.readerSchema
                 &amp;lt;&amp;lt; &quot; reader calls: &quot; &amp;lt;&amp;lt; td.readerCalls
                 &amp;lt;&amp;lt; &quot; skip-level: &quot; &amp;lt;&amp;lt; skipLevel);
-            auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
+            unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
             testDecoder(CodecFactory::newDecoder(vs, rvs), v, *in,
                 td.readerCalls, skipLevel);
         }
&lt;p&gt;@@ -696,7 +696,7 @@ void testCodecResolving2(const TestData4&amp;amp; td) {&lt;br/&gt;
     ValidSchema vs = makeValidSchema(td.writerSchema);&lt;/p&gt;

&lt;p&gt;     vector&amp;lt;string&amp;gt; wd = mkValues(td.writerValues);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p =&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; p =&lt;br/&gt;
         generate(*CodecFactory::newEncoder(vs), td.writerCalls, wd);&lt;br/&gt;
     // dump(*p);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -710,7 +710,7 @@ void testCodecResolving2(const TestData4&amp;amp; td) &lt;/p&gt;
{
             &amp;lt;&amp;lt; &quot; reader schema: &quot; &amp;lt;&amp;lt; td.readerSchema
             &amp;lt;&amp;lt; &quot; reader calls: &quot; &amp;lt;&amp;lt; td.readerCalls
             &amp;lt;&amp;lt; &quot; skip-level: &quot; &amp;lt;&amp;lt; skipLevel);
-        auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
+        unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);
         testDecoder(CodecFactory::newDecoder(vs, rvs), rd, *in,
             td.readerCalls, skipLevel);
     }
&lt;p&gt;@@ -728,9 +728,9 @@ void testReaderFail(const TestData2&amp;amp; td) {&lt;br/&gt;
     ValidSchema vs = makeValidSchema(td.schema);&lt;/p&gt;

&lt;p&gt;     vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
     testEncoder(CodecFactory::newEncoder(vs), td.correctCalls, v, p);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; in = memoryInputStream(*p);&lt;br/&gt;
     BOOST_CHECK_THROW(&lt;br/&gt;
         testDecoder(CodecFactory::newDecoder(vs), v, *in,&lt;br/&gt;
             td.incorrectCalls, td.depth), Exception);&lt;br/&gt;
@@ -746,7 +746,7 @@ void testWriterFail(const TestData2&amp;amp; td) 
{
     ValidSchema vs = makeValidSchema(td.schema);
 
     vector&amp;lt;string&amp;gt; v;
-    auto_ptr&amp;lt;OutputStream&amp;gt; p;
+    unique_ptr&amp;lt;OutputStream&amp;gt; p;
     BOOST_CHECK_THROW(testEncoder(CodecFactory::newEncoder(vs),
         td.incorrectCalls, v, p), Exception);
 }
&lt;p&gt;@@ -763,17 +763,17 @@ void testGeneric(const TestData&amp;amp; td) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     for (unsigned int i = 0; i &amp;lt; count; ++i) {&lt;br/&gt;
         vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
         testEncoder(CodecFactory::newEncoder(vs), td.calls, v, p);&lt;br/&gt;
         // dump(*p);&lt;br/&gt;
         DecoderPtr d1 = CodecFactory::newDecoder(vs);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
+        unique_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
         d1-&amp;gt;init(*in1);&lt;br/&gt;
         GenericDatum datum(vs);&lt;br/&gt;
         avro::decode(*d1, datum);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         EncoderPtr e2 = CodecFactory::newEncoder(vs);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
         e2-&amp;gt;init(*ob);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         avro::encode(*e2, datum);&lt;br/&gt;
@@ -782,7 +782,7 @@ void testGeneric(const TestData&amp;amp; td) &lt;/p&gt;
{
         BOOST_TEST_CHECKPOINT(&quot;Test: &quot; &amp;lt;&amp;lt; testNo &amp;lt;&amp;lt; &apos; &apos;
             &amp;lt;&amp;lt; &quot; schema: &quot; &amp;lt;&amp;lt; td.schema
             &amp;lt;&amp;lt; &quot; calls: &quot; &amp;lt;&amp;lt; td.calls);
-        auto_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*ob);
+        unique_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*ob);
         testDecoder(CodecFactory::newDecoder(vs), v, *in2,
             td.calls, td.depth);
     }
&lt;p&gt;@@ -804,11 +804,11 @@ void testGenericResolving(const TestData3&amp;amp; td) {&lt;/p&gt;

&lt;p&gt;     for (unsigned int i = 0; i &amp;lt; count; ++i) {&lt;br/&gt;
         vector&amp;lt;string&amp;gt; v;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; p;&lt;br/&gt;
         testEncoder(CodecFactory::newEncoder(wvs), td.writerCalls, v, p);&lt;br/&gt;
         // dump(*p);&lt;br/&gt;
         DecoderPtr d1 = CodecFactory::newDecoder(wvs);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
+        unique_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
         d1-&amp;gt;init(*in1);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         GenericReader gr(wvs, rvs, d1);&lt;br/&gt;
@@ -816,7 +816,7 @@ void testGenericResolving(const TestData3&amp;amp; td) {&lt;br/&gt;
         gr.read(datum);&lt;/p&gt;

&lt;p&gt;         EncoderPtr e2 = CodecFactory::newEncoder(rvs);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
+        unique_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
         e2-&amp;gt;init(*ob);&lt;br/&gt;
         avro::encode(*e2, datum);&lt;br/&gt;
         e2-&amp;gt;flush();&lt;br/&gt;
@@ -826,7 +826,7 @@ void testGenericResolving(const TestData3&amp;amp; td) 
{
             &amp;lt;&amp;lt; &quot; writer-calls: &quot; &amp;lt;&amp;lt; td.writerCalls 
             &amp;lt;&amp;lt; &quot; reader-schema: &quot; &amp;lt;&amp;lt; td.readerSchema
             &amp;lt;&amp;lt; &quot; calls: &quot; &amp;lt;&amp;lt; td.readerCalls);
-        auto_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*ob);
+        unique_ptr&amp;lt;InputStream&amp;gt; in2 = memoryInputStream(*ob);
         testDecoder(CodecFactory::newDecoder(rvs), v, *in2,
             td.readerCalls, td.depth);
     }
&lt;p&gt;@@ -848,11 +848,11 @@ void testGenericResolving2(const TestData4&amp;amp; td) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     const vector&amp;lt;string&amp;gt; wd = mkValues(td.writerValues);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; p = generate(*CodecFactory::newEncoder(wvs),&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; p = generate(*CodecFactory::newEncoder(wvs),&lt;br/&gt;
         td.writerCalls, wd);&lt;br/&gt;
     // dump(*p);&lt;br/&gt;
     DecoderPtr d1 = CodecFactory::newDecoder(wvs);&lt;/li&gt;
	&lt;li&gt;auto_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
+    unique_ptr&amp;lt;InputStream&amp;gt; in1 = memoryInputStream(*p);&lt;br/&gt;
     d1-&amp;gt;init(*in1);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     GenericReader gr(wvs, rvs, d1);&lt;br/&gt;
@@ -860,7 +860,7 @@ void testGenericResolving2(const TestData4&amp;amp; td) {&lt;br/&gt;
     gr.read(datum);&lt;/p&gt;

&lt;p&gt;     EncoderPtr e2 = CodecFactory::newEncoder(rvs);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; ob = memoryOutputStream();&lt;br/&gt;
     e2-&amp;gt;init(*ob);&lt;br/&gt;
     avro::encode(*e2, datum);&lt;br/&gt;
     e2-&amp;gt;flush();&lt;br/&gt;
@@ -1489,7 +1489,7 @@ static void testStreamLifetimes()&lt;br/&gt;
 {&lt;br/&gt;
     EncoderPtr e = binaryEncoder();
     {
-        std::auto_ptr&amp;lt;OutputStream&amp;gt; s1 = memoryOutputStream();
+        boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; s1 = memoryOutputStream();
         e-&amp;gt;init(*s1);
         e-&amp;gt;encodeInt(100);
         e-&amp;gt;encodeDouble(4.73);
@@ -1497,7 +1497,7 @@ static void testStreamLifetimes()
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; s2 = memoryOutputStream();&lt;br/&gt;
+        boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; s2 = memoryOutputStream();&lt;br/&gt;
         e-&amp;gt;init(*s2);&lt;br/&gt;
         e-&amp;gt;encodeDouble(3.14);&lt;br/&gt;
         e-&amp;gt;flush();&lt;br/&gt;
@@ -1507,7 +1507,7 @@ static void testStreamLifetimes()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; static void testLimits(const EncoderPtr&amp;amp; e, const DecoderPtr&amp;amp; d)&lt;br/&gt;
 {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;OutputStream&amp;gt; s1 = memoryOutputStream();&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; s1 = memoryOutputStream();
     {
         e-&amp;gt;init(*s1);
         e-&amp;gt;encodeDouble(std::numeric_limits&amp;lt;double&amp;gt;::infinity());
@@ -1524,7 +1524,7 @@ static void testLimits(const EncoderPtr&amp;amp; e, const DecoderPtr&amp;amp; d)
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; s2 = memoryInputStream(*s1);&lt;br/&gt;
+        boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; s2 = memoryInputStream(*s1);&lt;br/&gt;
         d-&amp;gt;init(*s2);&lt;br/&gt;
         BOOST_CHECK_EQUAL(d-&amp;gt;decodeDouble(),&lt;br/&gt;
             std::numeric_limits&amp;lt;double&amp;gt;::infinity());&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/test/DataFileTests.cc b/lang/c&lt;/ins&gt;+/test/DataFileTests.cc&lt;br/&gt;
index 27a7ce9ca..874c03970 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/c++/test/DataFileTests.cc&lt;br/&gt;
+++ b/lang/c++/test/DataFileTests.cc&lt;br/&gt;
@@ -27,7 +27,7 @@&lt;br/&gt;
 #include &quot;Stream.hh&quot;&lt;br/&gt;
 #include &quot;Compiler.hh&quot;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using boost::movelib::unique_ptr;&lt;br/&gt;
 using std::string;&lt;br/&gt;
 using std::pair;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
@@ -360,9 +360,9 @@ class DataFileTest {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs the DataFileReader in two steps.&lt;br/&gt;
      */&lt;br/&gt;
     void testReadDoubleTwoStep() {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;avro::DataFileReaderBase&amp;gt;&lt;br/&gt;
+        unique_ptr&amp;lt;avro::DataFileReaderBase&amp;gt;&lt;br/&gt;
             base(new avro::DataFileReaderBase(filename));&lt;/li&gt;
	&lt;li&gt;avro::DataFileReader&amp;lt;ComplexDouble&amp;gt; df(base);&lt;br/&gt;
+        avro::DataFileReader&amp;lt;ComplexDouble&amp;gt; df(boost::move(base));&lt;br/&gt;
         BOOST_CHECK_EQUAL(toString(writerSchema), toString(df.readerSchema()));&lt;br/&gt;
         BOOST_CHECK_EQUAL(toString(writerSchema), toString(df.dataSchema()));&lt;br/&gt;
         int i = 0;&lt;br/&gt;
@@ -384,9 +384,9 @@ class DataFileTest {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;reader schema.&lt;br/&gt;
      */&lt;br/&gt;
     void testReadDoubleTwoStepProject() {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;avro::DataFileReaderBase&amp;gt;&lt;br/&gt;
+        unique_ptr&amp;lt;avro::DataFileReaderBase&amp;gt;&lt;br/&gt;
             base(new avro::DataFileReaderBase(filename));&lt;/li&gt;
	&lt;li&gt;avro::DataFileReader&amp;lt;Double&amp;gt; df(base, readerSchema);&lt;br/&gt;
+        avro::DataFileReader&amp;lt;Double&amp;gt; df(boost::move(base), readerSchema);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         BOOST_CHECK_EQUAL(toString(readerSchema), toString(df.readerSchema()));&lt;br/&gt;
         BOOST_CHECK_EQUAL(toString(writerSchema), toString(df.dataSchema()));&lt;br/&gt;
diff --git a/lang/c+&lt;ins&gt;/test/SpecificTests.cc b/lang/c&lt;/ins&gt;+/test/SpecificTests.cc&lt;br/&gt;
index aec338ca0..44ff093ed 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/test/SpecificTests.cc&lt;br/&gt;
+++ b/lang/c++/test/SpecificTests.cc&lt;br/&gt;
@@ -22,7 +22,7 @@&lt;br/&gt;
 #include &quot;Specific.hh&quot;&lt;br/&gt;
 #include &quot;Stream.hh&quot;&lt;/p&gt;

&lt;p&gt;-using std::auto_ptr;&lt;br/&gt;
+using boost::movelib::unique_ptr;&lt;br/&gt;
 using std::string;&lt;br/&gt;
 using std::vector;&lt;br/&gt;
 using std::map;&lt;br/&gt;
@@ -61,7 +61,7 @@ template &amp;lt;&amp;gt; struct codec_traits&amp;lt;C&amp;gt; {&lt;br/&gt;
 namespace specific {&lt;/p&gt;

&lt;p&gt; class Test {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;auto_ptr&amp;lt;OutputStream&amp;gt; os;&lt;br/&gt;
+    unique_ptr&amp;lt;OutputStream&amp;gt; os;&lt;br/&gt;
     EncoderPtr e;&lt;br/&gt;
     DecoderPtr d;&lt;br/&gt;
 public:&lt;br/&gt;
@@ -75,7 +75,7 @@ class Test {&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     template &amp;lt;typename T&amp;gt; void decode(T&amp;amp; t) &lt;/p&gt;
{
-        auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
+        unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
         d-&amp;gt;init(*is);
         avro::decode(*d, t);
     }
&lt;p&gt;diff --git a/lang/c+&lt;ins&gt;/test/StreamTests.cc b/lang/c&lt;/ins&gt;+/test/StreamTests.cc&lt;br/&gt;
index 2504207eb..7c2327928 100644&lt;br/&gt;
&amp;#8212; a/lang/c++/test/StreamTests.cc&lt;br/&gt;
+++ b/lang/c++/test/StreamTests.cc&lt;br/&gt;
@@ -105,18 +105,18 @@ struct Verify2 {&lt;/p&gt;

&lt;p&gt; template &amp;lt;typename V&amp;gt;&lt;br/&gt;
 void testEmpty_memoryStream() &lt;/p&gt;
{
-    std::auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();
-    std::auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
+    boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream();
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
     V()(*is);
 }

&lt;p&gt; template &amp;lt;typename F, typename V&amp;gt;&lt;br/&gt;
 void testNonEmpty_memoryStream(const TestData&amp;amp; td)&lt;/p&gt;
 {
-    std::auto_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream(td.chunkSize);
+    boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; os = memoryOutputStream(td.chunkSize);
     F()(*os, td.dataSize);
 
-    std::auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(*os);
     V()(*is, td.dataSize);
 }

&lt;p&gt;@@ -127,7 +127,7 @@ void testNonEmpty2(const TestData&amp;amp; td) {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     uint8_t v2 = 0;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(v.empty() ? &amp;amp;v2 : &amp;amp;v&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, v.size());&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; is = memoryInputStream(v.empty() ? &amp;amp;v2 : &amp;amp;v&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, v.size());&lt;br/&gt;
     Verify1()(*is, td.dataSize);&lt;br/&gt;
 }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -143,9 +143,9 @@ template &amp;lt;typename V&amp;gt;&lt;br/&gt;
 void testEmpty_fileStream() {&lt;br/&gt;
     FileRemover fr(filename);&lt;/p&gt;
     {
-        std::auto_ptr&amp;lt;OutputStream&amp;gt; os = fileOutputStream(filename);
+        boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; os = fileOutputStream(filename);
     }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; is = fileInputStream(filename);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; is = fileInputStream(filename);&lt;br/&gt;
     V()(*is);&lt;br/&gt;
 }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -154,12 +154,12 @@ void testNonEmpty_fileStream(const TestData&amp;amp; td)&lt;br/&gt;
 {&lt;br/&gt;
     FileRemover fr(filename);&lt;/p&gt;
     {
-        std::auto_ptr&amp;lt;OutputStream&amp;gt; os = fileOutputStream(filename,
+        boost::movelib::unique_ptr&amp;lt;OutputStream&amp;gt; os = fileOutputStream(filename,
             td.chunkSize);
         F()(*os, td.dataSize);
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;std::auto_ptr&amp;lt;InputStream&amp;gt; is = fileInputStream(filename, td.chunkSize);&lt;br/&gt;
+    boost::movelib::unique_ptr&amp;lt;InputStream&amp;gt; is = fileInputStream(filename, td.chunkSize);&lt;br/&gt;
     V()(*is, td.dataSize);&lt;br/&gt;
 }&lt;/li&gt;
&lt;/ul&gt;






&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 15 Nov 2016 16:27:00 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405022</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1xpcv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405058</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>


<item>
            <title>[AVRO-1543] libboost_zlib library is not detected but is required</title>
                <link>https://issues.apache.org/jira/browse/AVRO-1543</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;Standard builds of Boost with the iostreams library and zlib support build two separate libraries, libboost_iostreams and libboost_zlib. Avro is properly setup to detect and link in the former but not the later, meaning that Avro cannot be build out of the box without customizing either the Boost build or Avro&apos;s CMakeLists.txt.&lt;/p&gt;

&lt;p&gt;Another alternative change may be to remove Avro&apos;s hard requirement on zlib support in Boost&apos;s iostreams library, especially as stand-alone Boost builds will not include zlib support. Avro could either require its own flag for zlib support (being explicit is good, so this would be good) or detect if Boost was compiled with zlib support during CMake generation time. If Avro does not do either of these, it needs to be updated to link in libboost_zlib.&lt;/p&gt;</description>
                <environment>&lt;p&gt;Windows?&lt;/p&gt;</environment>
        <key id="12726916">AVRO-1543</key>
            <summary>libboost_zlib library is not detected but is required</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="thiru_mg">Thiruvalluvan M. G.</assignee>
                                    <reporter username="wgs_smiddleditch">Sean Middleditch</reporter>
                        <labels>
                    </labels>
                <created>Sat, 12 Jul 2014 01:07:24 +0000</created>
                <updated>Thu, 17 Jan 2019 02:22:49 +0000</updated>
                                            <version>1.7.6</version>
                                    <fixVersion>1.9.0</fixVersion>
                                    <component>c++</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="16732104" author="thiru_mg" created="Wed, 2 Jan 2019 14:37:15 +0000"  >&lt;p&gt;It appears to be a windows-only issue. We are able to build on Linux and Macos without any trouble. In fact there is no specific zlib component for boost in order to include in &lt;tt&gt;find_package&lt;/tt&gt;. Can someone with Windows confirm this?&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 2 Jan 2019 14:37:15 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405023</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1xpd3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405059</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>


<item>
            <title>[AVRO-1544] Union of enum and null can result in NPE on validate if null is not first</title>
                <link>https://issues.apache.org/jira/browse/AVRO-1544</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;The ENUM case in validate is missing a null check for datum:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; ENUM:
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; schema.getEnumSymbols().contains(datum.toString());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This leads to a surprising error where a NPE is thrown for a union of enum and null when the enum is first in the union.  If null is first it works.  The fix is a simple.  I&apos;m creating a patch that adds the fix and a unit test for this case.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12726947">AVRO-1544</key>
            <summary>Union of enum and null can result in NPE on validate if null is not first</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="matterhayes">Matthew Hayes</assignee>
                                    <reporter username="matterhayes">Matthew Hayes</reporter>
                        <labels>
                    </labels>
                <created>Sat, 12 Jul 2014 15:47:44 +0000</created>
                <updated>Mon, 1 Feb 2016 14:55:54 +0000</updated>
                            <resolved>Mon, 4 Aug 2014 20:09:31 +0000</resolved>
                                    <version>1.7.6</version>
                                    <fixVersion>1.7.8</fixVersion>
                    <fixVersion>1.8.0</fixVersion>
                                    <component>java</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                <comments>
                            <comment id="14059832" author="matterhayes" created="Sat, 12 Jul 2014 15:56:02 +0000"  >&lt;p&gt;Attaching patch with null check and unit test exposing the issue.&lt;/p&gt;

&lt;p&gt;Testing done: &quot;mvn test&quot;&lt;/p&gt;

&lt;p&gt;To run the single test: &quot;mvn -Dtest=TestGenericData#testValidateNullableEnum test&quot;&lt;/p&gt;

&lt;p&gt;Note that this is somewhat related to &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-997&quot; title=&quot;Generic API should require GenericEnumSymbol when writing Avro Enums&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-997&quot;&gt;&lt;del&gt;AVRO-997&lt;/del&gt;&lt;/a&gt;.  I see that the latest patch there includes this change:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;     &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; ENUM:
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isEnum(datum)) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
       &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; schema.getEnumSymbols().contains(datum.toString());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I believe this change would probably address this issue as well.  However, I think this particular change may not be backwards compatible.  Currently you can pass in strings as I do in the unit test to validate and it works.&lt;/p&gt;</comment>
                            <comment id="14059982" author="busbey" created="Sun, 13 Jul 2014 03:18:37 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-997&quot; title=&quot;Generic API should require GenericEnumSymbol when writing Avro Enums&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-997&quot;&gt;&lt;del&gt;AVRO-997&lt;/del&gt;&lt;/a&gt; is def not backwards compatible. It&apos;s waiting for 1.8.0. Once this goes in, I&apos;ll rebase it onto the current trunk so it can happily keep waiting.&lt;/p&gt;

&lt;p&gt;A few points of feedback:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;TestGenericData has several lines with trailing whitespace, could you clean those up?&lt;/li&gt;
	&lt;li&gt;Could you change the test to use GenericData.EnumSymbol instead of String? (that way the tests won&apos;t have to change when 1.8.0 changes to strict enforcement of use of GenericData.EnumSymbol.)&lt;/li&gt;
	&lt;li&gt;How about changing the check to be consistent with the fail-first style elsewhere in GenericData? e.g.
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;+ &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (datum == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; schema.getEnumSymbols().contains(datum.toString());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14060181" author="matterhayes" created="Sun, 13 Jul 2014 17:31:55 +0000"  >&lt;p&gt;Thanks for taking a look.  Attaching v2 of patch, addressing all three issues raised.&lt;/p&gt;</comment>
                            <comment id="14060737" author="busbey" created="Mon, 14 Jul 2014 15:10:28 +0000"  >&lt;p&gt;+1 LGTM. Ran through without fix and test failed, after fix test passed.&lt;/p&gt;</comment>
                            <comment id="14081395" author="matterhayes" created="Thu, 31 Jul 2014 20:18:15 +0000"  >&lt;p&gt;Any objections to applying the patch?&lt;/p&gt;</comment>
                            <comment id="14083313" author="busbey" created="Sat, 2 Aug 2014 03:11:53 +0000"  >&lt;p&gt;I think the patch is ready to apply, but am sadly not a committer.&lt;/p&gt;</comment>
                            <comment id="14085206" author="jira-bot" created="Mon, 4 Aug 2014 20:09:01 +0000"  >&lt;p&gt;Commit 1615764 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cutting&quot; class=&quot;user-hover&quot; rel=&quot;cutting&quot;&gt;Doug Cutting&lt;/a&gt; in branch &apos;avro/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1615764&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1615764&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1544&quot; title=&quot;Union of enum and null can result in NPE on validate if null is not first&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1544&quot;&gt;&lt;del&gt;AVRO-1544&lt;/del&gt;&lt;/a&gt;. Java: Fix GenericData#validate for unions with null.  Contributed by Matthew Hayes.&lt;/p&gt;</comment>
                            <comment id="14085207" author="cutting" created="Mon, 4 Aug 2014 20:09:31 +0000"  >&lt;p&gt;I committed this.  Thanks Matthew!&lt;/p&gt;</comment>
                            <comment id="14085213" author="matterhayes" created="Mon, 4 Aug 2014 20:14:36 +0000"  >&lt;p&gt;Awesome thanks! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="14085478" author="hudson" created="Mon, 4 Aug 2014 23:18:14 +0000"  >&lt;p&gt;SUCCESS: Integrated in AvroJava #471 (See &lt;a href=&quot;https://builds.apache.org/job/AvroJava/471/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/AvroJava/471/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1544&quot; title=&quot;Union of enum and null can result in NPE on validate if null is not first&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1544&quot;&gt;&lt;del&gt;AVRO-1544&lt;/del&gt;&lt;/a&gt;. Java: Fix GenericData#validate for unions with null.  Contributed by Matthew Hayes. (cutting: rev 1615764)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/avro/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/avro/trunk/lang/java/avro/src/main/java/org/apache/avro/generic/GenericData.java&lt;/li&gt;
	&lt;li&gt;/avro/trunk/lang/java/avro/src/test/java/org/apache/avro/generic/TestGenericData.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                    <attachments>
                            <attachment id="12655463" name="AVRO-1544-v2.patch" size="2431" author="matterhayes" created="Sun, 13 Jul 2014 17:31:55 +0000"/>
                            <attachment id="12655405" name="AVRO-1544.patch" size="2300" author="matterhayes" created="Sat, 12 Jul 2014 15:56:02 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 13 Jul 2014 03:18:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405054</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 24 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1xpjj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405090</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>


<item>
            <title>[AVRO-1545] python bindings for avro discard customized type information for primitive types</title>
                <link>https://issues.apache.org/jira/browse/AVRO-1545</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;Given the following avsc file:&lt;/p&gt;

&lt;p&gt;{&lt;br/&gt;
  &quot;type&quot; : &quot;record&quot;,&lt;br/&gt;
  &quot;name&quot; : &quot;BrokenRecord&quot;,&lt;br/&gt;
  &quot;namespace&quot; : &quot;whatever&quot;,&lt;br/&gt;
  &quot;fields&quot; : [ {&lt;br/&gt;
    &quot;name&quot; : &quot;a_string&quot;,&lt;br/&gt;
    &quot;type&quot; : &lt;/p&gt;
{
      &quot;type&quot; : &quot;string&quot;,
      &quot;avro.java.string&quot; : &quot;String&quot;
    }
&lt;p&gt;  } ]&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;The python schema parser discards the avro.java.string marker, which breaks interoperability with java. In schema.py, it discards the other property information and compresses the type down to just a &apos;string&apos;.&lt;/p&gt;

&lt;p&gt;Patch attached against the 1.7.6 release. &lt;/p&gt;</description>
                <environment></environment>
        <key id="12727362">AVRO-1545</key>
            <summary>python bindings for avro discard customized type information for primitive types</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="virtuald">Dustin Spicuzza</assignee>
                                    <reporter username="virtuald">Dustin Spicuzza</reporter>
                        <labels>
                    </labels>
                <created>Tue, 15 Jul 2014 16:07:02 +0000</created>
                <updated>Mon, 1 Feb 2016 14:56:01 +0000</updated>
                            <resolved>Wed, 17 Dec 2014 23:08:08 +0000</resolved>
                                    <version>1.7.6</version>
                                    <fixVersion>1.8.0</fixVersion>
                                    <component>python</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="14062249" author="virtuald" created="Tue, 15 Jul 2014 16:16:58 +0000"  >&lt;p&gt;Patch for issue. &lt;/p&gt;</comment>
                            <comment id="14111446" author="virtuald" created="Tue, 26 Aug 2014 22:16:23 +0000"  >&lt;p&gt;This seems like a pretty reasonable patch, has anyone looked at it yet?&lt;/p&gt;</comment>
                            <comment id="14145290" author="virtuald" created="Tue, 23 Sep 2014 19:25:39 +0000"  >&lt;p&gt;Attached a better patch w/tests. &lt;/p&gt;</comment>
                            <comment id="14145293" author="virtuald" created="Tue, 23 Sep 2014 19:27:24 +0000"  >&lt;p&gt;Also fixes &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1378&quot; title=&quot;Python: custom properties not retained on primitive schemas&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1378&quot;&gt;AVRO-1378&lt;/a&gt;. &lt;/p&gt;</comment>
                            <comment id="14218586" author="virtuald" created="Wed, 19 Nov 2014 22:13:00 +0000"  >&lt;p&gt;It would be nice if this got merged.&lt;/p&gt;</comment>
                            <comment id="14248636" author="cutting" created="Tue, 16 Dec 2014 18:36:37 +0000"  >&lt;p&gt;This looks reasonable to me, but I&apos;m not a Python expert.  Can someone more familiar with Python please review it?  If no one reviews it soon, I&apos;m inclined to commit it.&lt;/p&gt;</comment>
                            <comment id="14248789" author="rdblue" created="Tue, 16 Dec 2014 19:46:30 +0000"  >&lt;p&gt;+1 (non-binding)&lt;/p&gt;

&lt;p&gt;This looks fine to me. I think all of the places where PrimitiveSchema is instantiated are correct and the tests pass.&lt;/p&gt;</comment>
                            <comment id="14250763" author="jira-bot" created="Wed, 17 Dec 2014 23:07:02 +0000"  >&lt;p&gt;Commit 1646362 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cutting&quot; class=&quot;user-hover&quot; rel=&quot;cutting&quot;&gt;Doug Cutting&lt;/a&gt; in branch &apos;avro/trunk&apos;&lt;br/&gt;
[ &lt;a href=&quot;https://svn.apache.org/r1646362&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://svn.apache.org/r1646362&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1545&quot; title=&quot;python bindings for avro discard customized type information for primitive types&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1545&quot;&gt;&lt;del&gt;AVRO-1545&lt;/del&gt;&lt;/a&gt;. Python. Fix to retain schema properties on primitive types.  Contributed by Dustin Spicuzza.&lt;/p&gt;</comment>
                            <comment id="14250765" author="cutting" created="Wed, 17 Dec 2014 23:08:09 +0000"  >&lt;p&gt;I committed this.  Thanks, Dustin for fixing this and thanks Ryan for the review.&lt;/p&gt;</comment>
                            <comment id="14250815" author="hudson" created="Wed, 17 Dec 2014 23:35:56 +0000"  >&lt;p&gt;SUCCESS: Integrated in AvroJava #506 (See &lt;a href=&quot;https://builds.apache.org/job/AvroJava/506/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://builds.apache.org/job/AvroJava/506/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-1545&quot; title=&quot;python bindings for avro discard customized type information for primitive types&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-1545&quot;&gt;&lt;del&gt;AVRO-1545&lt;/del&gt;&lt;/a&gt;. Python. Fix to retain schema properties on primitive types.  Contributed by Dustin Spicuzza. (cutting: rev 1646362)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;/avro/trunk/CHANGES.txt&lt;/li&gt;
	&lt;li&gt;/avro/trunk/lang/py/src/avro/schema.py&lt;/li&gt;
	&lt;li&gt;/avro/trunk/lang/py/test/test_schema.py&lt;/li&gt;
	&lt;li&gt;/avro/trunk/lang/py3/avro/schema.py&lt;/li&gt;
	&lt;li&gt;/avro/trunk/lang/py3/avro/tests/test_schema.py&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                    <attachments>
                            <attachment id="12670784" name="types.diff" size="2971" author="virtuald" created="Tue, 23 Sep 2014 19:25:39 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 16 Dec 2014 18:36:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405468</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 5 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1xrzr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>405493</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>
