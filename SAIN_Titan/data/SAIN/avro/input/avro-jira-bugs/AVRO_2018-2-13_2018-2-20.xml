<!--
RSS generated by JIRA (7.6.3#76005-sha1:8a4e38d34af948780dbf52044e7aafb13a7cae58) at Mon Jan 21 19:26:11 UTC 2019

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<!-- If you wish to do custom client-side styling of RSS, uncomment this:
<?xml-stylesheet href="https://issues.apache.org/jira/styles/jiraxml2html.xsl" type="text/xsl"?>
-->
<rss version="0.92">
    <channel>
        <title>ASF JIRA</title>
        <link>https://issues.apache.org/jira/issues/?jql=project+%3D+AVRO+AND+created+%3E%3D+2018-2-13+AND+created+%3C%3D+2018-2-20+ORDER+BY+key+ASC</link>
        <description>An XML representation of a search request</description>
                <language>en-uk</language>
                        <issue start="0" end="4" total="4"/>
                <build-info>
            <version>7.6.3</version>
            <build-number>76005</build-number>
            <build-date>09-01-2018</build-date>
        </build-info>

<item>
            <title>[AVRO-2144] 404 - Not found - Invalid Url for CSharp documentation</title>
                <link>https://issues.apache.org/jira/browse/AVRO-2144</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;Invalid Url for C# Api documentation&lt;/p&gt;

&lt;p&gt;Selecting the below link&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://avro.apache.org/docs/current/api/csharp/index.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;C# API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;leads to 404. Below is the current result:&lt;/p&gt;
&lt;h1&gt;&lt;a name=&quot;NotFound&quot;&gt;&lt;/a&gt;Not Found&lt;/h1&gt;

&lt;p&gt;The requested URL /docs/current/api/csharp/index.html was not found on this server.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13138206">AVRO-2144</key>
            <summary>404 - Not found - Invalid Url for CSharp documentation</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Minor</priority>
                        <status id="4" iconUrl="https://issues.apache.org/jira/images/icons/statuses/reopened.png" description="This issue was once resolved, but the resolution was deemed incorrect. From here issues are either marked assigned or resolved.">Reopened</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="vishelma">Selva Chinnasamy</assignee>
                                    <reporter username="vishelma">Selva Chinnasamy</reporter>
                        <labels>
                    </labels>
                <created>Tue, 13 Feb 2018 15:17:17 +0000</created>
                <updated>Wed, 5 Dec 2018 14:53:18 +0000</updated>
                                            <version>1.8.2</version>
                                                    <component>doc</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="16362548" author="nielsbasjes" created="Tue, 13 Feb 2018 15:59:20 +0000"  >&lt;p&gt;Where did you find this incorrect URL?&lt;/p&gt;</comment>
                            <comment id="16362572" author="nkollar" created="Tue, 13 Feb 2018 16:16:57 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=nielsbasjes&quot; class=&quot;user-hover&quot; rel=&quot;nielsbasjes&quot;&gt;Niels Basjes&lt;/a&gt; I think &lt;a href=&quot;https://avro.apache.org/docs/current/spec.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt;. If you click on C# API in the menu, then indeed the link is a 404.&lt;/p&gt;</comment>
                            <comment id="16362961" author="githubbot" created="Tue, 13 Feb 2018 19:57:42 +0000"  >&lt;p&gt;vishelma opened a new pull request #284: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2144&quot; title=&quot;404 - Not found - Invalid Url for CSharp documentation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2144&quot;&gt;AVRO-2144&lt;/a&gt;: Documentation Url fix for csharp spec&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/284&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/284&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   CSharp documentation currently points to &lt;a href=&quot;https://avro.apache.org/docs/current/api/csharp/index.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://avro.apache.org/docs/current/api/csharp/index.html&lt;/a&gt; where as it should be &lt;a href=&quot;https://avro.apache.org/docs/current/api/csharp/html/index.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://avro.apache.org/docs/current/api/csharp/html/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16367634" author="vishelma" created="Fri, 16 Feb 2018 17:38:25 +0000"  >&lt;p&gt;Updated the url to point to&#160;&lt;a href=&quot;https://avro.apache.org/docs/current/api/csharp/html/index.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://avro.apache.org/docs/current/api/csharp/html/index.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16371240" author="githubbot" created="Wed, 21 Feb 2018 11:07:37 +0000"  >&lt;p&gt;nielsbasjes commented on issue #284: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2144&quot; title=&quot;404 - Not found - Invalid Url for CSharp documentation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2144&quot;&gt;AVRO-2144&lt;/a&gt;: Documentation Url fix for csharp spec&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/284#issuecomment-367292472&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/284#issuecomment-367292472&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Few points about this:&lt;br/&gt;
    1. Please use a normal email address in the commits instead of &quot;vishelma &amp;lt;Cmrs58nh!&amp;gt;&quot;&lt;br/&gt;
    2. Why has the jira issue been set to &quot;Resolved&quot; ?? This problem is not resolved yet.&lt;br/&gt;
    3. Question to other committers: This problem is primarily confusing for visitors of the website. I&apos;m in doubt if we should fix this simple issue manually in the documentation of the currrent release or not. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16371426" author="nielsbasjes" created="Wed, 21 Feb 2018 13:53:52 +0000"  >&lt;p&gt;Reopening: At this point nothing has been committed yet.&lt;/p&gt;</comment>
                            <comment id="16372252" author="githubbot" created="Thu, 22 Feb 2018 00:30:38 +0000"  >&lt;p&gt;vishelma closed pull request #284: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2144&quot; title=&quot;404 - Not found - Invalid Url for CSharp documentation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2144&quot;&gt;AVRO-2144&lt;/a&gt;: Documentation Url fix for csharp spec&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/284&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/284&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/doc/src/content/xdocs/site.xml b/doc/src/content/xdocs/site.xml&lt;br/&gt;
index 30d0b4870..5aec50ca9 100644&lt;br/&gt;
&amp;#8212; a/doc/src/content/xdocs/site.xml&lt;br/&gt;
+++ b/doc/src/content/xdocs/site.xml&lt;br/&gt;
@@ -77,7 +77,7 @@ See &lt;a href=&quot;http://forrest.apache.org/docs/linking.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://forrest.apache.org/docs/linking.html&lt;/a&gt; for more info&lt;br/&gt;
 	&amp;lt;index href=&quot;html/index.html&quot; /&amp;gt;&lt;br/&gt;
       &amp;lt;/cpp&amp;gt;&lt;br/&gt;
       &amp;lt;csharp href=&quot;csharp/&quot;&amp;gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;index href=&quot;index.html&quot; /&amp;gt;&lt;br/&gt;
+	&amp;lt;index href=&quot;html/index.html&quot; /&amp;gt;&lt;br/&gt;
       &amp;lt;/csharp&amp;gt;&lt;br/&gt;
       &amp;lt;java href=&quot;java/&quot;&amp;gt;&lt;br/&gt;
 	&amp;lt;index href=&quot;index.html&quot; /&amp;gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16372267" author="githubbot" created="Thu, 22 Feb 2018 00:43:43 +0000"  >&lt;p&gt;vishelma opened a new pull request #286: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2144&quot; title=&quot;404 - Not found - Invalid Url for CSharp documentation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2144&quot;&gt;AVRO-2144&lt;/a&gt;: Fix for CSharp documentation Url&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/286&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/286&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Fixed Url for CSharp documentation.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16372271" author="vishelma" created="Thu, 22 Feb 2018 00:47:38 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=nielsbasjes&quot; class=&quot;user-hover&quot; rel=&quot;nielsbasjes&quot;&gt;Niels Basjes&lt;/a&gt;: Closed the previous pull request and opened a new one addressing above mentioned issues. Thanks.&lt;/p&gt;</comment>
                            <comment id="16710151" author="githubbot" created="Wed, 5 Dec 2018 14:53:14 +0000"  >&lt;p&gt;dkulp closed pull request #286: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2144&quot; title=&quot;404 - Not found - Invalid Url for CSharp documentation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2144&quot;&gt;AVRO-2144&lt;/a&gt;: Fix for CSharp documentation Url&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/286&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/286&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/doc/src/content/xdocs/site.xml b/doc/src/content/xdocs/site.xml&lt;br/&gt;
index 30d0b4870..5aec50ca9 100644&lt;br/&gt;
&amp;#8212; a/doc/src/content/xdocs/site.xml&lt;br/&gt;
+++ b/doc/src/content/xdocs/site.xml&lt;br/&gt;
@@ -77,7 +77,7 @@ See &lt;a href=&quot;http://forrest.apache.org/docs/linking.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://forrest.apache.org/docs/linking.html&lt;/a&gt; for more info&lt;br/&gt;
 	&amp;lt;index href=&quot;html/index.html&quot; /&amp;gt;&lt;br/&gt;
       &amp;lt;/cpp&amp;gt;&lt;br/&gt;
       &amp;lt;csharp href=&quot;csharp/&quot;&amp;gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;index href=&quot;index.html&quot; /&amp;gt;&lt;br/&gt;
+	&amp;lt;index href=&quot;html/index.html&quot; /&amp;gt;&lt;br/&gt;
       &amp;lt;/csharp&amp;gt;&lt;br/&gt;
       &amp;lt;java href=&quot;java/&quot;&amp;gt;&lt;br/&gt;
 	&amp;lt;index href=&quot;index.html&quot; /&amp;gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16710152" author="jira-bot" created="Wed, 5 Dec 2018 14:53:18 +0000"  >&lt;p&gt;Commit eaa7cca922b916ab7ad0fac6e109330197f8c75f in avro&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vishelma&quot; class=&quot;user-hover&quot; rel=&quot;vishelma&quot;&gt;Selva Chinnasamy&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=avro.git;h=eaa7cca&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://gitbox.apache.org/repos/asf?p=avro.git;h=eaa7cca&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2144&quot; title=&quot;404 - Not found - Invalid Url for CSharp documentation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2144&quot;&gt;AVRO-2144&lt;/a&gt;: Fix for CSharp documentation Url&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 13 Feb 2018 15:59:20 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3q4pb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>


<item>
            <title>[AVRO-2145] Can&apos;t generate Javadoc on master</title>
                <link>https://issues.apache.org/jira/browse/AVRO-2145</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;&lt;tt&gt;mvn javadoc:aggregate&lt;/tt&gt; fails with a bunch of Javadoc warnings on master&#160;when building with JDK8.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13138447">AVRO-2145</key>
            <summary>Can&apos;t generate Javadoc on master</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="nkollar">Nandor Kollar</reporter>
                        <labels>
                    </labels>
                <created>Wed, 14 Feb 2018 09:53:26 +0000</created>
                <updated>Sun, 30 Dec 2018 04:09:31 +0000</updated>
                                            <version>1.9.0</version>
                                                    <component>java</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="16628173" author="githubbot" created="Wed, 26 Sep 2018 02:26:00 +0000"  >&lt;p&gt;Fokko opened a new pull request #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   From Java 8 on the JavaDoc is being linted and it will fail early if there are issues with the JavaDoc: &lt;a href=&quot;http://openjdk.java.net/jeps/172&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://openjdk.java.net/jeps/172&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;   This patch will add the missing Javadoc with some stubs. Additionally I updated the docs of some of the public API by hand to make the Javadoc more verbose.&lt;/p&gt;

&lt;p&gt;   The JavaDoc needs to be updated in the future, but this commit will let the compiler pass the javadoc check step.&lt;/p&gt;

&lt;p&gt;   Tested locally and it passes the tests. This patch only changes the Javadoc and does not change the logic of the code.&lt;/p&gt;

&lt;p&gt;   Cheers, Fokko&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16637710" author="githubbot" created="Thu, 4 Oct 2018 01:57:46 +0000"  >&lt;p&gt;kojiromike commented on issue #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334#issuecomment-426860151&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334#issuecomment-426860151&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   @cutting I&apos;m happy to help review stuff when I can, but 157 files is a bit much for manual review. Can I help here by confirming I have run the tests locally?&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16637720" author="githubbot" created="Thu, 4 Oct 2018 02:08:46 +0000"  >&lt;p&gt;kojiromike commented on issue #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334#issuecomment-426861821&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334#issuecomment-426861821&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   I can confirm this passes all the java-related tests.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16640000" author="githubbot" created="Fri, 5 Oct 2018 16:03:09 +0000"  >&lt;p&gt;cutting commented on issue #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334#issuecomment-427416331&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334#issuecomment-427416331&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   I&apos;m not fond of whitespace changes.  Are all of these really required to pass JavaDoc lint?  In particular, a lot of existing Javadoc comments have content on the first line.  When these are moved to a new line it causes the rest of the comment to be re-indented.  I&apos;d prefer we don&apos;t make that style change here.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16640026" author="githubbot" created="Fri, 5 Oct 2018 16:15:47 +0000"  >&lt;p&gt;nandorKollar commented on issue #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334#issuecomment-427420122&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334#issuecomment-427420122&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   In this case I&apos;d recommend simply turning off DocLint. I remember we did similar things on Parquet, &lt;span class=&quot;error&quot;&gt;&amp;#91;here&amp;#39;s&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://github.com/apache/parquet-format/commit/28ead3fd157842247ac71c5ec1fac94f1ff83ec4&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/parquet-format/commit/28ead3fd157842247ac71c5ec1fac94f1ff83ec4&lt;/a&gt;) how it was turned off there.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16640036" author="githubbot" created="Fri, 5 Oct 2018 16:19:39 +0000"  >&lt;p&gt;Fokko commented on issue #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334#issuecomment-427421219&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334#issuecomment-427421219&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Currently it breaks the `dist` step. &lt;/p&gt;

&lt;p&gt;   Personally I would prefer to add the JavaDoc. But if the majority prefers to turn it off, I&apos;m fine with it as well. Beside the missing JavaDoc, I&apos;ve also corrected a lot of the invalid JavaDoc in this PR. &lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16640050" author="githubbot" created="Fri, 5 Oct 2018 16:27:37 +0000"  >&lt;p&gt;nandorKollar commented on issue #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334#issuecomment-427423523&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334#issuecomment-427423523&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   I think in some cases it would make sense to fix the Javadoc, but adding obvious comments only for DocLint doesn&apos;t give too much value. For example (at least in my opinion) we should keep changes like &lt;span class=&quot;error&quot;&gt;&amp;#91;this&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://github.com/apache/avro/pull/334/files#diff-8c641f2365208209cae8dd63a6d186f7L35&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334/files#diff-8c641f2365208209cae8dd63a6d186f7L35&lt;/a&gt;), but changes only related to the comment style like &lt;span class=&quot;error&quot;&gt;&amp;#91;this&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://github.com/apache/avro/pull/334/files#diff-6e7994042bf667704678c9395ace00bcL103&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334/files#diff-6e7994042bf667704678c9395ace00bcL103&lt;/a&gt;) don&apos;t give too much value.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16640052" author="githubbot" created="Fri, 5 Oct 2018 16:28:40 +0000"  >&lt;p&gt;nandorKollar edited a comment on issue #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334#issuecomment-427423523&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334#issuecomment-427423523&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   I think in some cases it would make sense to fix the Javadoc, but adding obvious comments only for DocLint doesn&apos;t give too much value. For example (at least in my opinion) we should keep changes like &lt;span class=&quot;error&quot;&gt;&amp;#91;this&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://github.com/apache/avro/pull/334/files#diff-8c641f2365208209cae8dd63a6d186f7R35&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334/files#diff-8c641f2365208209cae8dd63a6d186f7R35&lt;/a&gt;), but changes only related to the comment style like &lt;span class=&quot;error&quot;&gt;&amp;#91;this&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://github.com/apache/avro/pull/334/files#diff-6e7994042bf667704678c9395ace00bcL103&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334/files#diff-6e7994042bf667704678c9395ace00bcL103&lt;/a&gt;) don&apos;t give too much value.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16640538" author="githubbot" created="Sat, 6 Oct 2018 03:47:37 +0000"  >&lt;p&gt;Fokko commented on issue #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334#issuecomment-427543093&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334#issuecomment-427543093&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Ok, I&apos;ll create a new PR.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16640539" author="githubbot" created="Sat, 6 Oct 2018 03:47:39 +0000"  >&lt;p&gt;Fokko closed pull request #334: &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2145&quot; title=&quot;Can&amp;#39;t generate Javadoc on master&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2145&quot;&gt;AVRO-2145&lt;/a&gt; Cannot create Javadoc on JDK8+&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/avro/pull/334&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/apache/avro/pull/334&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/service/SimpleOrderService.java b/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/service/SimpleOrderService.java&lt;br/&gt;
index e9a103ad0..8a3b4f8f6 100644&lt;br/&gt;
&amp;#8212; a/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/service/SimpleOrderService.java&lt;br/&gt;
+++ b/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/service/SimpleOrderService.java&lt;br/&gt;
@@ -33,6 +33,14 @@&lt;/p&gt;

&lt;p&gt;   private Logger log = LoggerFactory.getLogger(SimpleOrderService.class);&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Submit order confirmation.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param order the order&lt;br/&gt;
+   * @return the confirmation&lt;br/&gt;
+   * @throws AvroRemoteException the avro remote exception&lt;br/&gt;
+   * @throws OrderFailure        the order failure&lt;br/&gt;
+   */&lt;br/&gt;
   @Override&lt;br/&gt;
   public Confirmation submitOrder(Order order) throws AvroRemoteException, OrderFailure {&lt;br/&gt;
     log.info(&quot;Received order for &apos;{}&apos; items from customer with id &apos;{}&apos;&quot;,&lt;br/&gt;
diff --git a/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/transport/SimpleOrderServiceClient.java b/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/transport/SimpleOrderServiceClient.java&lt;br/&gt;
index dce4982da..d30dbcb0e 100644&lt;br/&gt;
&amp;#8212; a/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/transport/SimpleOrderServiceClient.java&lt;br/&gt;
+++ b/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/transport/SimpleOrderServiceClient.java&lt;br/&gt;
@@ -50,10 +50,20 @@&lt;/p&gt;

&lt;p&gt;   private OrderProcessingService service;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Simple order service client.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param endpointAddress the endpoint address&lt;br/&gt;
+   */&lt;br/&gt;
   public SimpleOrderServiceClient(InetSocketAddress endpointAddress) &lt;/p&gt;
{
     this.endpointAddress = endpointAddress;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Start.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public synchronized void start() throws IOException {&lt;br/&gt;
     if (log.isInfoEnabled()) {&lt;br/&gt;
       log.info(&quot;Starting Simple Ordering Netty client on &apos;{}&apos;&quot;, endpointAddress);&lt;br/&gt;
@@ -62,6 +72,11 @@ public synchronized void start() throws IOException {
     service = SpecificRequestor.getClient(OrderProcessingService.class, transceiver);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Stop.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public void stop() throws IOException {&lt;br/&gt;
     if (log.isInfoEnabled()) {&lt;br/&gt;
       log.info(&quot;Stopping Simple Ordering Netty client on &apos;{}&apos;&quot;, endpointAddress);&lt;br/&gt;
@@ -71,6 +86,14 @@ public void stop() throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Submit order confirmation.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param order the order&lt;br/&gt;
+   * @return the confirmation&lt;br/&gt;
+   * @throws AvroRemoteException the avro remote exception&lt;br/&gt;
+   * @throws OrderFailure        the order failure&lt;br/&gt;
+   */&lt;br/&gt;
   @Override&lt;br/&gt;
   public Confirmation submitOrder(Order order) throws AvroRemoteException, OrderFailure {&lt;br/&gt;
     return service.submitOrder(order);&lt;br/&gt;
diff --git a/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/transport/SimpleOrderServiceEndpoint.java b/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/transport/SimpleOrderServiceEndpoint.java&lt;br/&gt;
index f768e048c..231ee8c77 100644&lt;br/&gt;
&amp;#8212; a/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/transport/SimpleOrderServiceEndpoint.java&lt;br/&gt;
+++ b/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/main/java/transport/SimpleOrderServiceEndpoint.java&lt;br/&gt;
@@ -44,10 +44,20 @@&lt;br/&gt;
 &lt;br/&gt;
   private Server service;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Simple order service endpoint.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param endpointAddress the endpoint address&lt;br/&gt;
+   */&lt;br/&gt;
   public SimpleOrderServiceEndpoint(InetSocketAddress endpointAddress) {     this.endpointAddress = endpointAddress;   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Start.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public synchronized void start() throws Exception {&lt;br/&gt;
     if (log.isInfoEnabled()) {&lt;br/&gt;
       log.info(&quot;Starting Simple Ordering Netty Server on &apos;{}&apos;&quot;, endpointAddress);&lt;br/&gt;
@@ -58,6 +68,11 @@ public synchronized void start() throws Exception &lt;/p&gt;
{
     service.start();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Stop.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public synchronized void stop() throws Exception {&lt;br/&gt;
     if (log.isInfoEnabled()) {&lt;br/&gt;
       log.info(&quot;Stopping Simple Ordering Server on &apos;{}&apos;&quot;, endpointAddress);&lt;br/&gt;
diff --git a/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/test/java/integration/SimpleOrderServiceIntegrationTest.java b/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/test/java/integration/SimpleOrderServiceIntegrationTest.java&lt;br/&gt;
index cf5e3c16f..a649c6c79 100644&lt;br/&gt;
&amp;#8212; a/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/test/java/integration/SimpleOrderServiceIntegrationTest.java&lt;br/&gt;
+++ b/lang/java/archetypes/avro-service-archetype/src/main/resources/archetype-resources/src/test/java/integration/SimpleOrderServiceIntegrationTest.java&lt;br/&gt;
@@ -47,6 +47,11 @@&lt;br/&gt;
   private static SimpleOrderServiceEndpoint service;&lt;br/&gt;
   private static SimpleOrderServiceClient client;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Simple round trip test.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void simpleRoundTripTest() throws Exception {&lt;br/&gt;
     Order simpleOrder = createOrder();&lt;br/&gt;
@@ -57,6 +62,11 @@ public void simpleRoundTripTest() throws Exception &lt;/p&gt;
{
     assertTrue(c.getEstimatedCompletion() &amp;gt; 0);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Sets transport.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @BeforeClass&lt;br/&gt;
   public static void setupTransport() throws Exception {&lt;br/&gt;
     InetSocketAddress endpointAddress = new InetSocketAddress(&quot;0.0.0.0&quot;, 12345);&lt;br/&gt;
@@ -67,16 +77,31 @@ public static void setupTransport() throws Exception &lt;/p&gt;
{
     client.start();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Shutdown transport.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void shutdownTransport() throws Exception &lt;/p&gt;
{
     client.stop();
     service.stop();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Create order order.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the order&lt;br/&gt;
+   */&lt;br/&gt;
   public Order createOrder() &lt;/p&gt;
{
     return Order.newBuilder().setOrderId(1).setCustomerId(1).setOrderItems(createItems()).build();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Create items list.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the list&lt;br/&gt;
+   */&lt;br/&gt;
   public List&amp;lt;Item&amp;gt; createItems() {&lt;br/&gt;
     List&amp;lt;Item&amp;gt; items = new ArrayList&amp;lt;Item&amp;gt;();&lt;br/&gt;
     for (int x = 0; x &amp;lt; 5; x++)&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/Conversions.java b/lang/java/avro/src/main/java/org/apache/avro/Conversions.java&lt;br/&gt;
index 0456580e8..b5c278527 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/Conversions.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/Conversions.java&lt;br/&gt;
@@ -176,6 +176,7 @@ public static Object convertToLogicalType(Object datum, Schema schema, LogicalTy&lt;br/&gt;
   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Convert a high level representation of a logical type (such as a BigDecimal)&lt;/li&gt;
	&lt;li&gt;to the its underlying representation object (such as a ByteBuffer)&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; The return type&lt;/li&gt;
	&lt;li&gt;@param datum The object to be converted.&lt;/li&gt;
	&lt;li&gt;@param schema The schema of datum. Cannot be null if datum is not null.&lt;/li&gt;
	&lt;li&gt;@param type The 
{@link org.apache.avro.LogicalType}
&lt;p&gt; of datum. Cannot&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/JsonProperties.java b/lang/java/avro/src/main/java/org/apache/avro/JsonProperties.java&lt;br/&gt;
index 1592950a5..28eafb3b7 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/JsonProperties.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/JsonProperties.java&lt;br/&gt;
@@ -32,12 +32,12 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Base class for objects that have JSON-valued properties. Avro and JSON values are&lt;/li&gt;
	&lt;li&gt;represented in Java using the following mapping:&lt;br/&gt;
  *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;table&amp;gt;&lt;/li&gt;
	&lt;li&gt;*   &amp;lt;th&amp;gt;&lt;/li&gt;
	&lt;li&gt;*     &amp;lt;td&amp;gt;Avro type&amp;lt;/td&amp;gt;&lt;/li&gt;
	&lt;li&gt;*     &amp;lt;td&amp;gt;JSON type&amp;lt;/td&amp;gt;&lt;/li&gt;
	&lt;li&gt;*     &amp;lt;td&amp;gt;Java type&amp;lt;/td&amp;gt;&lt;/li&gt;
	&lt;li&gt;*   &amp;lt;/th&amp;gt;&lt;br/&gt;
+ * &amp;lt;table summary=&quot;An overview of the different types in Avro, JSON and Java&quot;&amp;gt;&lt;br/&gt;
+ *   &amp;lt;tr&amp;gt;&lt;br/&gt;
+ *     &amp;lt;th&amp;gt;Avro type&amp;lt;/th&amp;gt;&lt;br/&gt;
+ *     &amp;lt;th&amp;gt;JSON type&amp;lt;/th&amp;gt;&lt;br/&gt;
+ *     &amp;lt;th&amp;gt;Java type&amp;lt;/th&amp;gt;&lt;br/&gt;
+ *   &amp;lt;/tr&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;tr&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;td&amp;gt;&amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;td&amp;gt;&amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;&amp;lt;/td&amp;gt;&lt;br/&gt;
@@ -125,6 +125,9 @@ private Null() {}&lt;br/&gt;
   /**&lt;/li&gt;
	&lt;li&gt;Returns the value of the named, string-valued property in this schema.&lt;/li&gt;
	&lt;li&gt;Returns &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; if there is no string-valued property with that name.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The property name&lt;br/&gt;
+   * @return The property if exists, otherwise null&lt;br/&gt;
    */&lt;br/&gt;
   public String getProp(String name) {&lt;br/&gt;
     JsonNode value = getJsonProp(name);&lt;br/&gt;
@@ -134,6 +137,10 @@ public String getProp(String name) {&lt;br/&gt;
   /**&lt;/li&gt;
	&lt;li&gt;Returns the value of the named property in this schema.&lt;/li&gt;
	&lt;li&gt;Returns &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; if there is no property with that name.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The property name&lt;br/&gt;
+   * @return The JsonNode if exists, otherwise null&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@deprecated use 
{@link #getObjectProp(String)}
&lt;p&gt;    */&lt;br/&gt;
   @Deprecated&lt;br/&gt;
@@ -144,6 +151,9 @@ public synchronized JsonNode getJsonProp(String name) {&lt;br/&gt;
   /**&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Returns the value of the named property in this schema.&lt;/li&gt;
	&lt;li&gt;Returns &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; if there is no property with that name.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The property name&lt;br/&gt;
+   * @return The object if exists, otherwise null&lt;br/&gt;
    */&lt;br/&gt;
   public synchronized Object getObjectProp(String name) {&lt;br/&gt;
     return JacksonUtils.toObject(props.get(name));&lt;br/&gt;
@@ -191,7 +201,9 @@ public synchronized void addProp(String name, Object value) 
{
     addProp(name, JacksonUtils.toJsonNode(value));
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return the defined properties that have string values. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return Return the defined properties that have string values.&lt;br/&gt;
+   */&lt;br/&gt;
   @Deprecated public Map&amp;lt;String,String&amp;gt; getProps() {&lt;br/&gt;
     Map&amp;lt;String,String&amp;gt; result = new LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     for (Map.Entry&amp;lt;String,JsonNode&amp;gt; e : props.entrySet())&lt;br/&gt;
@@ -200,24 +212,18 @@ public synchronized void addProp(String name, Object value) 
{
     return result;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Convert a map of string-valued properties to Json properties. */&lt;br/&gt;
-  Map&amp;lt;String,JsonNode&amp;gt; jsonProps(Map&amp;lt;String,String&amp;gt; stringProps) {
-    Map&amp;lt;String,JsonNode&amp;gt; result = new LinkedHashMap&amp;lt;&amp;gt;();
-    for (Map.Entry&amp;lt;String,String&amp;gt; e : stringProps.entrySet())
-      result.put(e.getKey(), TextNode.valueOf(e.getValue()));
-    return result;
-  }&lt;br/&gt;
-&lt;br/&gt;
   /**&lt;br/&gt;
-   * Return the defined properties as an unmodifiable Map.&lt;br/&gt;
    * @deprecated use {@link #getObjectProps()}&lt;br/&gt;
+   * @return The defined properties as an unmodifiable Map.&lt;br/&gt;
    */&lt;br/&gt;
   @Deprecated&lt;br/&gt;
   public Map&amp;lt;String,JsonNode&amp;gt; getJsonProps() {
     return Collections.unmodifiableMap(props);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Return the defined properties as an unmodifiable Map. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return The defined properties as an unmodifiable Map.&lt;br/&gt;
+   */&lt;br/&gt;
   public Map&amp;lt;String,Object&amp;gt; getObjectProps() {
     Map&amp;lt;String,Object&amp;gt; result = new LinkedHashMap&amp;lt;&amp;gt;();
     for (Map.Entry&amp;lt;String,JsonNode&amp;gt; e : props.entrySet())
diff --git a/lang/java/avro/src/main/java/org/apache/avro/LogicalTypes.java b/lang/java/avro/src/main/java/org/apache/avro/LogicalTypes.java
index 57dc661be..c651ae72f 100644
--- a/lang/java/avro/src/main/java/org/apache/avro/LogicalTypes.java
+++ b/lang/java/avro/src/main/java/org/apache/avro/LogicalTypes.java
@@ -46,12 +46,17 @@ public static void register(String logicalTypeName, LogicalTypeFactory factory)
   }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
-   * Returns the {@link LogicalType} from the schema, if one is present.&lt;br/&gt;
+   * @param schema The schema&lt;br/&gt;
+   * @return The {@link LogicalType} from the schema, if one is present.&lt;br/&gt;
    */&lt;br/&gt;
   public static LogicalType fromSchema(Schema schema) {
     return fromSchemaImpl(schema, true);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param schema The schema&lt;br/&gt;
+   * @return The {@link LogicalType} from the schema, if one is present.&lt;br/&gt;
+   */&lt;br/&gt;
   public static LogicalType fromSchemaIgnoreInvalid(Schema schema) {
     return fromSchemaImpl(schema, false);
   }&lt;br/&gt;
@@ -108,12 +113,19 @@ private static LogicalType fromSchemaImpl(Schema schema, boolean throwErrors) {&lt;br/&gt;
   private static final String TIMESTAMP_MILLIS = &quot;timestamp-millis&quot;;&lt;br/&gt;
   private static final String TIMESTAMP_MICROS = &quot;timestamp-micros&quot;;&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a Decimal LogicalType with the given precision and scale 0 */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param precision The precision of the decimal&lt;br/&gt;
+   * @return Decimal LogicalType with the given precision and scale 0&lt;br/&gt;
+   */&lt;br/&gt;
   public static Decimal decimal(int precision) {
     return decimal(precision, 0);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a Decimal LogicalType with the given precision and scale */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param precision The precision of the decimal&lt;br/&gt;
+   * @param scale The scale of the param&lt;br/&gt;
+   * @return Decimal LogicalType with the given precision and scale&lt;br/&gt;
+   */&lt;br/&gt;
   public static Decimal decimal(int precision, int scale) {
     return new Decimal(precision, scale);
   }&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/Protocol.java b/lang/java/avro/src/main/java/org/apache/avro/Protocol.java&lt;br/&gt;
index 907362338..4b019b263 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/Protocol.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/Protocol.java&lt;br/&gt;
@@ -22,6 +22,7 @@&lt;br/&gt;
 import java.io.InputStream;&lt;br/&gt;
 import java.io.StringWriter;&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
+import java.nio.charset.StandardCharsets;&lt;br/&gt;
 import java.security.MessageDigest;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
 import java.util.Iterator;&lt;br/&gt;
@@ -100,20 +101,46 @@ private Message(String name, String doc,&lt;br/&gt;
         }&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** The name of this message. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The name of this message&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Name of the messages&lt;br/&gt;
+     */&lt;br/&gt;
     public String getName() { return name; }&lt;br/&gt;
-    /** The parameters of this message. */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The parameters of this message&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return The schema of the message&lt;br/&gt;
+     */&lt;br/&gt;
     public Schema getRequest() { return request; }&lt;br/&gt;
-    /** The returned data. */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The returned data&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return The schema of the response&lt;br/&gt;
+     */&lt;br/&gt;
     public Schema getResponse() { return Schema.create(Schema.Type.NULL); }&lt;br/&gt;
-    /** Errors that might be thrown. */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Errors that might be thrown&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return The schema of the errors&lt;br/&gt;
+     */&lt;br/&gt;
     public Schema getErrors() {
       return Schema.createUnion(new ArrayList&amp;lt;&amp;gt;());
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Returns true if this is a one-way message, with no response or errors.*/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns true if this is a one-way message, with no response or errors&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Boolean indicating if it is a one way messages&lt;br/&gt;
+     */&lt;br/&gt;
     public boolean isOneWay() { return true; }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return A JSON representation of the protocol&lt;br/&gt;
+     */&lt;br/&gt;
     public String toString() {&lt;br/&gt;
       try {&lt;br/&gt;
         StringWriter writer = new StringWriter();&lt;br/&gt;
@@ -125,6 +152,7 @@ public String toString() {
         throw new AvroRuntimeException(e);
       }&lt;br/&gt;
     }&lt;br/&gt;
+&lt;br/&gt;
     void toJson(JsonGenerator gen) throws IOException {&lt;br/&gt;
       gen.writeStartObject();&lt;br/&gt;
       if (doc != null) gen.writeStringField(&quot;doc&quot;, doc);&lt;br/&gt;
@@ -240,50 +268,100 @@ public Protocol(String name, String namespace) {
     this(name, null, namespace);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** The name of this protocol. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return Name of this protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public String getName() { return name; }&lt;br/&gt;
 &lt;br/&gt;
-  /** The namespace of this protocol.  Qualifies its name. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return Namespace of this protocol. Qualifies its name.&lt;br/&gt;
+   */&lt;br/&gt;
   public String getNamespace() { return namespace; }&lt;br/&gt;
 &lt;br/&gt;
-  /** Doc string for this protocol. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return Doc string for this protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public String getDoc() { return doc; }&lt;br/&gt;
 &lt;br/&gt;
-  /** The types of this protocol. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return The types of this protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public Collection&amp;lt;Schema&amp;gt; getTypes() { return types.values(); }&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns the named type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param name the name of the type&lt;br/&gt;
+   * @return The named type&lt;br/&gt;
+   */&lt;br/&gt;
   public Schema getType(String name) { return types.get(name); }&lt;br/&gt;
 &lt;br/&gt;
-  /** Set the types of this protocol. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Set the types of this protocol&lt;br/&gt;
+   * @param newTypes Types of this protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public void setTypes(Collection&amp;lt;Schema&amp;gt; newTypes) {
     types = new Schema.Names();
     for (Schema s : newTypes)
       types.add(s);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** The messages of this protocol. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return Messages of this protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public Map&amp;lt;String,Message&amp;gt; getMessages() { return messages; }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a one-way message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a one-way message.&lt;br/&gt;
+   * @param name Name of the message&lt;br/&gt;
+   * @param doc Docstring of the message&lt;br/&gt;
+   * @param request Schema of the message&lt;br/&gt;
+   * @return One-way message&lt;br/&gt;
+   */&lt;br/&gt;
   @Deprecated&lt;br/&gt;
   public Message createMessage(String name, String doc, Schema request) {
     return createMessage(name, doc, new LinkedHashMap&amp;lt;String,String&amp;gt;(),request);
   }&lt;br/&gt;
-  /** Create a one-way message. */&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a one-way message.&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; The type of the message to be created&lt;br/&gt;
+   * @param name Name of the message&lt;br/&gt;
+   * @param doc Docstring of the message&lt;br/&gt;
+   * @param propMap Properties of the message&lt;br/&gt;
+   * @param request Schema of the message&lt;br/&gt;
+   * @return One-way message&lt;br/&gt;
+   */&lt;br/&gt;
   public &amp;lt;T&amp;gt; Message createMessage(String name, String doc,&lt;br/&gt;
                                    Map&amp;lt;String,T&amp;gt; propMap, Schema request) {
     return new Message(name, doc, propMap, request);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a two-way message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a two-way message.&lt;br/&gt;
+   * @param name Name of the message&lt;br/&gt;
+   * @param doc Docstring of the message&lt;br/&gt;
+   * @param request Schema of the request message&lt;br/&gt;
+   * @param response Schema of the response message&lt;br/&gt;
+   * @param errors Schema of the errors&lt;br/&gt;
+   * @return Two-way message&lt;br/&gt;
+   */&lt;br/&gt;
   @Deprecated&lt;br/&gt;
   public Message createMessage(String name, String doc, Schema request,&lt;br/&gt;
                                Schema response, Schema errors) {
     return createMessage(name, doc, new LinkedHashMap&amp;lt;String,String&amp;gt;(),
                          request, response, errors);
   }&lt;br/&gt;
-  /** Create a two-way message. */&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a two-way message.&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; The type of the message to be created&lt;br/&gt;
+   * @param name Name of the message&lt;br/&gt;
+   * @param doc Docstring of the message&lt;br/&gt;
+   * @param propMap Properties of the message&lt;br/&gt;
+   * @param request Schema of the request message&lt;br/&gt;
+   * @param response Schema of the response message&lt;br/&gt;
+   * @param errors Schema of the errors&lt;br/&gt;
+   * @return Two-way message&lt;br/&gt;
+   */&lt;br/&gt;
   public &amp;lt;T&amp;gt; Message createMessage(String name, String doc,&lt;br/&gt;
                                    Map&amp;lt;String,T&amp;gt; propMap, Schema request,&lt;br/&gt;
                                    Schema response, Schema errors) {&lt;br/&gt;
@@ -306,12 +384,17 @@ public int hashCode() {
       + types.hashCode() + messages.hashCode() + props.hashCode();
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Render this as &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Render this as &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.&lt;br/&gt;
+   * @return A JSON representation of the protocol&lt;br/&gt;
+   */&lt;br/&gt;
   @Override&lt;br/&gt;
   public String toString() { return toString(false); }&lt;br/&gt;
 &lt;br/&gt;
-  /** Render this as &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Render this as &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.&lt;br/&gt;
    * @param pretty if true, pretty-print JSON.&lt;br/&gt;
+   * @return JSON representation of the protocol&lt;br/&gt;
    */&lt;br/&gt;
   public String toString(boolean pretty) {&lt;br/&gt;
     try {&lt;br/&gt;
@@ -325,6 +408,7 @@ public String toString(boolean pretty) {
       throw new AvroRuntimeException(e);
     }&lt;br/&gt;
   }&lt;br/&gt;
+&lt;br/&gt;
   void toJson(JsonGenerator gen) throws IOException {&lt;br/&gt;
     types.space(namespace);&lt;br/&gt;
 &lt;br/&gt;
@@ -350,29 +434,47 @@ void toJson(JsonGenerator gen) throws IOException {
     gen.writeEndObject();
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Return the MD5 hash of the text of this protocol. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the MD5 hash of the text of this protocol.&lt;br/&gt;
+   * @return The MD5 hash as a byte array&lt;br/&gt;
+   */&lt;br/&gt;
   public byte[] getMD5() {&lt;br/&gt;
     if (md5 == null)&lt;br/&gt;
       try {
         md5 = MessageDigest.getInstance(&quot;MD5&quot;)
-          .digest(this.toString().getBytes(&quot;UTF-8&quot;));
+          .digest(this.toString().getBytes(StandardCharsets.UTF_8));
       } catch (Exception e) {
         throw new AvroRuntimeException(e);
       }&lt;br/&gt;
     return md5;&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Read a protocol from a Json file. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read a protocol from a JSON file&lt;br/&gt;
+   * @param file The file that contains the JSON to parse&lt;br/&gt;
+   * @throws IOException if the file cannot be read&lt;br/&gt;
+   * @return the parsed protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public static Protocol parse(File file) throws IOException {
     return parse(Schema.FACTORY.createJsonParser(file));
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Read a protocol from a Json stream. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read a protocol from a JSON stream&lt;br/&gt;
+   * @param stream The InputStream providing JSON&lt;br/&gt;
+   * @throws IOException if the stream cannot be consumed&lt;br/&gt;
+   * @return the parsed protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public static Protocol parse(InputStream stream) throws IOException {
     return parse(Schema.FACTORY.createJsonParser(stream));
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Read a protocol from one or more json strings */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read a protocol from one or more JSON strings&lt;br/&gt;
+   * @param string One JSON string representing a protocol&lt;br/&gt;
+   * @param more Additional JSON strings representing one or more protocols&lt;br/&gt;
+   * @return the parsed protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public static Protocol parse(String string, String... more) {&lt;br/&gt;
     StringBuilder b = new StringBuilder(string);&lt;br/&gt;
     for (String part : more)&lt;br/&gt;
@@ -380,11 +482,15 @@ public static Protocol parse(String string, String... more) {
     return parse(b.toString());
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Read a protocol from a Json string. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read a protocol from one JSON strings&lt;br/&gt;
+   * @param string JSON string containing a protocol&lt;br/&gt;
+   * @return the parsed protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public static Protocol parse(String string) {&lt;br/&gt;
     try {
       return parse(Schema.FACTORY.createJsonParser
-                   (new ByteArrayInputStream(string.getBytes(&quot;UTF-8&quot;))));
+                   (new ByteArrayInputStream(string.getBytes(StandardCharsets.UTF_8))));
     } catch (IOException e) {       throw new AvroRuntimeException(e);     }&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/Schema.java b/lang/java/avro/src/main/java/org/apache/avro/Schema.java&lt;br/&gt;
index 9fcbfd3a7..3c46aaca1 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/Schema.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/Schema.java&lt;br/&gt;
@@ -96,7 +96,7 @@&lt;br/&gt;
     private String name;&lt;br/&gt;
     private Type() { this.name = this.name().toLowerCase(Locale.ENGLISH); }&lt;br/&gt;
     public String getName() { return name; }&lt;br/&gt;
-  };&lt;br/&gt;
+  }&lt;br/&gt;
 &lt;br/&gt;
   private final Type type;&lt;br/&gt;
   private LogicalType logicalType = null;&lt;br/&gt;
@@ -106,7 +106,11 @@&lt;br/&gt;
     this.type = type;&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a schema for a primitive type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a schema for a primitive type.&lt;br/&gt;
+   * @param type The type of the schema to be created&lt;br/&gt;
+   * @return The created schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema create(Type type) {&lt;br/&gt;
     switch (type) {&lt;br/&gt;
     case STRING:  return new StringSchema();&lt;br/&gt;
@@ -153,72 +157,143 @@ void setLogicalType(LogicalType logicalType) {
     this.logicalType = logicalType;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create an anonymous record schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create an anonymous record schema&lt;br/&gt;
+   * @param fields A list of fields that will construct the record&lt;br/&gt;
+   * @return A new Schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createRecord(List&amp;lt;Field&amp;gt; fields) {
     Schema result = createRecord(null, null, null, false);
     result.setFields(fields);
     return result;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a named record schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a named record schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The name of the record&lt;br/&gt;
+   * @param doc Docstring of the record&lt;br/&gt;
+   * @param namespace The namespace of the record&lt;br/&gt;
+   * @param isError indicates if there is an error&lt;br/&gt;
+   * @return A new Schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createRecord(String name, String doc, String namespace,&lt;br/&gt;
                                     boolean isError) {
     return new RecordSchema(new Name(name, namespace), doc, isError);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a named record schema with fields already set. */&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a named record schema with fields already set&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The name of the record&lt;br/&gt;
+   * @param doc Docstring of the record&lt;br/&gt;
+   * @param namespace The namespace of the record&lt;br/&gt;
+   * @param isError Indicates if there is an error&lt;br/&gt;
+   * @param fields the preset fields&lt;br/&gt;
+   * @return A new Schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createRecord(String name, String doc, String namespace,&lt;br/&gt;
                                     boolean isError, List&amp;lt;Field&amp;gt; fields) {
     return new RecordSchema(new Name(name, namespace), doc, isError, fields);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create an enum schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create an enum schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The name of the record&lt;br/&gt;
+   * @param doc The docstring of the record&lt;br/&gt;
+   * @param namespace The namespace of the record&lt;br/&gt;
+   * @param values The enum values&lt;br/&gt;
+   * @return A new enum Schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createEnum(String name, String doc, String namespace,&lt;br/&gt;
                                   List&amp;lt;String&amp;gt; values) {
     return new EnumSchema(new Name(name, namespace), doc,
       new LockableArrayList&amp;lt;&amp;gt;(values), null);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create an enum schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create an enum schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The name of the record&lt;br/&gt;
+   * @param doc Docstring of the record&lt;br/&gt;
+   * @param namespace The namespace of the record&lt;br/&gt;
+   * @param values The enum values&lt;br/&gt;
+   * @param enumDefault The default enum value&lt;br/&gt;
+   * @return A new enum Schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createEnum(String name, String doc, String namespace,&lt;br/&gt;
                                   List&amp;lt;String&amp;gt; values, String enumDefault) {
     return new EnumSchema(new Name(name, namespace), doc,
         new LockableArrayList&amp;lt;&amp;gt;(values), enumDefault);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create an array schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create an array schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param elementType The type of element&lt;br/&gt;
+   * @return An array schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createArray(Schema elementType) {
     return new ArraySchema(elementType);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a map schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a map schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param valueType The value types of the map&lt;br/&gt;
+   * @return A map schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createMap(Schema valueType) {
     return new MapSchema(valueType);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a union schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create an union schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param types The list of the schema types&lt;br/&gt;
+   * @return An union schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createUnion(List&amp;lt;Schema&amp;gt; types) {
     return new UnionSchema(new LockableArrayList&amp;lt;&amp;gt;(types));
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a union schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create an union schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param types One or more of the schema types&lt;br/&gt;
+   * @return An union schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema createUnion(Schema... types) {
     return createUnion(new LockableArrayList&amp;lt;&amp;gt;(types));
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a union schema. */&lt;br/&gt;
-  public static Schema createFixed(String name, String doc, String space,&lt;br/&gt;
-      int size) {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a map schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The name of the schema&lt;br/&gt;
+   * @param doc The doc of the schema&lt;br/&gt;
+   * @param space The space&lt;br/&gt;
+   * @param size The capacity of the FixedSchema&lt;br/&gt;
+   * @return A fixed schema&lt;br/&gt;
+   */&lt;br/&gt;
+  public static Schema createFixed(String name, String doc, String space, int size) {
     return new FixedSchema(new Name(name, space), doc, size);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Return the type of this schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return Type of this schema&lt;br/&gt;
+   */&lt;br/&gt;
   public Type getType() { return type; }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * If this is a record, returns the Field with the&lt;br/&gt;
    * given name &amp;lt;tt&amp;gt;fieldName&amp;lt;/tt&amp;gt;. If there is no field by that name, a&lt;br/&gt;
    * &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; is returned.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param fieldname The fieldname to look for&lt;br/&gt;
+   * @return The Field if set&lt;br/&gt;
    */&lt;br/&gt;
   public Field getField(String fieldname) {&lt;br/&gt;
     throw new AvroRuntimeException(&quot;Not a record: &quot;+this);&lt;br/&gt;
@@ -227,6 +302,8 @@ public Field getField(String fieldname) {&lt;br/&gt;
   /**&lt;br/&gt;
    * If this is a record, returns the fields in it. The returned&lt;br/&gt;
    * list is in the order of their positions.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return A list of all the fields&lt;br/&gt;
    */&lt;br/&gt;
   public List&amp;lt;Field&amp;gt; getFields() {&lt;br/&gt;
     throw new AvroRuntimeException(&quot;Not a record: &quot;+this);&lt;br/&gt;
@@ -235,103 +312,171 @@ public Field getField(String fieldname) {&lt;br/&gt;
   /**&lt;br/&gt;
    * If this is a record, set its fields. The fields can be set&lt;br/&gt;
    * only once in a schema.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param fields The fields to set&lt;br/&gt;
    */&lt;br/&gt;
   public void setFields(List&amp;lt;Field&amp;gt; fields) {
     throw new AvroRuntimeException(&quot;Not a record: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is an enum, return its symbols. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is an enum, return its symbols&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return A list strings that represent the symbols of the enum&lt;br/&gt;
+   */&lt;br/&gt;
   public List&amp;lt;String&amp;gt; getEnumSymbols() {
     throw new AvroRuntimeException(&quot;Not an enum: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is an enum, return its default value. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is an enum, return its default value&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return The default value of the enum&lt;br/&gt;
+   */&lt;br/&gt;
   public String getEnumDefault() {
     throw new AvroRuntimeException(&quot;Not an enum: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is an enum, return a symbol&apos;s ordinal value. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is an enum, return a symbol&apos;s ordinal value&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param symbol The symbol to look for in the enum&lt;br/&gt;
+   * @return the ordinal value of the symbol&lt;br/&gt;
+   */&lt;br/&gt;
   public int getEnumOrdinal(String symbol) {
     throw new AvroRuntimeException(&quot;Not an enum: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is an enum, returns true if it contains given symbol. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is an enum, returns true if it contains given symbol&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param symbol The symbol name&lt;br/&gt;
+   * @return Check if the symbol exists within the enum&lt;br/&gt;
+   */&lt;br/&gt;
   public boolean hasEnumSymbol(String symbol) {
     throw new AvroRuntimeException(&quot;Not an enum: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a record, enum or fixed, returns its name, otherwise the name&lt;br/&gt;
-   * of the primitive type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return If this is a record, enum or fixed, returns its name, otherwise the name of the primitive type&lt;br/&gt;
+   */&lt;br/&gt;
   public String getName() { return type.name; }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a record, enum, or fixed, returns its docstring,&lt;br/&gt;
-   * if available.  Otherwise, returns null. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return If this is a record, enum, or fixed, returns its docstring, if available.  Otherwise, returns null.&lt;br/&gt;
+   */&lt;br/&gt;
   public String getDoc() {
     return null;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a record, enum or fixed, returns its namespace, if any. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return If this is a record, enum or fixed, returns its namespace, if any.&lt;br/&gt;
+   */&lt;br/&gt;
   public String getNamespace() {
     throw new AvroRuntimeException(&quot;Not a named type: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a record, enum or fixed, returns its namespace-qualified name,&lt;br/&gt;
-   * otherwise returns the name of the primitive type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return If this is a record, enum or fixed, returns its namespace-qualified name, otherwise returns the name of the primitive type.&lt;br/&gt;
+   */&lt;br/&gt;
   public String getFullName() {
     return getName();
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a record, enum or fixed, add an alias. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is a record, enum or fixed, add an alias&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param alias The alias to be added&lt;br/&gt;
+   */&lt;br/&gt;
   public void addAlias(String alias) {
     throw new AvroRuntimeException(&quot;Not a named type: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a record, enum or fixed, add an alias. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is a record, enum or fixed, add an alias&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param alias The alias to be added&lt;br/&gt;
+   * @param space The space&lt;br/&gt;
+   */&lt;br/&gt;
   public void addAlias(String alias, String space) {
     throw new AvroRuntimeException(&quot;Not a named type: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a record, enum or fixed, return its aliases, if any. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is a record, enum or fixed, return its aliases, if any.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return A set of all the known aliases&lt;br/&gt;
+   */&lt;br/&gt;
   public Set&amp;lt;String&amp;gt; getAliases() {
     throw new AvroRuntimeException(&quot;Not a named type: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns true if this record is an error type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return True if this record is an error type&lt;br/&gt;
+   */&lt;br/&gt;
   public boolean isError() {
     throw new AvroRuntimeException(&quot;Not a record: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is an array, returns its element type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is an array, returns its element type&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return The element type&lt;br/&gt;
+   */&lt;br/&gt;
   public Schema getElementType() {
     throw new AvroRuntimeException(&quot;Not an array: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a map, returns its value type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is a map, returns its value type&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return Value type&lt;br/&gt;
+   */&lt;br/&gt;
   public Schema getValueType() {
     throw new AvroRuntimeException(&quot;Not a map: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a union, returns its types. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is a union, returns its types&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return Types&lt;br/&gt;
+   */&lt;br/&gt;
   public List&amp;lt;Schema&amp;gt; getTypes() {
     throw new AvroRuntimeException(&quot;Not a union: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is a union, return the branch with the provided full name. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is a union, return the branch with the provided full name&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name The lookup name&lt;br/&gt;
+   * @return The index of the given name&lt;br/&gt;
+   */&lt;br/&gt;
   public Integer getIndexNamed(String name) {
     throw new AvroRuntimeException(&quot;Not a union: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** If this is fixed, returns its size. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If this is fixed, returns its size&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return The fixed size of the schema&lt;br/&gt;
+   */&lt;br/&gt;
   public int getFixedSize() {
     throw new AvroRuntimeException(&quot;Not fixed: &quot;+this);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Render this as &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Render this as &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the schema as a JSON representation&lt;br/&gt;
+   */&lt;br/&gt;
   @Override&lt;br/&gt;
   public String toString() { return toString(false); }&lt;br/&gt;
 &lt;br/&gt;
-  /** Render this as &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Render this as &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.&lt;br/&gt;
+   *&lt;br/&gt;
    * @param pretty if true, pretty-print JSON.&lt;br/&gt;
+   * @return JSON representation of the schema&lt;br/&gt;
    */&lt;br/&gt;
   public String toString(boolean pretty) {&lt;br/&gt;
     try {&lt;br/&gt;
@@ -406,18 +551,42 @@ final boolean equalCachedHash(Schema other) {&lt;br/&gt;
     private final Order order;&lt;br/&gt;
     private Set&amp;lt;String&amp;gt; aliases;&lt;br/&gt;
 &lt;br/&gt;
-    /** @deprecated use {@link #Field(String, Schema, String, Object)} */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @deprecated use {@link #Field(String, Schema, String, Object)}&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name the name of the field&lt;br/&gt;
+     * @param schema the schema of the field&lt;br/&gt;
+     * @param doc the docstring of the field&lt;br/&gt;
+     * @param defaultValue The default value of the field&lt;br/&gt;
+     */&lt;br/&gt;
     @Deprecated&lt;br/&gt;
     public Field(String name, Schema schema, String doc,&lt;br/&gt;
         JsonNode defaultValue) {
       this(name, schema, doc, defaultValue, Order.ASCENDING);
     }&lt;br/&gt;
-    /** @deprecated use {@link #Field(String, Schema, String, Object, Order)} */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @deprecated use {@link #Field(String, Schema, String, Object, Order)}&lt;br/&gt;
+     * @param name the name of the field&lt;br/&gt;
+     * @param schema the schema of the field&lt;br/&gt;
+     * @param doc the docstring of the field&lt;br/&gt;
+     * @param defaultValue The default value of the field&lt;br/&gt;
+     * @param order The ordering of the field&lt;br/&gt;
+     */&lt;br/&gt;
     @Deprecated&lt;br/&gt;
     public Field(String name, Schema schema, String doc,&lt;br/&gt;
         JsonNode defaultValue, Order order) {
       this(name, schema, doc, defaultValue, true, order);
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @param name the name of the field&lt;br/&gt;
+     * @param schema the schema of the field&lt;br/&gt;
+     * @param doc the docstring of the field&lt;br/&gt;
+     * @param defaultValue the default value for this field specified using the mapping in {@link JsonProperties}&lt;br/&gt;
+     * @param validateDefault Validate the value by default&lt;br/&gt;
+     * @param order The ordering of the field&lt;br/&gt;
+     */&lt;br/&gt;
     public Field(String name, Schema schema, String doc,&lt;br/&gt;
                  JsonNode defaultValue, boolean validateDefault, Order order) {
       super(FIELD_RESERVED);
@@ -430,48 +599,96 @@ public Field(String name, Schema schema, String doc,
       this.order = order;
     }&lt;br/&gt;
     /**&lt;br/&gt;
-     * @param defaultValue the default value for this field specified using the mapping&lt;br/&gt;
-     *  in {@link JsonProperties}&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name the name of the field&lt;br/&gt;
+     * @param schema the schema of the field&lt;br/&gt;
+     * @param doc the docstring of the field&lt;br/&gt;
+     * @param defaultValue the default value for this field specified using the mapping in {@link JsonProperties}&lt;br/&gt;
      */&lt;br/&gt;
     public Field(String name, Schema schema, String doc,&lt;br/&gt;
         Object defaultValue) {       this(name, schema, doc, defaultValue, Order.ASCENDING);     }&lt;br/&gt;
+&lt;br/&gt;
+&lt;br/&gt;
     /**&lt;br/&gt;
-     * @param defaultValue the default value for this field specified using the mapping&lt;br/&gt;
-     *  in {@link JsonProperties}&lt;br/&gt;
+     * @param name the name of the field&lt;br/&gt;
+     * @param schema the schema of the field&lt;br/&gt;
+     * @param doc the docstring of the field&lt;br/&gt;
+     * @param defaultValue the default value for this field specified using the mapping in {@link JsonProperties}&lt;br/&gt;
+     * @param order The ordering of the field&lt;br/&gt;
      */&lt;br/&gt;
     public Field(String name, Schema schema, String doc,&lt;br/&gt;
         Object defaultValue, Order order) {
       this(name, schema, doc, JacksonUtils.toJsonNode(defaultValue), order);
     }&lt;br/&gt;
-    public String name() { return name; };&lt;br/&gt;
-    /** The position of this field within the record. */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return The name of the field&lt;br/&gt;
+     */&lt;br/&gt;
+    public String name() { return name; }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return position of this field within the record&lt;br/&gt;
+     */&lt;br/&gt;
     public int pos() { return position; }&lt;br/&gt;
-    /** This field&apos;s {@link Schema}. */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * This field&apos;s {@link Schema}&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return The schema of the field&lt;br/&gt;
+     */&lt;br/&gt;
     public Schema schema() { return schema; }&lt;br/&gt;
-    /** Field&apos;s documentation within the record, if set. May return null. */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Field&apos;s documentation within the record, if set. May return null&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return The docstring of the field&lt;br/&gt;
+     */&lt;br/&gt;
     public String doc() { return doc; }&lt;br/&gt;
-    /** @deprecated use {@link #defaultVal() } */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @deprecated use {@link #defaultVal() }&lt;br/&gt;
+     * @return The default value of the field&lt;br/&gt;
+     */&lt;br/&gt;
     @Deprecated public JsonNode defaultValue() { return defaultValue; }&lt;br/&gt;
+&lt;br/&gt;
     /**&lt;br/&gt;
      * @return the default value for this field specified using the mapping&lt;br/&gt;
      *  in {@link JsonProperties}&lt;br/&gt;
      */&lt;br/&gt;
     public Object defaultVal() { return JacksonUtils.toObject(defaultValue, schema); }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * This field&apos;s ordering {@link Order}&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return The ordering of the field&lt;br/&gt;
+     */&lt;br/&gt;
     public Order order() { return order; }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return The properties of the field&lt;br/&gt;
+     */&lt;br/&gt;
     @Deprecated public Map&amp;lt;String,String&amp;gt; props() { return getProps(); }&lt;br/&gt;
     public void addAlias(String alias) {
       if (aliases == null)
         this.aliases = new LinkedHashSet&amp;lt;&amp;gt;();
       aliases.add(alias);
     }&lt;br/&gt;
-    /** Return the defined aliases as an unmodifiable Set. */&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return the defined aliases as an unmodifiable Set&lt;br/&gt;
+     */&lt;br/&gt;
     public Set&amp;lt;String&amp;gt; aliases() {
       if (aliases == null)
         return Collections.emptySet();
       return Collections.unmodifiableSet(aliases);
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @param other The object to compare with&lt;br/&gt;
+     * @return If the objects are equal&lt;br/&gt;
+     */&lt;br/&gt;
     public boolean equals(Object other) {&lt;br/&gt;
       if (other == this) return true;&lt;br/&gt;
       if (!(other instanceof Field)) return false;&lt;br/&gt;
@@ -482,6 +699,10 @@ public boolean equals(Object other) {
         (order == that.order) &amp;amp;&amp;amp;
         props.equals(that.props);
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return returns the hashcode of the schema&lt;br/&gt;
+     */&lt;br/&gt;
     public int hashCode() { return name.hashCode() + schema.computeHash(); }&lt;br/&gt;
 &lt;br/&gt;
     private boolean defaultValueEquals(JsonNode thatDefaultValue) {&lt;br/&gt;
@@ -991,15 +1212,22 @@ void toJson(Names names, JsonGenerator gen) throws IOException {&lt;br/&gt;
     private boolean validate = true;&lt;br/&gt;
     private boolean validateDefaults = true;&lt;br/&gt;
 &lt;br/&gt;
-    /** Adds the provided types to the set of defined, named types known to&lt;br/&gt;
-     * this parser. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Add the provided types to the set of defined, named types known to this parser.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param types Types to add to the current schema&lt;br/&gt;
+     * @return The schema with the appended types&lt;br/&gt;
+     */&lt;br/&gt;
     public Parser addTypes(Map&amp;lt;String,Schema&amp;gt; types) {
       for (Schema s : types.values())
         names.add(s);
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Returns the set of defined, named types known to this parser. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Returns the set of defined, named types known to this parser&lt;br/&gt;
+     * @return A map of all the names schema pair&lt;br/&gt;
+     */&lt;br/&gt;
     public Map&amp;lt;String,Schema&amp;gt; getTypes() {&lt;br/&gt;
       Map&amp;lt;String,Schema&amp;gt; result = new LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
       for (Schema s : names.values())&lt;br/&gt;
@@ -1007,39 +1235,69 @@ public Parser addTypes(Map&amp;lt;String,Schema&amp;gt; types) {
       return result;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Enable or disable name validation. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @param validate Enable or disable name validation&lt;br/&gt;
+     * @return the parser&lt;br/&gt;
+     */&lt;br/&gt;
     public Parser setValidate(boolean validate) {
       this.validate = validate;
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** True iff names are validated.  True by default. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * True iff names are validated.  True by default.&lt;br/&gt;
+     * @return boolean if validation is on&lt;br/&gt;
+     */&lt;br/&gt;
     public boolean getValidate() { return this.validate; }&lt;br/&gt;
 &lt;br/&gt;
-    /** Enable or disable default value validation. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Enable or disable default value validation&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param validateDefaults Set validation on or of by default&lt;br/&gt;
+     * @return The current schema&lt;br/&gt;
+     */&lt;br/&gt;
     public Parser setValidateDefaults(boolean validateDefaults) {
       this.validateDefaults = validateDefaults;
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** True iff default values are validated.  False by default. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return True iff default values are validated. False by default.&lt;br/&gt;
+     */&lt;br/&gt;
     public boolean getValidateDefaults() { return this.validateDefaults; }&lt;br/&gt;
 &lt;br/&gt;
-    /** Parse a schema from the provided file.&lt;br/&gt;
-     * If named, the schema is added to the names known to this parser. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Parse a schema from the provided file. If named, the schema is added to the names known to this parser.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param file The file which contains the schema&lt;br/&gt;
+     * @throws IOException Throws an exception if it cannot access the file&lt;br/&gt;
+     * @return the parsed schema&lt;br/&gt;
+     */&lt;br/&gt;
     public Schema parse(File file) throws IOException {
       return parse(FACTORY.createJsonParser(file));
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Parse a schema from the provided stream.&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Parse a schema from the provided stream.&lt;br/&gt;
      * If named, the schema is added to the names known to this parser.&lt;br/&gt;
-     * The input stream stays open after the parsing. */&lt;br/&gt;
+     * The input stream stays open after the parsing.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param in the inputstream which provides the schema in json format&lt;br/&gt;
+     * @throws IOException Throws an exception if it cannot access the inputstream&lt;br/&gt;
+     * @return The parsed schema&lt;br/&gt;
+     */&lt;br/&gt;
     public Schema parse(InputStream in) throws IOException {
       return parse(FACTORY.createJsonParser(in).disable(
               JsonParser.Feature.AUTO_CLOSE_SOURCE));
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Read a schema from one or more json strings */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Read a schema from one or more json strings&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param s The string containing the schema&lt;br/&gt;
+     * @param more one or more strings containing a schema&lt;br/&gt;
+     * @return The parsed schema based on the input string(s)&lt;br/&gt;
+     */&lt;br/&gt;
     public Schema parse(String s, String... more) {&lt;br/&gt;
       StringBuilder b = new StringBuilder(s);&lt;br/&gt;
       for (String part : more)&lt;br/&gt;
@@ -1047,8 +1305,13 @@ public Schema parse(String s, String... more) {
       return parse(b.toString());
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Parse a schema from the provided string.&lt;br/&gt;
-     * If named, the schema is added to the names known to this parser. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Parse a schema from the provided string.&lt;br/&gt;
+     * If named, the schema is added to the names known to this parser.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param s The string to be parsed&lt;br/&gt;
+     * @return The parsed Schema&lt;br/&gt;
+     */&lt;br/&gt;
     public Schema parse(String s) {&lt;br/&gt;
       try {&lt;br/&gt;
         return parse(FACTORY.createJsonParser(new StringReader(s)));&lt;br/&gt;
@@ -1057,6 +1320,10 @@ public Schema parse(String s) {&lt;br/&gt;
       }&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * @param parser The JsonParser which will provide the schema&lt;br/&gt;
+     * @return The parsed Schema&lt;br/&gt;
+     */&lt;br/&gt;
     private Schema parse(JsonParser parser) throws IOException {&lt;br/&gt;
       boolean saved = validateNames.get();&lt;br/&gt;
       boolean savedValidateDefaults = VALIDATE_DEFAULTS.get();&lt;br/&gt;
@@ -1100,16 +1367,22 @@ public static Schema parse(InputStream in) throws IOException {
     return new Parser().parse(in);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Construct a schema from &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt; text.&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Construct a schema from &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt; text.&lt;br/&gt;
    * @deprecated use {@link Schema.Parser} instead.&lt;br/&gt;
+   * @param jsonSchema The JSON representing a schema&lt;br/&gt;
+   * @return the parsed schema based on the input JSON&lt;br/&gt;
    */&lt;br/&gt;
   public static Schema parse(String jsonSchema) {
     return new Parser().parse(jsonSchema);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Construct a schema from &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt; text.&lt;br/&gt;
-   * @param validate true if names should be validated, false if not.&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Construct a schema from &amp;lt;a href=&quot;http://json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt; text.&lt;br/&gt;
    * @deprecated use {@link Schema.Parser} instead.&lt;br/&gt;
+   * @param jsonSchema The JSON representing a schema&lt;br/&gt;
+   * @param validate true if names should be validated, false if not.&lt;br/&gt;
+   * @return the parsed schema based on the input JSON&lt;br/&gt;
    */&lt;br/&gt;
   public static Schema parse(String jsonSchema, boolean validate) {&lt;br/&gt;
     return new Parser().setValidate(validate).parse(jsonSchema);&lt;br/&gt;
@@ -1430,6 +1703,8 @@ private static String getOptionalText(JsonNode container, String key) {&lt;br/&gt;
   /**&lt;br/&gt;
    * Parses a string as Json.&lt;br/&gt;
    * @deprecated use {@link org.apache.avro.data.Json#parseJson(String)}&lt;br/&gt;
+   * @param s JSON representation as a string&lt;br/&gt;
+   * @return The parsed JsonNode&lt;br/&gt;
    */&lt;br/&gt;
   @Deprecated&lt;br/&gt;
   public static JsonNode parseJson(String s) {&lt;br/&gt;
@@ -1446,7 +1721,12 @@ public static JsonNode parseJson(String s) {&lt;br/&gt;
    * permits reading records, enums and fixed schemas whose names have changed,&lt;br/&gt;
    * and records whose field names have changed.  The returned schema always&lt;br/&gt;
    * contains the same data elements in the same order, but with possibly&lt;br/&gt;
-   * different names. */&lt;br/&gt;
+   * different names.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param writer writer&lt;br/&gt;
+   * @param reader reader&lt;br/&gt;
+   * @return Schema&lt;br/&gt;
+   */&lt;br/&gt;
   public static Schema applyAliases(Schema writer, Schema reader) {&lt;br/&gt;
     if (writer == reader) return writer;          // same schema&lt;br/&gt;
 &lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/SchemaBuilder.java b/lang/java/avro/src/main/java/org/apache/avro/SchemaBuilder.java&lt;br/&gt;
index b8b11539b..12c3a8117 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/SchemaBuilder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/SchemaBuilder.java&lt;br/&gt;
@@ -70,15 +70,15 @@&lt;br/&gt;
  *     .name(&quot;meta&quot;).type().nullable().map().values().bytesType().noDefault()&lt;br/&gt;
  *   .endRecord();&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ * &amp;lt;br&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * &amp;lt;h5&amp;gt;Usage Guide&amp;lt;/h5&amp;gt;&lt;br/&gt;
+ * &amp;lt;h1&amp;gt;Usage Guide&amp;lt;/h1&amp;gt;&lt;br/&gt;
  * SchemaBuilder chains together many smaller builders and maintains nested&lt;br/&gt;
  * context in order to mimic the Avro Schema specification. Every Avro type in&lt;br/&gt;
  * JSON has required and optional JSON properties, as well as user-defined&lt;br/&gt;
  * properties.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
- * &amp;lt;h6&amp;gt;Selecting and Building an Avro Type&amp;lt;/h6&amp;gt;&lt;br/&gt;
+ * &amp;lt;br&amp;gt;&lt;br/&gt;
+ * &amp;lt;h2&amp;gt;Selecting and Building an Avro Type&amp;lt;/h2&amp;gt;&lt;br/&gt;
  * The API analogy for the right hand side of the Avro Schema JSON&lt;br/&gt;
  * &amp;lt;pre&amp;gt;&lt;br/&gt;
  * &quot;type&quot;:&lt;br/&gt;
@@ -86,8 +86,8 @@&lt;br/&gt;
  * is a {@link TypeBuilder}, {@link FieldTypeBuilder}, or&lt;br/&gt;
  * {@link UnionFieldTypeBuilder}, depending on the context. These types all&lt;br/&gt;
  * share a similar API for selecting and building types.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
- * &amp;lt;h5&amp;gt;Primitive Types&amp;lt;/h5&amp;gt;&lt;br/&gt;
+ * &amp;lt;br&amp;gt;&lt;br/&gt;
+ * &amp;lt;h1&amp;gt;Primitive Types&amp;lt;/h1&amp;gt;&lt;br/&gt;
  * All Avro primitive types are trivial to configure. A primitive type in&lt;br/&gt;
  * Avro JSON can be declared two ways, one that supports custom properties&lt;br/&gt;
  * and one that does not:&lt;br/&gt;
@@ -106,21 +106,25 @@&lt;br/&gt;
  * Every primitive type has a shortcut to create the trivial type, and&lt;br/&gt;
  * a builder when custom properties are required.  The first line above is&lt;br/&gt;
  * a shortcut for the second, analogous to the JSON case.&lt;br/&gt;
- * &amp;lt;h6&amp;gt;Named Types&amp;lt;/h6&amp;gt;&lt;br/&gt;
+ * &amp;lt;h2&amp;gt;Named Types&amp;lt;/h2&amp;gt;&lt;br/&gt;
  * Avro named types have names, namespace, aliases, and doc.  In this API&lt;br/&gt;
  * these share a common parent, {@link NamespacedBuilder}.&lt;br/&gt;
  * The builders for named types require a name to be constructed, and optional&lt;br/&gt;
  * configuration via:&lt;br/&gt;
+ * &amp;lt;ul&amp;gt;&lt;br/&gt;
  * &amp;lt;li&amp;gt;{@link NamespacedBuilder#doc()}&amp;lt;/li&amp;gt;&lt;br/&gt;
  * &amp;lt;li&amp;gt;{@link NamespacedBuilder#namespace(String)}&amp;lt;/li&amp;gt;&lt;br/&gt;
  * &amp;lt;li&amp;gt;{@link NamespacedBuilder#aliases(String...)}&amp;lt;/li&amp;gt;&lt;br/&gt;
  * &amp;lt;li&amp;gt;{@link PropBuilder#prop(String, String)}&amp;lt;/li&amp;gt;&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ * &amp;lt;/ul&amp;gt;&lt;br/&gt;
+ * &amp;lt;br&amp;gt;&lt;br/&gt;
  * Each named type completes configuration of the optional properties&lt;br/&gt;
  * with its own method:&lt;br/&gt;
+ * &amp;lt;ul&amp;gt;&lt;br/&gt;
  * &amp;lt;li&amp;gt;{@link FixedBuilder#size(int)}&amp;lt;/li&amp;gt;&lt;br/&gt;
  * &amp;lt;li&amp;gt;{@link EnumBuilder#symbols(String...)}&amp;lt;/li&amp;gt;&lt;br/&gt;
  * &amp;lt;li&amp;gt;{@link RecordBuilder#fields()}&amp;lt;/li&amp;gt;&lt;br/&gt;
+ * &amp;lt;/ul&amp;gt;&lt;br/&gt;
  * Example use of a named type with all optional parameters:&lt;br/&gt;
  * &amp;lt;pre&amp;gt;&lt;br/&gt;
  * .enumeration(&quot;Suit&quot;).namespace(&quot;org.apache.test&quot;)&lt;br/&gt;
@@ -139,31 +143,31 @@&lt;br/&gt;
  *   &quot;symbols&quot;:&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;SPADES&amp;quot;, &amp;quot;HEARTS&amp;quot;, &amp;quot;DIAMONDS&amp;quot;, &amp;quot;CLUBS&amp;quot;&amp;#93;&lt;/span&gt;&lt;br/&gt;
  * }&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
- * &amp;lt;h6&amp;gt;Nested Types&amp;lt;/h6&amp;gt;&lt;br/&gt;
+ * &amp;lt;h2&amp;gt;Nested Types&amp;lt;/h2&amp;gt;&lt;br/&gt;
  * The Avro nested types, map and array, can have custom properties like&lt;br/&gt;
  * all avro types, are not named, and must specify a nested type.&lt;br/&gt;
  * After configuration of optional properties, an array or map&lt;br/&gt;
  * builds or selects its nested type with {@link ArrayBuilder#items()}&lt;br/&gt;
  * and {@link MapBuilder#values()}, respectively.&lt;br/&gt;
  *&lt;br/&gt;
- * &amp;lt;h6&amp;gt;Fields&amp;lt;/h6&amp;gt;&lt;br/&gt;
+ * &amp;lt;h2&amp;gt;Fields&amp;lt;/h2&amp;gt;&lt;br/&gt;
  * {@link RecordBuilder#fields()} returns a {@link FieldAssembler} for&lt;br/&gt;
  * defining the fields of the record and completing it.&lt;br/&gt;
  * Each field must have a name, specified via {@link FieldAssembler#name(String)},&lt;br/&gt;
  * which returns a {@link FieldBuilder} for defining aliases, custom properties,&lt;br/&gt;
  * and documentation of the field.  After configuring these optional values for&lt;br/&gt;
  * a field, the type is selected or built with {@link FieldBuilder#type()}.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ * &amp;lt;br&amp;gt;&lt;br/&gt;
  * Fields have default values that must be specified to complete the field.&lt;br/&gt;
  * {@link FieldDefault#noDefault()} is available for all field types, and&lt;br/&gt;
  * a specific method is available for each type to use a default, for example&lt;br/&gt;
  * {@link IntDefault#intDefault(int)}&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ * &amp;lt;br&amp;gt;&lt;br/&gt;
  * There are field shortcut methods on {@link FieldAssembler} for primitive types.&lt;br/&gt;
  * These shortcuts create required, optional, and nullable fields, but do not&lt;br/&gt;
  * support field aliases, doc, or custom properties.&lt;br/&gt;
  *&lt;br/&gt;
- * &amp;lt;h6&amp;gt;Unions&amp;lt;/h6&amp;gt;&lt;br/&gt;
+ * &amp;lt;h2&amp;gt;Unions&amp;lt;/h2&amp;gt;&lt;br/&gt;
  * Union types are built via {@link TypeBuilder#unionOf()} or&lt;br/&gt;
  * {@link FieldTypeBuilder#unionOf()} in the context of type selection.&lt;br/&gt;
  * This chains together multiple types, in union order.  For example:&lt;br/&gt;
@@ -183,7 +187,7 @@&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  * In a field context, the first type of a union defines what default type&lt;br/&gt;
  * is allowed.&lt;br/&gt;
- * &amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;br&amp;gt;&lt;br/&gt;
  * Unions have two shortcuts for common cases.  nullable()&lt;br/&gt;
  * creates a union of a type and null.  In a field type context, optional()&lt;br/&gt;
  * is available and creates a union of null and a type, with a null default.&lt;br/&gt;
@@ -198,7 +202,7 @@&lt;br/&gt;
  *   .name(&quot;f&quot;).type().optional().longType()&lt;br/&gt;
  * &amp;lt;/pre&amp;gt;&lt;br/&gt;
  *&lt;br/&gt;
- * &amp;lt;h6&amp;gt;Explicit Types and Types by Name&amp;lt;/h6&amp;gt;&lt;br/&gt;
+ * &amp;lt;h2&amp;gt;Explicit Types and Types by Name&amp;lt;/h2&amp;gt;&lt;br/&gt;
  * Types can also be specified explicitly by passing in a Schema, or by name:&lt;br/&gt;
  * &amp;lt;pre&amp;gt;&lt;br/&gt;
  *   .type(Schema.create(Schema.Type.INT)) // explicitly specified&lt;br/&gt;
@@ -210,7 +214,7 @@&lt;br/&gt;
  * propagate as a default to child fields, nested types, or later defined types&lt;br/&gt;
  * in a union.  To specify a name that has no namespace and ignore the inherited&lt;br/&gt;
  * namespace, set the namespace to &quot;&quot;.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ * &amp;lt;br&amp;gt;&lt;br/&gt;
  * {@link SchemaBuilder#builder(String)} returns a type builder with a default&lt;br/&gt;
  * namespace.  {@link SchemaBuilder#builder()} returns a type builder with no&lt;br/&gt;
  * default namespace.&lt;br/&gt;
@@ -221,7 +225,7 @@ private SchemaBuilder() {&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
-   * Create a builder for Avro schemas.&lt;br/&gt;
+   * @return A builder for Avro Schemas&lt;br/&gt;
    */&lt;br/&gt;
   public static TypeBuilder&amp;lt;Schema&amp;gt; builder() {&lt;br/&gt;
     return new TypeBuilder&amp;lt;&amp;gt;(new SchemaCompletion(), new NameContext());&lt;br/&gt;
@@ -230,6 +234,9 @@ private SchemaBuilder() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Create a builder for Avro schemas with a default namespace. Types created&lt;br/&gt;
    * without namespaces will inherit the namespace provided.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param namespace The namespace of the Schema&lt;br/&gt;
+   * @return A new TypeBuilder&lt;br/&gt;
    */&lt;br/&gt;
   public static TypeBuilder&amp;lt;Schema&amp;gt; builder(String namespace) {&lt;br/&gt;
     return new TypeBuilder&amp;lt;&amp;gt;(new SchemaCompletion(),&lt;br/&gt;
@@ -243,6 +250,7 @@ private SchemaBuilder() {&lt;br/&gt;
    *   builder().record(name);&lt;br/&gt;
    * &amp;lt;/pre&amp;gt;&lt;br/&gt;
    * @param name the record name&lt;br/&gt;
+   * @return A new RecordBuilder&lt;br/&gt;
    */&lt;br/&gt;
   public static RecordBuilder&amp;lt;Schema&amp;gt; record(String name) {&lt;br/&gt;
     return builder().record(name);&lt;br/&gt;
@@ -255,6 +263,7 @@ private SchemaBuilder() {&lt;br/&gt;
    *   builder().enumeration(name);&lt;br/&gt;
    * &amp;lt;/pre&amp;gt;&lt;br/&gt;
    * @param name the enum name&lt;br/&gt;
+   * @return A new EnumBuilder&lt;br/&gt;
    */&lt;br/&gt;
   public static EnumBuilder&amp;lt;Schema&amp;gt; enumeration(String name) {&lt;br/&gt;
     return builder().enumeration(name);&lt;br/&gt;
@@ -267,6 +276,7 @@ private SchemaBuilder() {&lt;br/&gt;
    *   builder().fixed(name);&lt;br/&gt;
    * &amp;lt;/pre&amp;gt;&lt;br/&gt;
    * @param name the fixed name&lt;br/&gt;
+   * @return A new FixedBuilder&lt;br/&gt;
    */&lt;br/&gt;
   public static FixedBuilder&amp;lt;Schema&amp;gt; fixed(String name) {&lt;br/&gt;
     return builder().fixed(name);&lt;br/&gt;
@@ -278,6 +288,7 @@ private SchemaBuilder() {&lt;br/&gt;
    * &amp;lt;pre&amp;gt;&lt;br/&gt;
    *   builder().array();&lt;br/&gt;
    * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+   * @return A new ArrayBuilder&lt;br/&gt;
    */&lt;br/&gt;
   public static ArrayBuilder&amp;lt;Schema&amp;gt; array() {&lt;br/&gt;
     return builder().array();&lt;br/&gt;
@@ -289,6 +300,7 @@ private SchemaBuilder() {&lt;br/&gt;
    * &amp;lt;pre&amp;gt;&lt;br/&gt;
    *   builder().map();&lt;br/&gt;
    * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+   * @return A new MapBuilder&lt;br/&gt;
    */&lt;br/&gt;
   public static MapBuilder&amp;lt;Schema&amp;gt; map() {&lt;br/&gt;
     return builder().map();&lt;br/&gt;
@@ -300,6 +312,7 @@ private SchemaBuilder() {&lt;br/&gt;
    * &amp;lt;pre&amp;gt;&lt;br/&gt;
    *   builder().unionOf();&lt;br/&gt;
    * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+   * @return A new BaseTypeBuilder&lt;br/&gt;
    */&lt;br/&gt;
   public static BaseTypeBuilder&amp;lt;UnionAccumulator&amp;lt;Schema&amp;gt;&amp;gt; unionOf() {&lt;br/&gt;
     return builder().unionOf();&lt;br/&gt;
@@ -318,6 +331,7 @@ private SchemaBuilder() {&lt;br/&gt;
    * &amp;lt;pre&amp;gt;&lt;br/&gt;
    *   unionOf().intType().and().nullType().endUnion();&lt;br/&gt;
    * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+   * @return A new BaseTypeBuilder&lt;br/&gt;
    */&lt;br/&gt;
   public static BaseTypeBuilder&amp;lt;Schema&amp;gt; nullable() {&lt;br/&gt;
     return builder().nullable();&lt;br/&gt;
@@ -327,6 +341,7 @@ private SchemaBuilder() {&lt;br/&gt;
   /**&lt;br/&gt;
    * An abstract builder for all Avro types.  All Avro types&lt;br/&gt;
    * can have arbitrary string key-value properties.&lt;br/&gt;
+   *&lt;br/&gt;
    */&lt;br/&gt;
   public static abstract class PropBuilder&amp;lt;S extends PropBuilder&amp;lt;S&amp;gt;&amp;gt; {&lt;br/&gt;
     private Map&amp;lt;String, JsonNode&amp;gt; props = null;&lt;br/&gt;
@@ -335,6 +350,10 @@ protected PropBuilder() {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Set name-value pair properties for this type or field.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the property&lt;br/&gt;
+     * @param val the value of the property&lt;br/&gt;
+     * @return the contructed property&lt;br/&gt;
      */&lt;br/&gt;
     public final S prop(String name, String val) {&lt;br/&gt;
       return prop(name, TextNode.valueOf(val));&lt;br/&gt;
@@ -342,6 +361,10 @@ public final S prop(String name, String val) {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Set name-value pair properties for this type or field.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the property&lt;br/&gt;
+     * @param value the value of the property&lt;br/&gt;
+     * @return the contructed property&lt;br/&gt;
      */&lt;br/&gt;
     public final S prop(String name, Object value) {&lt;br/&gt;
       return prop(name, JacksonUtils.toJsonNode(value));&lt;br/&gt;
@@ -368,8 +391,12 @@ private boolean hasProps() {&lt;br/&gt;
       }&lt;br/&gt;
       return jsonable;&lt;br/&gt;
     }&lt;br/&gt;
-    /** a self-type for chaining builder subclasses.  Concrete subclasses&lt;br/&gt;
-     * must return &apos;this&apos; **/&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * A self-type for chaining builder subclasses. Concrete subclasses must return &apos;this&apos;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return itself&lt;br/&gt;
+     */&lt;br/&gt;
     protected abstract S self();&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
@@ -377,7 +404,7 @@ private boolean hasProps() {&lt;br/&gt;
    * An abstract type that provides builder methods for configuring the name,&lt;br/&gt;
    * doc, and aliases of all Avro types that have names (fields, Fixed, Record,&lt;br/&gt;
    * and Enum).&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * All Avro named types and fields have &apos;doc&apos;, &apos;aliases&apos;, and &apos;name&apos;&lt;br/&gt;
    * components. &apos;name&apos; is required, and provided to this builder. &apos;doc&apos; and&lt;br/&gt;
    * &apos;aliases&apos; are optional.&lt;br/&gt;
@@ -395,13 +422,23 @@ protected NamedBuilder(NameContext names, String name) {
       this.name = name;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** configure this type&apos;s optional documentation string **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Configure this type&apos;s optional documentation string&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param doc The docstring&lt;br/&gt;
+     * @return {@link S}&lt;br/&gt;
+     */&lt;br/&gt;
     public final S doc(String doc) {
       this.doc = doc;
       return self();
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** configure this type&apos;s optional name aliases **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Configure this type&apos;s optional name aliases&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param aliases Set one or more aliasses&lt;br/&gt;
+     * @return {@link S}&lt;br/&gt;
+     */&lt;br/&gt;
     public final S aliases(String... aliases) {&lt;br/&gt;
       this.aliases = aliases;&lt;br/&gt;
       return self();&lt;br/&gt;
@@ -456,10 +493,13 @@ protected NamespacedBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names,&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Set the namespace of this type. To clear the namespace, set empty string.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * When the namespace is null or unset, the namespace of the type defaults&lt;br/&gt;
      * to the namespace of the enclosing context.&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param namespace The namespace of the schema&lt;br/&gt;
+     * @return {@link S}&lt;br/&gt;
+     */&lt;br/&gt;
     public final S namespace(String namespace) {&lt;br/&gt;
       this.namespace = namespace;&lt;br/&gt;
       return self();&lt;br/&gt;
@@ -511,7 +551,7 @@ private R end() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro boolean type with optional properties. Set properties with&lt;br/&gt;
    * {@link #prop(String, String)}, and finalize with {@link #endBoolean()}&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class BooleanBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PrimitiveBuilder&amp;lt;R, BooleanBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private BooleanBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -528,7 +568,10 @@ private BooleanBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** complete building this type, return control to context **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * complete building this type, return control to context&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endBoolean() {
       return super.end();
     }&lt;br/&gt;
@@ -537,7 +580,7 @@ public R endBoolean() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro int type with optional properties. Set properties with&lt;br/&gt;
    * {@link #prop(String, String)}, and finalize with {@link #endInt()}&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class IntBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PrimitiveBuilder&amp;lt;R, IntBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private IntBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -554,7 +597,10 @@ private IntBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** complete building this type, return control to context **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Complete building this type, return control to context&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endInt() {
       return super.end();
     }&lt;br/&gt;
@@ -563,7 +609,7 @@ public R endInt() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro long type with optional properties. Set properties with&lt;br/&gt;
    * {@link #prop(String, String)}, and finalize with {@link #endLong()}&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class LongBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PrimitiveBuilder&amp;lt;R, LongBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private LongBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -580,7 +626,10 @@ private LongBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {       return this;     }&lt;br/&gt;
 &lt;br/&gt;
-    /** complete building this type, return control to context **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Complete building this type, return control to context&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endLong() {
       return super.end();
     }&lt;br/&gt;
@@ -589,7 +638,7 @@ public R endLong() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro float type with optional properties. Set properties with&lt;br/&gt;
    * {@link #prop(String, String)}, and finalize with {@link #endFloat()}&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class FloatBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PrimitiveBuilder&amp;lt;R, FloatBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private FloatBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -606,7 +655,10 @@ private FloatBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** complete building this type, return control to context **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * complete building this type, return control to context&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endFloat() {
       return super.end();
     }&lt;br/&gt;
@@ -615,7 +667,7 @@ public R endFloat() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro double type with optional properties. Set properties with&lt;br/&gt;
    * {@link #prop(String, String)}, and finalize with {@link #endDouble()}&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class DoubleBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PrimitiveBuilder&amp;lt;R, DoubleBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private DoubleBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -632,7 +684,10 @@ private DoubleBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** complete building this type, return control to context **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Complete building this type, return control to context&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endDouble() {       return super.end();     }&lt;br/&gt;
@@ -641,7 +696,7 @@ public R endDouble() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro string type with optional properties. Set properties with&lt;br/&gt;
    * {@link #prop(String, String)}, and finalize with {@link #endString()}&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class StringBldr&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PrimitiveBuilder&amp;lt;R, StringBldr&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private StringBldr(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -658,7 +713,10 @@ private StringBldr(Completion&amp;lt;R&amp;gt; context, NameContext names) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** complete building this type, return control to context **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * complete building this type, return control to context&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endString() {
       return super.end();
     }&lt;br/&gt;
@@ -667,7 +725,7 @@ public R endString() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro bytes type with optional properties. Set properties with&lt;br/&gt;
    * {@link #prop(String, String)}, and finalize with {@link #endBytes()}&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class BytesBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PrimitiveBuilder&amp;lt;R, BytesBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private BytesBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -684,7 +742,10 @@ private BytesBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** complete building this type, return control to context **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Complete building this type, return control to context&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endBytes() {
       return super.end();
     }&lt;br/&gt;
@@ -693,7 +754,7 @@ public R endBytes() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro null type with optional properties. Set properties with&lt;br/&gt;
    * {@link #prop(String, String)}, and finalize with {@link #endNull()}&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class NullBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PrimitiveBuilder&amp;lt;R, NullBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private NullBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -710,7 +771,10 @@ private NullBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {       return this;     }&lt;br/&gt;
 &lt;br/&gt;
-    /** complete building this type, return control to context **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Complete building this type, return control to context&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endNull() {
       return super.end();
     }&lt;br/&gt;
@@ -719,14 +783,14 @@ public R endNull() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro Fixed type with optional properties, namespace, doc, and&lt;br/&gt;
    * aliases.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * Set properties with {@link #prop(String, String)}, namespace with&lt;br/&gt;
    * {@link #namespace(String)}, doc with {@link #doc(String)}, and aliases with&lt;br/&gt;
    * {@link #aliases(String[])}.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * The Fixed schema is finalized when its required size is set via&lt;br/&gt;
    * {@link #size(int)}.&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class FixedBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       NamespacedBuilder&amp;lt;R, FixedBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private FixedBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names, String name) {&lt;br/&gt;
@@ -743,7 +807,12 @@ private FixedBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names, String name) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Configure this fixed type&apos;s size, and end its configuration. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Complete building this type, return control to context&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param size The size of the {@link FixedBuilder}&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R size(int size) {&lt;br/&gt;
       Schema schema = Schema.createFixed(name(), super.doc(), space(), size);&lt;br/&gt;
       completeSchema(schema);&lt;br/&gt;
@@ -754,14 +823,14 @@ public R size(int size) {&lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro Enum type with optional properties, namespace, doc, and&lt;br/&gt;
    * aliases.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * Set properties with {@link #prop(String, String)}, namespace with&lt;br/&gt;
    * {@link #namespace(String)}, doc with {@link #doc(String)}, and aliases with&lt;br/&gt;
    * {@link #aliases(String[])}.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * The Enum schema is finalized when its required symbols are set via&lt;br/&gt;
    * {@link #symbols(String[])}.&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class EnumBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       NamespacedBuilder&amp;lt;R, EnumBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private EnumBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names, String name) {&lt;br/&gt;
@@ -779,7 +848,12 @@ private EnumBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names, String name) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Configure this enum type&apos;s symbols, and end its configuration. Populates the default if it was set.**/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Configure this enum type&apos;s symbols, and end its configuration. Populates the default if it was set.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param symbols One or more symbols to construct the enum&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R symbols(String... symbols) {&lt;br/&gt;
       Schema schema = Schema.createEnum(name(), doc(), space(),&lt;br/&gt;
           Arrays.asList(symbols), this.enumDefault);&lt;br/&gt;
@@ -787,7 +861,11 @@ public R symbols(String... symbols) {
       return context().complete(schema);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Set the default value of the enum. */&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Set the default value of the enum.&lt;br/&gt;
+     * @param enumDefault The default symbol&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public EnumBuilder&amp;lt;R&amp;gt; defaultSymbol(String enumDefault) {&lt;br/&gt;
       this.enumDefault = enumDefault;&lt;br/&gt;
       return self();&lt;br/&gt;
@@ -796,12 +874,12 @@ public R symbols(String... symbols) {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro Map type with optional properties.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * Set properties with {@link #prop(String, String)}.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * The Map schema&apos;s properties are finalized when {@link #values()} or&lt;br/&gt;
    * {@link #values(Schema)} is called.&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class MapBuilder&amp;lt;R&amp;gt; extends PropBuilder&amp;lt;MapBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private final Completion&amp;lt;R&amp;gt; context;&lt;br/&gt;
     private final NameContext names;&lt;br/&gt;
@@ -825,7 +903,9 @@ private MapBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
      * Return a type builder for configuring the map&apos;s nested values schema.&lt;br/&gt;
      * This builder will return control to the map&apos;s enclosing context when&lt;br/&gt;
      * complete.&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link TypeBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public TypeBuilder&amp;lt;R&amp;gt; values() {
       return new TypeBuilder&amp;lt;&amp;gt;(new MapCompletion&amp;lt;&amp;gt;(this, context), names);
     }&lt;br/&gt;
@@ -833,7 +913,9 @@ private MapBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Complete configuration of this map, setting the schema of the map values&lt;br/&gt;
      * to the schema provided. Returns control to the enclosing context.&lt;br/&gt;
-     **/&lt;br/&gt;
+     * @param valueSchema The schema to be set&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R values(Schema valueSchema) {
       return new MapCompletion&amp;lt;&amp;gt;(this, context).complete(valueSchema);
     }&lt;br/&gt;
@@ -841,12 +923,12 @@ public R values(Schema valueSchema) {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Builds an Avro Array type with optional properties.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * Set properties with {@link #prop(String, String)}.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * The Array schema&apos;s properties are finalized when {@link #items()} or&lt;br/&gt;
    * {@link #items(Schema)} is called.&lt;br/&gt;
-   **/&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class ArrayBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       PropBuilder&amp;lt;ArrayBuilder&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private final Completion&amp;lt;R&amp;gt; context;&lt;br/&gt;
@@ -871,7 +953,9 @@ public ArrayBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
      * Return a type builder for configuring the array&apos;s nested items schema.&lt;br/&gt;
      * This builder will return control to the array&apos;s enclosing context when&lt;br/&gt;
      * complete.&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return The nested items of the schema&lt;br/&gt;
+     */&lt;br/&gt;
     public TypeBuilder&amp;lt;R&amp;gt; items() {
       return new TypeBuilder&amp;lt;&amp;gt;(new ArrayCompletion&amp;lt;&amp;gt;(this, context), names);
     }&lt;br/&gt;
@@ -879,7 +963,10 @@ public ArrayBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Complete configuration of this array, setting the schema of the array&lt;br/&gt;
      * items to the schema provided. Returns control to the enclosing context.&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param itemsSchema Schema to complete the configuration&lt;br/&gt;
+     * @return The enclosing context control&lt;br/&gt;
+     */&lt;br/&gt;
     public R items(Schema itemsSchema) {
       return new ArrayCompletion&amp;lt;&amp;gt;(this, context).complete(itemsSchema);
     }&lt;br/&gt;
@@ -888,13 +975,12 @@ public R items(Schema itemsSchema) {&lt;br/&gt;
   /**&lt;br/&gt;
    * internal class for passing the naming context around. This allows for the&lt;br/&gt;
    * following:&lt;br/&gt;
-   * &amp;lt;li&amp;gt;Cache and re-use primitive schemas when they do not set&lt;br/&gt;
-   * properties.&amp;lt;/li&amp;gt;&lt;br/&gt;
-   * &amp;lt;li&amp;gt;Provide a default namespace for nested contexts (as&lt;br/&gt;
-   * the JSON Schema spec does).&amp;lt;/li&amp;gt;&lt;br/&gt;
-   * &amp;lt;li&amp;gt;Allow previously defined named types or primitive types&lt;br/&gt;
-   * to be referenced by name.&amp;lt;/li&amp;gt;&lt;br/&gt;
-   **/&lt;br/&gt;
+   * &amp;lt;ul&amp;gt;&lt;br/&gt;
+   * &amp;lt;li&amp;gt;Cache and re-use primitive schemas when they do not set properties.&amp;lt;/li&amp;gt;&lt;br/&gt;
+   * &amp;lt;li&amp;gt;Provide a default namespace for nested contexts (as the JSON Schema spec does).&amp;lt;/li&amp;gt;&lt;br/&gt;
+   * &amp;lt;li&amp;gt;Allow previously defined named types or primitive types to be referenced by name.&amp;lt;/li&amp;gt;&lt;br/&gt;
+   * &amp;lt;/ul&amp;gt;&lt;br/&gt;
+   */&lt;br/&gt;
   private static class NameContext {&lt;br/&gt;
     private static final Set&amp;lt;String&amp;gt; PRIMITIVES = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
     static {&lt;br/&gt;
@@ -973,15 +1059,17 @@ private String resolveName(String name, String space) {&lt;br/&gt;
    * A common API for building types within a context. BaseTypeBuilder can build&lt;br/&gt;
    * all types other than Unions. {@link TypeBuilder} can additionally build&lt;br/&gt;
    * Unions.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * The builder has two contexts:&lt;br/&gt;
+   * &amp;lt;ul&amp;gt;&lt;br/&gt;
    * &amp;lt;li&amp;gt;A naming context provides a default namespace and allows for previously&lt;br/&gt;
    * defined named types to be referenced from {@link #type(String)}&amp;lt;/li&amp;gt;&lt;br/&gt;
    * &amp;lt;li&amp;gt;A completion context representing the scope that the builder was&lt;br/&gt;
    * created in. A builder created in a nested context (for example,&lt;br/&gt;
    * {@link MapBuilder#values()} will have a completion context assigned by the&lt;br/&gt;
    * {@link MapBuilder}&amp;lt;/li&amp;gt;&lt;br/&gt;
-   **/&lt;br/&gt;
+   * &amp;lt;/ul&amp;gt;&lt;br/&gt;
+   */&lt;br/&gt;
   public static class BaseTypeBuilder&amp;lt;R&amp;gt; {&lt;br/&gt;
     private final Completion&amp;lt;R&amp;gt; context;&lt;br/&gt;
     private final NameContext names;&lt;br/&gt;
@@ -991,7 +1079,12 @@ private BaseTypeBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {
       this.names = names;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Use the schema provided as the type. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Use the schema provided as the type.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param schema The provided schema&lt;br/&gt;
+     * @return The completed record&lt;br/&gt;
+     */&lt;br/&gt;
     public final R type(Schema schema) {
       return context.complete(schema);
     }&lt;br/&gt;
@@ -999,11 +1092,14 @@ public final R type(Schema schema) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Look up the type by name. This type must be previously defined in the&lt;br/&gt;
      * context of this builder.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * The name may be fully qualified or a short name. If it is a short name,&lt;br/&gt;
      * the default namespace of the current context will additionally be&lt;br/&gt;
      * searched.&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The lookup name&lt;br/&gt;
+     * @return The completed record&lt;br/&gt;
+     */&lt;br/&gt;
     public final R type(String name) {
       return type(name, null);
     }&lt;br/&gt;
@@ -1011,12 +1107,16 @@ public final R type(String name) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Look up the type by name and namespace. This type must be previously&lt;br/&gt;
      * defined in the context of this builder.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * The name may be fully qualified or a short name. If it is a fully&lt;br/&gt;
      * qualified name, the namespace provided is ignored. If it is a short name,&lt;br/&gt;
      * the namespace provided is used if not null, else the default namespace of&lt;br/&gt;
      * the current context will be used.&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The lookup name&lt;br/&gt;
+     * @param namespace The namespace to search in&lt;br/&gt;
+     * @return The completed record&lt;br/&gt;
+     */&lt;br/&gt;
     public final R type(String name, String namespace) {
       return type(names.get(name, namespace));
     }&lt;br/&gt;
@@ -1026,6 +1126,8 @@ public final R type(String name, String namespace) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * booleanBuilder().endBoolean();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Record&lt;br/&gt;
      */&lt;br/&gt;
     public final R booleanType() {&lt;br/&gt;
       return booleanBuilder().endBoolean();&lt;br/&gt;
@@ -1034,6 +1136,8 @@ public final R booleanType() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a boolean type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #booleanType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link BooleanBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final BooleanBuilder&amp;lt;R&amp;gt; booleanBuilder() {&lt;br/&gt;
       return BooleanBuilder.create(context, names);&lt;br/&gt;
@@ -1044,6 +1148,8 @@ public final R booleanType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * intBuilder().endInt();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Record&lt;br/&gt;
      */&lt;br/&gt;
     public final R intType() {&lt;br/&gt;
       return intBuilder().endInt();&lt;br/&gt;
@@ -1052,6 +1158,8 @@ public final R intType() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build an int type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #intType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link IntBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final IntBuilder&amp;lt;R&amp;gt; intBuilder() {&lt;br/&gt;
       return IntBuilder.create(context, names);&lt;br/&gt;
@@ -1062,6 +1170,8 @@ public final R intType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * longBuilder().endLong();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Record&lt;br/&gt;
      */&lt;br/&gt;
     public final R longType() {&lt;br/&gt;
       return longBuilder().endLong();&lt;br/&gt;
@@ -1070,6 +1180,8 @@ public final R longType() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a long type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #longType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link LongBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final LongBuilder&amp;lt;R&amp;gt; longBuilder() {&lt;br/&gt;
       return LongBuilder.create(context, names);&lt;br/&gt;
@@ -1080,6 +1192,8 @@ public final R longType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * floatBuilder().endFloat();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
      */&lt;br/&gt;
     public final R floatType() {&lt;br/&gt;
       return floatBuilder().endFloat();&lt;br/&gt;
@@ -1088,6 +1202,8 @@ public final R floatType() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a float type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #floatType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link FloatBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final FloatBuilder&amp;lt;R&amp;gt; floatBuilder() {&lt;br/&gt;
       return FloatBuilder.create(context, names);&lt;br/&gt;
@@ -1098,6 +1214,8 @@ public final R floatType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * doubleBuilder().endDouble();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Record&lt;br/&gt;
      */&lt;br/&gt;
     public final R doubleType() {&lt;br/&gt;
       return doubleBuilder().endDouble();&lt;br/&gt;
@@ -1106,6 +1224,8 @@ public final R doubleType() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a double type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #doubleType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link DoubleBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final DoubleBuilder&amp;lt;R&amp;gt; doubleBuilder() {&lt;br/&gt;
       return DoubleBuilder.create(context, names);&lt;br/&gt;
@@ -1116,6 +1236,8 @@ public final R doubleType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * stringBuilder().endString();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Record&lt;br/&gt;
      */&lt;br/&gt;
     public final R stringType() {&lt;br/&gt;
       return stringBuilder().endString();&lt;br/&gt;
@@ -1124,6 +1246,8 @@ public final R stringType() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a string type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #stringType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link StringBldr}&lt;br/&gt;
      */&lt;br/&gt;
     public final StringBldr&amp;lt;R&amp;gt; stringBuilder() {&lt;br/&gt;
       return StringBldr.create(context, names);&lt;br/&gt;
@@ -1134,6 +1258,8 @@ public final R stringType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * bytesBuilder().endBytes();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Record&lt;br/&gt;
      */&lt;br/&gt;
     public final R bytesType() {&lt;br/&gt;
       return bytesBuilder().endBytes();&lt;br/&gt;
@@ -1142,6 +1268,8 @@ public final R bytesType() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a bytes type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #bytesType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link BytesBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final BytesBuilder&amp;lt;R&amp;gt; bytesBuilder() {&lt;br/&gt;
       return BytesBuilder.create(context, names);&lt;br/&gt;
@@ -1152,6 +1280,8 @@ public final R bytesType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * nullBuilder().endNull();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return Record&lt;br/&gt;
      */&lt;br/&gt;
     public final R nullType() {&lt;br/&gt;
       return nullBuilder().endNull();&lt;br/&gt;
@@ -1160,6 +1290,8 @@ public final R nullType() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a null type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #nullType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link NullBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final NullBuilder&amp;lt;R&amp;gt; nullBuilder() {&lt;br/&gt;
       return NullBuilder.create(context, names);&lt;br/&gt;
@@ -1173,12 +1305,15 @@ public final R nullType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * {&quot;type&quot;:&quot;map&quot;, &quot;values&quot;:&quot;int&quot;}&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link MapBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final MapBuilder&amp;lt;R&amp;gt; map() {
       return MapBuilder.create(context, names);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro array type  Example usage:&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro array type  Example usage:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * array().items().longType()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
@@ -1186,12 +1321,15 @@ public final R nullType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * {&quot;type&quot;:&quot;array&quot;, &quot;values&quot;:&quot;long&quot;}&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link ArrayBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final ArrayBuilder&amp;lt;R&amp;gt; array() {
       return ArrayBuilder.create(context, names);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro fixed type. Example usage:&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro fixed type. Example usage:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * fixed(&quot;com.foo.IPv4&quot;).size(4)&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
@@ -1199,7 +1337,10 @@ public final R nullType() {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * {&quot;type&quot;:&quot;fixed&quot;, &quot;name&quot;:&quot;com.foo.IPv4&quot;, &quot;size&quot;:4}&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the field&lt;br/&gt;
+     * @return {@link FixedBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FixedBuilder&amp;lt;R&amp;gt; fixed(String name) {
       return FixedBuilder.create(context, names, name);
     }&lt;br/&gt;
@@ -1215,7 +1356,10 @@ public final R nullType() {
      *  &quot;doc&quot;:&quot;card suit names&quot;, &quot;symbols&quot;:[
      *    &quot;HEART&quot;, &quot;SPADE&quot;, &quot;DIAMOND&quot;, &quot;CLUB&quot;], &quot;default&quot;:&quot;HEART&quot;}&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the field&lt;br/&gt;
+     * @return {@link EnumBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final EnumBuilder&amp;lt;R&amp;gt; enumeration(String name) {
       return EnumBuilder.create(context, names, name);
     }&lt;br/&gt;
@@ -1238,49 +1382,65 @@ public final R nullType() {
      *     ]}&lt;br/&gt;
      *   ]}&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the field&lt;br/&gt;
+     * @return {@link RecordBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final RecordBuilder&amp;lt;R&amp;gt; record(String name) {
       return RecordBuilder.create(context, names, name);
     }&lt;br/&gt;
 &lt;br/&gt;
     /** Build an Avro union schema type. Example usage:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;unionOf().stringType().and().bytesType().endUnion()&amp;lt;/pre&amp;gt;&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link BaseTypeBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     protected BaseTypeBuilder&amp;lt;UnionAccumulator&amp;lt;R&amp;gt;&amp;gt; unionOf() {
       return UnionBuilder.create(context, names);
     }&lt;br/&gt;
 &lt;br/&gt;
     /** A shortcut for building a union of a type and null.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * For example, the code snippets below are equivalent:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;nullable().booleanType()&amp;lt;/pre&amp;gt;&lt;br/&gt;
      * &amp;lt;pre&amp;gt;unionOf().booleanType().and().nullType().endUnion()&amp;lt;/pre&amp;gt;&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link BaseTypeBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     protected BaseTypeBuilder&amp;lt;R&amp;gt; nullable() {
       return new BaseTypeBuilder&amp;lt;&amp;gt;(new NullableCompletion&amp;lt;&amp;gt;(context), names);
     }&lt;br/&gt;
 &lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** A Builder for creating any Avro schema type.&lt;br/&gt;
-   **/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * A Builder for creating any Avro schema type.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class TypeBuilder&amp;lt;R&amp;gt; extends BaseTypeBuilder&amp;lt;R&amp;gt; {&lt;br/&gt;
     private TypeBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {
       super(context, names);
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return {@link BaseTypeBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     @Override&lt;br/&gt;
     public BaseTypeBuilder&amp;lt;UnionAccumulator&amp;lt;R&amp;gt;&amp;gt; unionOf() {
       return super.unionOf();
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return {@link BaseTypeBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     @Override&lt;br/&gt;
     public BaseTypeBuilder&amp;lt;R&amp;gt; nullable() {
       return super.nullable();
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** A special builder for unions.  Unions cannot nest unions directly **/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * A special builder for unions.  Unions cannot nest unions directly&lt;br/&gt;
+   */&lt;br/&gt;
   private static final class UnionBuilder&amp;lt;R&amp;gt; extends&lt;br/&gt;
       BaseTypeBuilder&amp;lt;UnionAccumulator&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private UnionBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names) {&lt;br/&gt;
@@ -1300,11 +1460,11 @@ private UnionBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names, List&amp;lt;Schema&amp;gt; sche&lt;br/&gt;
    * A special Builder for Record fields. The API is very similar to&lt;br/&gt;
    * {@link BaseTypeBuilder}. However, fields have their own names, properties,&lt;br/&gt;
    * and default values.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * The methods on this class create builder instances that return their&lt;br/&gt;
    * control to the {@link FieldAssembler} of the enclosing record context after&lt;br/&gt;
    * configuring a default for the field.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   * &amp;lt;br&amp;gt;&lt;br/&gt;
    * For example, an int field with default value 1:&lt;br/&gt;
    * &amp;lt;pre&amp;gt;&lt;br/&gt;
    * intSimple().withDefault(1);&lt;br/&gt;
@@ -1330,6 +1490,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * booleanBuilder().endBoolean();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link BooleanDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public final BooleanDefault&amp;lt;R&amp;gt; booleanType() {&lt;br/&gt;
       return booleanBuilder().endBoolean();&lt;br/&gt;
@@ -1338,6 +1500,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a boolean type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #booleanType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link BooleanBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final BooleanBuilder&amp;lt;BooleanDefault&amp;lt;R&amp;gt;&amp;gt; booleanBuilder() {&lt;br/&gt;
       return BooleanBuilder.create(wrap(new BooleanDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1348,6 +1512,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * intBuilder().endInt();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link IntDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public final IntDefault&amp;lt;R&amp;gt; intType() {&lt;br/&gt;
       return intBuilder().endInt();&lt;br/&gt;
@@ -1356,6 +1522,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     /**&lt;br/&gt;
      * Build an int type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #intType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link IntBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final IntBuilder&amp;lt;IntDefault&amp;lt;R&amp;gt;&amp;gt; intBuilder() {&lt;br/&gt;
       return IntBuilder.create(wrap(new IntDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1366,6 +1534,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * longBuilder().endLong();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link LongDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public final LongDefault&amp;lt;R&amp;gt; longType() {&lt;br/&gt;
       return longBuilder().endLong();&lt;br/&gt;
@@ -1374,6 +1544,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a long type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #longType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link LongBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final LongBuilder&amp;lt;LongDefault&amp;lt;R&amp;gt;&amp;gt; longBuilder() {&lt;br/&gt;
       return LongBuilder.create(wrap(new LongDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1384,6 +1556,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * floatBuilder().endFloat();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link FloatDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public final FloatDefault&amp;lt;R&amp;gt; floatType() {&lt;br/&gt;
       return floatBuilder().endFloat();&lt;br/&gt;
@@ -1392,6 +1566,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a float type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #floatType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link FloatBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final FloatBuilder&amp;lt;FloatDefault&amp;lt;R&amp;gt;&amp;gt; floatBuilder() {&lt;br/&gt;
       return FloatBuilder.create(wrap(new FloatDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1402,6 +1578,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * doubleBuilder().endDouble();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link DoubleDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public final DoubleDefault&amp;lt;R&amp;gt; doubleType() {&lt;br/&gt;
       return doubleBuilder().endDouble();&lt;br/&gt;
@@ -1410,6 +1588,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a double type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #doubleType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link DoubleBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final DoubleBuilder&amp;lt;DoubleDefault&amp;lt;R&amp;gt;&amp;gt; doubleBuilder() {&lt;br/&gt;
       return DoubleBuilder.create(wrap(new DoubleDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1420,6 +1600,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * stringBuilder().endString();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link StringDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public final StringDefault&amp;lt;R&amp;gt; stringType() {&lt;br/&gt;
       return stringBuilder().endString();&lt;br/&gt;
@@ -1428,6 +1610,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a string type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #stringType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link StringBldr}&lt;br/&gt;
      */&lt;br/&gt;
     public final StringBldr&amp;lt;StringDefault&amp;lt;R&amp;gt;&amp;gt; stringBuilder() {&lt;br/&gt;
       return StringBldr.create(wrap(new StringDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1438,6 +1622,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * bytesBuilder().endBytes();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link BytesDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public final BytesDefault&amp;lt;R&amp;gt; bytesType() {&lt;br/&gt;
       return bytesBuilder().endBytes();&lt;br/&gt;
@@ -1446,6 +1632,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a bytes type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #bytesType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link BytesBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final BytesBuilder&amp;lt;BytesDefault&amp;lt;R&amp;gt;&amp;gt; bytesBuilder() {&lt;br/&gt;
       return BytesBuilder.create(wrap(new BytesDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1456,6 +1644,8 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * nullBuilder().endNull();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link NullDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public final NullDefault&amp;lt;R&amp;gt; nullType() {&lt;br/&gt;
       return nullBuilder().endNull();&lt;br/&gt;
@@ -1464,32 +1654,57 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a null type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #nullType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link NullBuilder}&lt;br/&gt;
      */&lt;br/&gt;
     public final NullBuilder&amp;lt;NullDefault&amp;lt;R&amp;gt;&amp;gt; nullBuilder() {
       return NullBuilder.create(wrap(new NullDefault&amp;lt;&amp;gt;(bldr)), names);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro map type **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro map type&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link MapBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final MapBuilder&amp;lt;MapDefault&amp;lt;R&amp;gt;&amp;gt; map() {
       return MapBuilder.create(wrap(new MapDefault&amp;lt;&amp;gt;(bldr)), names);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro array type **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro array type&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link ArrayBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final ArrayBuilder&amp;lt;ArrayDefault&amp;lt;R&amp;gt;&amp;gt; array() {
       return ArrayBuilder.create(wrap(new ArrayDefault&amp;lt;&amp;gt;(bldr)), names);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro fixed type. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro fixed type&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the type&lt;br/&gt;
+     * @return {@link FixedBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FixedBuilder&amp;lt;FixedDefault&amp;lt;R&amp;gt;&amp;gt; fixed(String name) {
       return FixedBuilder.create(wrap(new FixedDefault&amp;lt;&amp;gt;(bldr)), names, name);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro enum type. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro enum type.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the enumeration&lt;br/&gt;
+     * @return {@link EnumBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final EnumBuilder&amp;lt;EnumDefault&amp;lt;R&amp;gt;&amp;gt; enumeration(String name) {
       return EnumBuilder.create(wrap(new EnumDefault&amp;lt;&amp;gt;(bldr)), names, name);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro record type. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro record type.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the record&lt;br/&gt;
+     * @return {@link RecordBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public final RecordBuilder&amp;lt;RecordDefault&amp;lt;R&amp;gt;&amp;gt; record(String name) {
       return RecordBuilder.create(wrap(new RecordDefault&amp;lt;&amp;gt;(bldr)), names, name);
     }&lt;br/&gt;
@@ -1503,14 +1718,20 @@ protected BaseFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr, CompletionWrapper wrapper)&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** FieldTypeBuilder adds {@link #unionOf()}, {@link #nullable()}, and {@link #optional()}&lt;br/&gt;
-   * to BaseFieldTypeBuilder. **/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * FieldTypeBuilder adds {@link #unionOf()}, {@link #nullable()}, and {@link #optional()}&lt;br/&gt;
+   * to BaseFieldTypeBuilder.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final class FieldTypeBuilder&amp;lt;R&amp;gt; extends BaseFieldTypeBuilder&amp;lt;R&amp;gt; {&lt;br/&gt;
     private FieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {
       super(bldr, null);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro union schema type. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro union schema type.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionFieldTypeBuilder&lt;br/&gt;
+     */&lt;br/&gt;
     public UnionFieldTypeBuilder&amp;lt;R&amp;gt; unionOf() {
       return new UnionFieldTypeBuilder&amp;lt;&amp;gt;(bldr);
     }&lt;br/&gt;
@@ -1518,21 +1739,25 @@ private FieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * A shortcut for building a union of a type and null, with an optional default&lt;br/&gt;
      * value of the non-null type.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * For example, the two code snippets below are equivalent:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;nullable().booleanType().booleanDefault(true)&amp;lt;/pre&amp;gt;&lt;br/&gt;
      * &amp;lt;pre&amp;gt;unionOf().booleanType().and().nullType().endUnion().booleanDefault(true)&amp;lt;/pre&amp;gt;&lt;br/&gt;
-     **/&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return BaseFieldTypeBuilder&lt;br/&gt;
+     */&lt;br/&gt;
     public BaseFieldTypeBuilder&amp;lt;R&amp;gt; nullable() {
       return new BaseFieldTypeBuilder&amp;lt;&amp;gt;(bldr, new NullableCompletionWrapper());
     }&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * A shortcut for building a union of null and a type, with a null default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * For example, the two code snippets below are equivalent:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;optional().booleanType()&amp;lt;/pre&amp;gt;&lt;br/&gt;
      * &amp;lt;pre&amp;gt;unionOf().nullType().and().booleanType().endUnion().nullDefault()&amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return BaseTypeBuilder&lt;br/&gt;
      */&lt;br/&gt;
     public BaseTypeBuilder&amp;lt;FieldAssembler&amp;lt;R&amp;gt;&amp;gt; optional() {&lt;br/&gt;
       return new BaseTypeBuilder&amp;lt;&amp;gt;(&lt;br/&gt;
@@ -1557,6 +1782,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * booleanBuilder().endBoolean();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionAccumulator&lt;br/&gt;
      */&lt;br/&gt;
     public UnionAccumulator&amp;lt;BooleanDefault&amp;lt;R&amp;gt;&amp;gt; booleanType() {&lt;br/&gt;
       return booleanBuilder().endBoolean();&lt;br/&gt;
@@ -1565,6 +1792,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a boolean type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #booleanType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return BooleanBuilder&lt;br/&gt;
      */&lt;br/&gt;
     public BooleanBuilder&amp;lt;UnionAccumulator&amp;lt;BooleanDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; booleanBuilder() {&lt;br/&gt;
       return BooleanBuilder.create(completion(new BooleanDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1575,6 +1804,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * intBuilder().endInt();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionAccumulator&lt;br/&gt;
      */&lt;br/&gt;
     public UnionAccumulator&amp;lt;IntDefault&amp;lt;R&amp;gt;&amp;gt; intType() {&lt;br/&gt;
       return intBuilder().endInt();&lt;br/&gt;
@@ -1583,6 +1814,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build an int type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #intType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return IntBuilder&lt;br/&gt;
      */&lt;br/&gt;
     public IntBuilder&amp;lt;UnionAccumulator&amp;lt;IntDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; intBuilder() {&lt;br/&gt;
       return IntBuilder.create(completion(new IntDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1593,6 +1826,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * longBuilder().endLong();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionAccumulator&lt;br/&gt;
      */&lt;br/&gt;
     public UnionAccumulator&amp;lt;LongDefault&amp;lt;R&amp;gt;&amp;gt; longType() {&lt;br/&gt;
       return longBuilder().endLong();&lt;br/&gt;
@@ -1601,6 +1836,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a long type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #longType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return LongBuilder&lt;br/&gt;
      */&lt;br/&gt;
     public LongBuilder&amp;lt;UnionAccumulator&amp;lt;LongDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; longBuilder() {&lt;br/&gt;
       return LongBuilder.create(completion(new LongDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1611,6 +1848,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * floatBuilder().endFloat();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionAccumulator&lt;br/&gt;
      */&lt;br/&gt;
     public UnionAccumulator&amp;lt;FloatDefault&amp;lt;R&amp;gt;&amp;gt; floatType() {&lt;br/&gt;
       return floatBuilder().endFloat();&lt;br/&gt;
@@ -1619,6 +1858,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a float type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #floatType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return FloatBuilder&lt;br/&gt;
      */&lt;br/&gt;
     public FloatBuilder&amp;lt;UnionAccumulator&amp;lt;FloatDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; floatBuilder() {&lt;br/&gt;
       return FloatBuilder.create(completion(new FloatDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1629,6 +1870,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * doubleBuilder().endDouble();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionAccumulator&lt;br/&gt;
      */&lt;br/&gt;
     public UnionAccumulator&amp;lt;DoubleDefault&amp;lt;R&amp;gt;&amp;gt; doubleType() {&lt;br/&gt;
       return doubleBuilder().endDouble();&lt;br/&gt;
@@ -1637,6 +1880,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a double type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #doubleType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return DoubleBuilder&lt;br/&gt;
      */&lt;br/&gt;
     public DoubleBuilder&amp;lt;UnionAccumulator&amp;lt;DoubleDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; doubleBuilder() {&lt;br/&gt;
       return DoubleBuilder.create(completion(new DoubleDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1647,6 +1892,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * stringBuilder().endString();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionAccumulator&lt;br/&gt;
      */&lt;br/&gt;
     public UnionAccumulator&amp;lt;StringDefault&amp;lt;R&amp;gt;&amp;gt; stringType() {&lt;br/&gt;
       return stringBuilder().endString();&lt;br/&gt;
@@ -1655,6 +1902,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a string type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #stringType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return StringBldr&lt;br/&gt;
      */&lt;br/&gt;
     public StringBldr&amp;lt;UnionAccumulator&amp;lt;StringDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; stringBuilder() {&lt;br/&gt;
       return StringBldr.create(completion(new StringDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1665,6 +1914,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * bytesBuilder().endBytes();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionAccumulator&lt;br/&gt;
      */&lt;br/&gt;
     public UnionAccumulator&amp;lt;BytesDefault&amp;lt;R&amp;gt;&amp;gt; bytesType() {&lt;br/&gt;
       return bytesBuilder().endBytes();&lt;br/&gt;
@@ -1673,6 +1924,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a bytes type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #bytesType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return BytesBuilder&lt;br/&gt;
      */&lt;br/&gt;
     public BytesBuilder&amp;lt;UnionAccumulator&amp;lt;BytesDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; bytesBuilder() {&lt;br/&gt;
       return BytesBuilder.create(completion(new BytesDefault&amp;lt;&amp;gt;(bldr)), names);&lt;br/&gt;
@@ -1683,6 +1936,8 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * nullBuilder().endNull();&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return UnionAccumulator&lt;br/&gt;
      */&lt;br/&gt;
     public UnionAccumulator&amp;lt;NullDefault&amp;lt;R&amp;gt;&amp;gt; nullType() {&lt;br/&gt;
       return nullBuilder().endNull();&lt;br/&gt;
@@ -1691,36 +1946,65 @@ private UnionFieldTypeBuilder(FieldBuilder&amp;lt;R&amp;gt; bldr) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Build a null type that can set custom properties. If custom properties&lt;br/&gt;
      * are not needed it is simpler to use {@link #nullType()}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return NullBuilder&lt;br/&gt;
      */&lt;br/&gt;
     public NullBuilder&amp;lt;UnionAccumulator&amp;lt;NullDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; nullBuilder() {
       return NullBuilder.create(completion(new NullDefault&amp;lt;&amp;gt;(bldr)), names);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro map type **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro map type&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return MapBuilder&lt;br/&gt;
+     */&lt;br/&gt;
     public MapBuilder&amp;lt;UnionAccumulator&amp;lt;MapDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; map() {
       return MapBuilder.create(completion(new MapDefault&amp;lt;&amp;gt;(bldr)), names);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro array type **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro array type&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return ArrayBuilder&lt;br/&gt;
+     */&lt;br/&gt;
     public ArrayBuilder&amp;lt;UnionAccumulator&amp;lt;ArrayDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; array() {
       return ArrayBuilder.create(completion(new ArrayDefault&amp;lt;&amp;gt;(bldr)), names);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro fixed type. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro fixed type.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the type&lt;br/&gt;
+     * @return {@link FixedBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public FixedBuilder&amp;lt;UnionAccumulator&amp;lt;FixedDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; fixed(String name) {
       return FixedBuilder.create(completion(new FixedDefault&amp;lt;&amp;gt;(bldr)), names, name);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro enum type. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro enum type.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the type&lt;br/&gt;
+     * @return EnumBuilder&lt;br/&gt;
+     */&lt;br/&gt;
     public EnumBuilder&amp;lt;UnionAccumulator&amp;lt;EnumDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; enumeration(String name) {
       return EnumBuilder.create(completion(new EnumDefault&amp;lt;&amp;gt;(bldr)), names, name);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Build an Avro record type. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Build an Avro record type.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the type&lt;br/&gt;
+     * @return RecordBuilder&lt;br/&gt;
+     */&lt;br/&gt;
     public RecordBuilder&amp;lt;UnionAccumulator&amp;lt;RecordDefault&amp;lt;R&amp;gt;&amp;gt;&amp;gt; record(String name) {
       return RecordBuilder.create(completion(new RecordDefault&amp;lt;&amp;gt;(bldr)), names, name);
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * @param context The completion context&lt;br/&gt;
+     * @return A completed UnionCompletion&lt;br/&gt;
+     */&lt;br/&gt;
     private &amp;lt;C&amp;gt; UnionCompletion&amp;lt;C&amp;gt; completion(Completion&amp;lt;C&amp;gt; context) {
       return new UnionCompletion&amp;lt;&amp;gt;(context, names, new ArrayList&amp;lt;&amp;gt;());
     }&lt;br/&gt;
@@ -1742,6 +2026,9 @@ private RecordBuilder(Completion&amp;lt;R&amp;gt; context, NameContext names, String name) {
       return this;
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return FieldAssembler&lt;br/&gt;
+     */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; fields() {&lt;br/&gt;
       Schema record = Schema.createRecord(name(), doc(), space(), false);&lt;br/&gt;
       // place the record in the name context, fields yet to be set.&lt;br/&gt;
@@ -1765,6 +2052,7 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Add a field with the given name.&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
      * @return A {@link FieldBuilder} for the given name.&lt;br/&gt;
      */&lt;br/&gt;
     public FieldBuilder&amp;lt;R&amp;gt; name(String fieldName) {&lt;br/&gt;
@@ -1773,10 +2061,12 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a boolean field with the given name and no default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;This is equivalent to:&lt;br/&gt;
+     * &amp;lt;br&amp;gt;This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().booleanType().noDefault()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name.&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; requiredBoolean(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().booleanType().noDefault();&lt;br/&gt;
@@ -1784,11 +2074,14 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating an optional boolean field: a union of null and&lt;br/&gt;
-     * boolean with null default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * boolean with null default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().optional().booleanType()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; optionalBoolean(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().optional().booleanType();&lt;br/&gt;
@@ -1797,12 +2090,16 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a nullable boolean field: a union of boolean and&lt;br/&gt;
      * null with an boolean default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      *&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      * name(fieldName).type().nullable().booleanType().booleanDefault(defaultVal)&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; nullableBoolean(String fieldName, boolean defaultVal) {&lt;br/&gt;
       return name(fieldName)&lt;br/&gt;
@@ -1811,10 +2108,13 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating an int field with the given name and no default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;This is equivalent to:&lt;br/&gt;
+     * &amp;lt;br&amp;gt;This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().intType().noDefault()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; requiredInt(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().intType().noDefault();&lt;br/&gt;
@@ -1822,11 +2122,14 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating an optional int field: a union of null and int&lt;br/&gt;
-     * with null default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with null default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().optional().intType()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; optionalInt(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().optional().intType();&lt;br/&gt;
@@ -1834,11 +2137,15 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a nullable int field: a union of int and null&lt;br/&gt;
-     * with an int default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with an int default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().nullable().intType().intDefault(defaultVal)&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; nullableInt(String fieldName, int defaultVal) {&lt;br/&gt;
       return name(fieldName).type().nullable().intType().intDefault(defaultVal);&lt;br/&gt;
@@ -1846,10 +2153,13 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a long field with the given name and no default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;This is equivalent to:&lt;br/&gt;
+     * &amp;lt;br&amp;gt;This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().longType().noDefault()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; requiredLong(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().longType().noDefault();&lt;br/&gt;
@@ -1857,11 +2167,14 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating an optional long field: a union of null and long&lt;br/&gt;
-     * with null default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with null default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().optional().longType()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; optionalLong(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().optional().longType();&lt;br/&gt;
@@ -1869,11 +2182,15 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a nullable long field: a union of long and null&lt;br/&gt;
-     * with a long default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with a long default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().nullable().longType().longDefault(defaultVal)&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; nullableLong(String fieldName, long defaultVal) {&lt;br/&gt;
       return name(fieldName).type().nullable().longType().longDefault(defaultVal);&lt;br/&gt;
@@ -1881,10 +2198,13 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a float field with the given name and no default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;This is equivalent to:&lt;br/&gt;
+     * &amp;lt;br&amp;gt;This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().floatType().noDefault()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; requiredFloat(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().floatType().noDefault();&lt;br/&gt;
@@ -1892,11 +2212,14 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating an optional float field: a union of null and float&lt;br/&gt;
-     * with null default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with null default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().optional().floatType()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; optionalFloat(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().optional().floatType();&lt;br/&gt;
@@ -1904,11 +2227,15 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a nullable float field: a union of float and null&lt;br/&gt;
-     * with a float default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with a float default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().nullable().floatType().floatDefault(defaultVal)&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; nullableFloat(String fieldName, float defaultVal) {&lt;br/&gt;
       return name(fieldName).type().nullable().floatType().floatDefault(defaultVal);&lt;br/&gt;
@@ -1916,10 +2243,13 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a double field with the given name and no default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;This is equivalent to:&lt;br/&gt;
+     * &amp;lt;br&amp;gt;This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().doubleType().noDefault()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; requiredDouble(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().doubleType().noDefault();&lt;br/&gt;
@@ -1927,11 +2257,14 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating an optional double field: a union of null and double&lt;br/&gt;
-     * with null default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with null default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().optional().doubleType()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; optionalDouble(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().optional().doubleType();&lt;br/&gt;
@@ -1939,11 +2272,15 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a nullable double field: a union of double and null&lt;br/&gt;
-     * with a double default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with a double default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().nullable().doubleType().doubleDefault(defaultVal)&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; nullableDouble(String fieldName, double defaultVal) {&lt;br/&gt;
       return name(fieldName).type().nullable().doubleType().doubleDefault(defaultVal);&lt;br/&gt;
@@ -1951,10 +2288,13 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a string field with the given name and no default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;This is equivalent to:&lt;br/&gt;
+     * &amp;lt;br&amp;gt;This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().stringType().noDefault()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; requiredString(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().stringType().noDefault();&lt;br/&gt;
@@ -1962,11 +2302,14 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating an optional string field: a union of null and string&lt;br/&gt;
-     * with null default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with null default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().optional().stringType()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; optionalString(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().optional().stringType();&lt;br/&gt;
@@ -1974,11 +2317,15 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a nullable string field: a union of string and null&lt;br/&gt;
-     * with a string default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with a string default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().nullable().stringType().stringDefault(defaultVal)&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; nullableString(String fieldName, String defaultVal) {&lt;br/&gt;
       return name(fieldName).type().nullable().stringType().stringDefault(defaultVal);&lt;br/&gt;
@@ -1986,10 +2333,13 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a bytes field with the given name and no default.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;This is equivalent to:&lt;br/&gt;
+     * &amp;lt;br&amp;gt;This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().bytesType().noDefault()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; requiredBytes(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().bytesType().noDefault();&lt;br/&gt;
@@ -1997,11 +2347,14 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating an optional bytes field: a union of null and bytes&lt;br/&gt;
-     * with null default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with null default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().optional().bytesType()&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; optionalBytes(String fieldName) {&lt;br/&gt;
       return name(fieldName).type().optional().bytesType();&lt;br/&gt;
@@ -2009,11 +2362,15 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Shortcut for creating a nullable bytes field: a union of bytes and null&lt;br/&gt;
-     * with a bytes default.&amp;lt;p/&amp;gt;&lt;br/&gt;
+     * with a bytes default.&amp;lt;br&amp;gt;&lt;br/&gt;
      * This is equivalent to:&lt;br/&gt;
      * &amp;lt;pre&amp;gt;&lt;br/&gt;
      *   name(fieldName).type().nullable().bytesType().bytesDefault(defaultVal)&lt;br/&gt;
      * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param fieldName The fieldname of the builder&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return A {@link FieldAssembler} for the given name, if available&lt;br/&gt;
      */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; nullableBytes(String fieldName, byte[] defaultVal) {&lt;br/&gt;
       return name(fieldName).type().nullable().bytesType().bytesDefault(defaultVal);&lt;br/&gt;
@@ -2022,6 +2379,8 @@ private FieldAssembler(Completion&amp;lt;R&amp;gt; context, NameContext names, Schema record)&lt;br/&gt;
     /**&lt;br/&gt;
      * End adding fields to this record, returning control&lt;br/&gt;
      * to the context that this record builder was created in.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return The closed record&lt;br/&gt;
      */&lt;br/&gt;
     public R endRecord() {&lt;br/&gt;
       record.setFields(fields);&lt;br/&gt;
@@ -2055,19 +2414,28 @@ private FieldBuilder(FieldAssembler&amp;lt;R&amp;gt; fields, NameContext names, String name) {
       this.fields = fields;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Set this field to have ascending order.  Ascending is the default **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Set this field to have ascending order.  Ascending is the default&lt;br/&gt;
+     * @return {@link FieldBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public FieldBuilder&amp;lt;R&amp;gt; orderAscending() {
       order = Schema.Field.Order.ASCENDING;
       return self();
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Set this field to have descending order.  Descending is the default **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Set this field to have descending order.  Descending is the default&lt;br/&gt;
+     * @return {@link FieldBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public FieldBuilder&amp;lt;R&amp;gt; orderDescending() {
       order = Schema.Field.Order.DESCENDING;
       return self();
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Set this field to ignore order.  **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Set this field to ignore order.&lt;br/&gt;
+     * @return {@link FieldBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public FieldBuilder&amp;lt;R&amp;gt; orderIgnore() {&lt;br/&gt;
       order = Schema.Field.Order.IGNORE;&lt;br/&gt;
       return self();&lt;br/&gt;
@@ -2086,6 +2454,9 @@ private FieldBuilder(FieldAssembler&amp;lt;R&amp;gt; fields, NameContext names, String name) {&lt;br/&gt;
      * Final step in configuring this field, finalizing name, namespace, alias,&lt;br/&gt;
      * and order.  Sets the field&apos;s type to the provided schema, returns a&lt;br/&gt;
      * {@link GenericDefault}.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param type The type of the schema&lt;br/&gt;
+     * @return {@link GenericDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public GenericDefault&amp;lt;R&amp;gt; type(Schema type) {&lt;br/&gt;
       return new GenericDefault&amp;lt;&amp;gt;(this, type);&lt;br/&gt;
@@ -2094,14 +2465,17 @@ private FieldBuilder(FieldAssembler&amp;lt;R&amp;gt; fields, NameContext names, String name) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Final step in configuring this field, finalizing name, namespace, alias,&lt;br/&gt;
      * and order. Sets the field&apos;s type to the schema by name reference.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * The name must correspond with a named schema that has already been&lt;br/&gt;
      * created in the context of this builder. The name may be a fully qualified&lt;br/&gt;
      * name, or a short name. If it is a short name, the namespace context of&lt;br/&gt;
      * this builder will be used.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * The name and namespace context rules are the same as the Avro schema JSON&lt;br/&gt;
      * specification.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the schema&lt;br/&gt;
+     * @return {@link GenericDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public GenericDefault&amp;lt;R&amp;gt; type(String name) {&lt;br/&gt;
       return type(name, null);&lt;br/&gt;
@@ -2110,15 +2484,19 @@ private FieldBuilder(FieldAssembler&amp;lt;R&amp;gt; fields, NameContext names, String name) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Final step in configuring this field, finalizing name, namespace, alias,&lt;br/&gt;
      * and order. Sets the field&apos;s type to the schema by name reference.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * The name must correspond with a named schema that has already been&lt;br/&gt;
      * created in the context of this builder. The name may be a fully qualified&lt;br/&gt;
      * name, or a short name. If it is a full name, the namespace is ignored. If&lt;br/&gt;
      * it is a short name, the namespace provided is used. If the namespace&lt;br/&gt;
      * provided is null, the namespace context of this builder will be used.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     * &amp;lt;br&amp;gt;&lt;br/&gt;
      * The name and namespace context rules are the same as the Avro schema JSON&lt;br/&gt;
      * specification.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name The name of the schema&lt;br/&gt;
+     * @param namespace The namespace of the schema&lt;br/&gt;
+     * @return {@link GenericDefault}&lt;br/&gt;
      */&lt;br/&gt;
     public GenericDefault&amp;lt;R&amp;gt; type(String name, String namespace) {&lt;br/&gt;
       Schema schema = names().get(name, namespace);&lt;br/&gt;
@@ -2147,7 +2525,7 @@ private FieldBuilder(FieldAssembler&amp;lt;R&amp;gt; fields, NameContext names, String name) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Abstract base class for field defaults. **/&lt;br/&gt;
+  /** Abstract base class for field defaults. */&lt;br/&gt;
   public static abstract class FieldDefault&amp;lt;R, S extends FieldDefault&amp;lt;R, S&amp;gt;&amp;gt; extends Completion&amp;lt;S&amp;gt; {&lt;br/&gt;
     private final FieldBuilder&amp;lt;R&amp;gt; field;&lt;br/&gt;
     private Schema schema;&lt;br/&gt;
@@ -2155,7 +2533,10 @@ private FieldBuilder(FieldAssembler&amp;lt;R&amp;gt; fields, NameContext names, String name) {
       this.field = field;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with no default value **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with no default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; noDefault() {
       return field.completeField(schema);
     }&lt;br/&gt;
@@ -2173,13 +2554,17 @@ final S complete(Schema schema) {
     abstract S self();
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class BooleanDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, BooleanDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private BooleanDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; booleanDefault(boolean defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
@@ -2190,13 +2575,17 @@ private BooleanDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class IntDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, IntDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private IntDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; intDefault(int defaultVal) {       return super.usingDefault(defaultVal);     }&lt;br/&gt;
@@ -2207,13 +2596,17 @@ private IntDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class LongDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, LongDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private LongDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; longDefault(long defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
@@ -2224,13 +2617,17 @@ private LongDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class FloatDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, FloatDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private FloatDefault(FieldBuilder&amp;lt;R&amp;gt; field) {       super(field);     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; floatDefault(float defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
@@ -2241,13 +2638,17 @@ private FloatDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class DoubleDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, DoubleDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private DoubleDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; doubleDefault(double defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
@@ -2258,13 +2659,17 @@ private DoubleDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class StringDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, StringDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private StringDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided. Cannot be null. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided. Cannot be null.&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; stringDefault(String defaultVal) {       return super.usingDefault(defaultVal);     }&lt;br/&gt;
@@ -2275,25 +2680,37 @@ private StringDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class BytesDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, BytesDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private BytesDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; bytesDefault(byte[] defaultVal) {
       return super.usingDefault(ByteBuffer.wrap(defaultVal));
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; bytesDefault(ByteBuffer defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null.&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null.&lt;br/&gt;
      * The string is interpreted as a byte[], with each character code point&lt;br/&gt;
-     * value equalling the byte value, as in the Avro spec JSON default. **/&lt;br/&gt;
+     * value equalling the byte value, as in the Avro spec JSON default.&lt;br/&gt;
+     * @param defaultVal Default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; bytesDefault(String defaultVal) {       return super.usingDefault(defaultVal);     }&lt;br/&gt;
@@ -2304,13 +2721,16 @@ private BytesDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class NullDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, NullDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private NullDefault(FieldBuilder&amp;lt;R&amp;gt; field) {       super(field);     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with a default value of null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with a default value of null&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; nullDefault() {
       return super.usingDefault(null);
     }&lt;br/&gt;
@@ -2321,13 +2741,19 @@ private NullDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class MapDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, MapDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private MapDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null&lt;br/&gt;
+     * @param &amp;lt;K&amp;gt; The key type&lt;br/&gt;
+     * @param &amp;lt;V&amp;gt; The value type&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final &amp;lt;K, V&amp;gt; FieldAssembler&amp;lt;R&amp;gt; mapDefault(Map&amp;lt;K, V&amp;gt; defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
@@ -2338,13 +2764,19 @@ private MapDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class ArrayDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, ArrayDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private ArrayDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param &amp;lt;V&amp;gt; The field to construct&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final &amp;lt;V&amp;gt; FieldAssembler&amp;lt;R&amp;gt; arrayDefault(List&amp;lt;V&amp;gt; defaultVal) {       return super.usingDefault(defaultVal);     }&lt;br/&gt;
@@ -2355,25 +2787,39 @@ private ArrayDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class FixedDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, FixedDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private FixedDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; fixedDefault(byte[] defaultVal) {
       return super.usingDefault(ByteBuffer.wrap(defaultVal));
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; fixedDefault(ByteBuffer defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
 &lt;br/&gt;
     /** Completes this field with the default value provided, cannot be null.&lt;br/&gt;
      * The string is interpreted as a byte[], with each character code point&lt;br/&gt;
-     * value equalling the byte value, as in the Avro spec JSON default. **/&lt;br/&gt;
+     * value equalling the byte value, as in the Avro spec JSON default.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; fixedDefault(String defaultVal) {       return super.usingDefault(defaultVal);     }&lt;br/&gt;
@@ -2384,30 +2830,43 @@ private FixedDefault(FieldBuilder&amp;lt;R&amp;gt; field) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class EnumDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, EnumDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private EnumDefault(FieldBuilder&amp;lt;R&amp;gt; field) {       super(field);     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; enumDefault(String defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * @return itself&lt;br/&gt;
+     */&lt;br/&gt;
     @Override&lt;br/&gt;
     final EnumDefault&amp;lt;R&amp;gt; self() {       return this;     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Choose whether to use a default value for the field or not. **/&lt;br/&gt;
+  /** Choose whether to use a default value for the field or not. */&lt;br/&gt;
   public static class RecordDefault&amp;lt;R&amp;gt; extends FieldDefault&amp;lt;R, RecordDefault&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private RecordDefault(FieldBuilder&amp;lt;R&amp;gt; field) {
       super(field);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided, cannot be null **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided, cannot be null&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public final FieldAssembler&amp;lt;R&amp;gt; recordDefault(GenericRecord defaultVal) {
       return super.usingDefault(defaultVal);
     }&lt;br/&gt;
@@ -2426,13 +2885,22 @@ private GenericDefault(FieldBuilder&amp;lt;R&amp;gt; field, Schema schema) {
       this.schema = schema;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Do not use a default value for this field. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Do not use a default value for this field.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; noDefault() {
       return field.completeField(schema);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Completes this field with the default value provided.&lt;br/&gt;
-     * The value must conform to the schema of the field. **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Completes this field with the default value provided.&lt;br/&gt;
+     * The value must conform to the schema of the field.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param defaultVal The default value&lt;br/&gt;
+     * @return {@link FieldAssembler}&lt;br/&gt;
+     */&lt;br/&gt;
     public FieldAssembler&amp;lt;R&amp;gt; withDefault(Object defaultVal) {
       return field.completeField(schema, defaultVal);
     }&lt;br/&gt;
@@ -2471,9 +2939,11 @@ protected R complete(Schema schema) {&lt;br/&gt;
 &lt;br/&gt;
   private static class OptionalCompletion&amp;lt;R&amp;gt; extends Completion&amp;lt;FieldAssembler&amp;lt;R&amp;gt;&amp;gt; {&lt;br/&gt;
     private final FieldBuilder&amp;lt;R&amp;gt; bldr;&lt;br/&gt;
+&lt;br/&gt;
     public OptionalCompletion(FieldBuilder&amp;lt;R&amp;gt; bldr) {
       this.bldr = bldr;
     }&lt;br/&gt;
+&lt;br/&gt;
     @Override&lt;br/&gt;
     protected FieldAssembler&amp;lt;R&amp;gt; complete(Schema schema) {
       // wrap the schema as a union of null and the schema
@@ -2568,12 +3038,18 @@ private UnionAccumulator(Completion&amp;lt;R&amp;gt; context, NameContext names, List&amp;lt;Schema&amp;gt;
       this.schemas = schemas;
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Add an additional type to this union **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Add an additional type to this union&lt;br/&gt;
+     * @return {@link BaseTypeBuilder}&lt;br/&gt;
+     */&lt;br/&gt;
     public BaseTypeBuilder&amp;lt;UnionAccumulator&amp;lt;R&amp;gt;&amp;gt; and() {
       return new UnionBuilder&amp;lt;&amp;gt;(context, names, schemas);
     }&lt;br/&gt;
 &lt;br/&gt;
-    /** Complete this union **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Complete this union&lt;br/&gt;
+     * @return {@link R}&lt;br/&gt;
+     */&lt;br/&gt;
     public R endUnion() {&lt;br/&gt;
       Schema schema = Schema.createUnion(schemas);&lt;br/&gt;
       return context.complete(schema);&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/SchemaCompatibility.java b/lang/java/avro/src/main/java/org/apache/avro/SchemaCompatibility.java&lt;br/&gt;
index b1a499e73..9f3137d28 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/SchemaCompatibility.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/SchemaCompatibility.java&lt;br/&gt;
@@ -578,6 +578,12 @@ public static SchemaCompatibilityResult recursionInProgress() {&lt;br/&gt;
      * Returns a details object representing an incompatible schema pair, including error details.&lt;br/&gt;
      * @return a SchemaCompatibilityDetails object with INCOMPATIBLE SchemaCompatibilityType, and&lt;br/&gt;
      *         state representing the violating part.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param incompatibilityType {@link SchemaIncompatibilityType}&lt;br/&gt;
+     * @param readerFragment {@link Schema}&lt;br/&gt;
+     * @param writerFragment {@link Schema}&lt;br/&gt;
+     * @param message {@link String}&lt;br/&gt;
+     * @param location {@link List}&lt;br/&gt;
      */&lt;br/&gt;
     public static SchemaCompatibilityResult incompatible(&lt;br/&gt;
         SchemaIncompatibilityType incompatibilityType,&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/SchemaNormalization.java b/lang/java/avro/src/main/java/org/apache/avro/SchemaNormalization.java&lt;br/&gt;
index ed9659b47..864ce4646 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/SchemaNormalization.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/SchemaNormalization.java&lt;br/&gt;
@@ -32,8 +32,11 @@&lt;br/&gt;
 &lt;br/&gt;
   private SchemaNormalization() {}&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns &quot;Parsing Canonical Form&quot; of a schema as defined by Avro&lt;br/&gt;
-    * spec. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns &quot;Parsing Canonical Form&quot; of a schema as defined by Avro spec.&lt;br/&gt;
+   * @param s The input schema&lt;br/&gt;
+   * @return The canonical form as a string&lt;br/&gt;
+   */&lt;br/&gt;
   public static String toParsingForm(Schema s) {&lt;br/&gt;
     try {&lt;br/&gt;
       Map&amp;lt;String,String&amp;gt; env = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -44,20 +47,27 @@ public static String toParsingForm(Schema s) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns a fingerprint of a string of bytes.  This string is&lt;br/&gt;
-    * presumed to contain a canonical form of a schema.  The&lt;br/&gt;
-    * algorithm used to compute the fingerprint is selected by the&lt;br/&gt;
-    * argument &amp;lt;i&amp;gt;fpName&amp;lt;/i&amp;gt;.  If &amp;lt;i&amp;gt;fpName&amp;lt;/i&amp;gt; equals the string&lt;br/&gt;
-    * &amp;lt;code&amp;gt;&quot;CRC-64-AVRO&quot;&amp;lt;/code&amp;gt;, then the result of {@link #fingerprint64} is&lt;br/&gt;
-    * returned in little-endian format.  Otherwise, &amp;lt;i&amp;gt;fpName&amp;lt;/i&amp;gt; is&lt;br/&gt;
-    * used as an algorithm name for {@link
-    * MessageDigest#getInstance(String)}, which will throw&lt;br/&gt;
-    * &amp;lt;code&amp;gt;NoSuchAlgorithmException&amp;lt;/code&amp;gt; if it doesn&apos;t recognize&lt;br/&gt;
-    * the name.&lt;br/&gt;
-    * &amp;lt;p&amp;gt; Recommended Avro practice dictates that&lt;br/&gt;
-    * &amp;lt;code&amp;gt;&quot;CRC-64-AVRO&quot;&amp;lt;/code&amp;gt; is used for 64-bit fingerprints,&lt;br/&gt;
-    * &amp;lt;code&amp;gt;&quot;MD5&quot;&amp;lt;/code&amp;gt; is used for 128-bit fingerprints, and&lt;br/&gt;
-    * &amp;lt;code&amp;gt;&quot;SHA-256&quot;&amp;lt;/code&amp;gt; is used for 256-bit fingerprints. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   *  Returns a fingerprint of a string of bytes.  This string is&lt;br/&gt;
+   * presumed to contain a canonical form of a schema.  The&lt;br/&gt;
+   * algorithm used to compute the fingerprint is selected by the&lt;br/&gt;
+   * argument &amp;lt;i&amp;gt;fpName&amp;lt;/i&amp;gt;.  If &amp;lt;i&amp;gt;fpName&amp;lt;/i&amp;gt; equals the string&lt;br/&gt;
+   * &amp;lt;code&amp;gt;&quot;CRC-64-AVRO&quot;&amp;lt;/code&amp;gt;, then the result of {@link #fingerprint64} is&lt;br/&gt;
+   * returned in little-endian format.  Otherwise, &amp;lt;i&amp;gt;fpName&amp;lt;/i&amp;gt; is&lt;br/&gt;
+   * used as an algorithm name for {@link
+   * MessageDigest#getInstance(String)}, which will throw&lt;br/&gt;
+   * &amp;lt;code&amp;gt;NoSuchAlgorithmException&amp;lt;/code&amp;gt; if it doesn&apos;t recognize&lt;br/&gt;
+   * the name.&lt;br/&gt;
+   * &amp;lt;p&amp;gt;Recommended Avro practice dictates that&amp;lt;/p&amp;gt;&lt;br/&gt;
+   * &amp;lt;code&amp;gt;&quot;CRC-64-AVRO&quot;&amp;lt;/code&amp;gt; is used for 64-bit fingerprints,&lt;br/&gt;
+   * &amp;lt;code&amp;gt;&quot;MD5&quot;&amp;lt;/code&amp;gt; is used for 128-bit fingerprints, and&lt;br/&gt;
+   * &amp;lt;code&amp;gt;&quot;SHA-256&quot;&amp;lt;/code&amp;gt; is used for 256-bit fingerprints.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param fpName The fingerprint name&lt;br/&gt;
+   * @param data The Avro data as bytes&lt;br/&gt;
+   * @throws NoSuchAlgorithmException In case the algorithm isn&apos;t available&lt;br/&gt;
+   * @return The fingerprint as bytes&lt;br/&gt;
+   */&lt;br/&gt;
   public static byte[] fingerprint(String fpName, byte[] data)&lt;br/&gt;
     throws NoSuchAlgorithmException&lt;br/&gt;
   {&lt;br/&gt;
@@ -75,8 +85,10 @@ public static String toParsingForm(Schema s) {
     return md.digest(data);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns the 64-bit Rabin Fingerprint (as recommended in the Avro&lt;br/&gt;
-    * spec) of a byte string. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param data The data of the Avro message&lt;br/&gt;
+   * @return 64-bit Rabin Fingerprint (as recommended in the Avro spec) of a byte string.&lt;br/&gt;
+   */&lt;br/&gt;
   public static long fingerprint64(byte[] data) {&lt;br/&gt;
     long result = EMPTY64;&lt;br/&gt;
     for (byte b: data)&lt;br/&gt;
@@ -84,8 +96,13 @@ public static long fingerprint64(byte[] data) {     return result;   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns 
{@link #fingerprint} applied to the parsing canonical form&lt;br/&gt;
-    * of the supplied schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param fpName The fingerprint name&lt;br/&gt;
+   * @param s Avro schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws NoSuchAlgorithmException In case the selected algoritm isn&apos;t available&lt;br/&gt;
+   * @return {@link #fingerprint}
&lt;p&gt; applied to the parsing canonical form of the supplied schema.&lt;br/&gt;
+   */&lt;br/&gt;
   public static byte[] parsingFingerprint(String fpName, Schema s)&lt;br/&gt;
     throws NoSuchAlgorithmException&lt;br/&gt;
   {&lt;br/&gt;
@@ -94,8 +111,10 @@ public static long fingerprint64(byte[] data) {&lt;br/&gt;
     } catch (UnsupportedEncodingException e) &lt;/p&gt;
{ throw new RuntimeException(e); }
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns 
{@link #fingerprint64} applied to the parsing canonical form&lt;br/&gt;
-    * of the supplied schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param s The Avro schema&lt;br/&gt;
+   * @return {@link #fingerprint64}
&lt;p&gt; applied to the parsing canonical form of the supplied schema.&lt;br/&gt;
+   */&lt;br/&gt;
   public static long parsingFingerprint64(Schema s) {&lt;br/&gt;
     try {&lt;br/&gt;
       return fingerprint64(toParsingForm(s).getBytes(&quot;UTF-8&quot;));&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/SchemaValidationStrategy.java b/lang/java/avro/src/main/java/org/apache/avro/SchemaValidationStrategy.java&lt;br/&gt;
index f2efabe95..7b126b68c 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/SchemaValidationStrategy.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/SchemaValidationStrategy.java&lt;br/&gt;
@@ -23,13 +23,15 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;another.&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;What makes one schema compatible with another is not defined by the contract.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  */&lt;br/&gt;
 public interface SchemaValidationStrategy {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Validates that one schema is compatible with another.&lt;br/&gt;
    *&lt;br/&gt;
+   * @param toValidate The schema to be validated&lt;br/&gt;
+   * @param existing The current schema to check compatibility with&lt;/li&gt;
	&lt;li&gt;@throws SchemaValidationException if the schemas are not compatible.&lt;br/&gt;
    */&lt;br/&gt;
   void validate(Schema toValidate, Schema existing)&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/SchemaValidator.java b/lang/java/avro/src/main/java/org/apache/avro/SchemaValidator.java&lt;br/&gt;
index cf97bdb0d..5f22a6532 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/SchemaValidator.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/SchemaValidator.java&lt;br/&gt;
@@ -21,7 +21,7 @@&lt;br/&gt;
 /**&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;A SchemaValidator has one method, which validates that a 
{@link Schema}
&lt;p&gt; is&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;b&amp;gt;compatible&amp;lt;b/&amp;gt; with the other schemas provided.&lt;br/&gt;
+ * &amp;lt;b&amp;gt;compatible&amp;lt;/b&amp;gt; with the other schemas provided.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;/p&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;What makes one Schema compatible with another is not part of the interface&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/SchemaValidatorBuilder.java b/lang/java/avro/src/main/java/org/apache/avro/SchemaValidatorBuilder.java&lt;br/&gt;
index af3b48b94..41bf314ef 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/SchemaValidatorBuilder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/SchemaValidatorBuilder.java&lt;br/&gt;
@@ -34,6 +34,8 @@ public SchemaValidatorBuilder strategy(SchemaValidationStrategy strategy) {&lt;br/&gt;
   /**&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Use a strategy that validates that a schema can be used to read existing&lt;/li&gt;
	&lt;li&gt;schema(s) according to the Avro default schema resolution.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return 
{@link SchemaValidatorBuilder}&lt;br/&gt;
    */&lt;br/&gt;
   public SchemaValidatorBuilder canReadStrategy() {&lt;br/&gt;
     this.strategy = new ValidateCanRead();&lt;br/&gt;
@@ -43,6 +45,8 @@ public SchemaValidatorBuilder canReadStrategy() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Use a strategy that validates that a schema can be read by existing&lt;br/&gt;
    * schema(s) according to the Avro default schema resolution.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return {@link SchemaValidatorBuilder}
&lt;p&gt;    */&lt;br/&gt;
   public SchemaValidatorBuilder canBeReadStrategy() {&lt;br/&gt;
     this.strategy = new ValidateCanBeRead();&lt;br/&gt;
@@ -52,17 +56,25 @@ public SchemaValidatorBuilder canBeReadStrategy() {&lt;br/&gt;
   /**&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Use a strategy that validates that a schema can read existing schema(s),&lt;/li&gt;
	&lt;li&gt;and vice-versa, according to the Avro default schema resolution.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return 
{@link SchemaValidatorBuilder}
&lt;p&gt;    */&lt;br/&gt;
   public SchemaValidatorBuilder mutualReadStrategy() &lt;/p&gt;
{
     this.strategy = new ValidateMutualRead();
     return this;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * @return &lt;/p&gt;
{@link SchemaValidator}&lt;br/&gt;
+   */&lt;br/&gt;
   public SchemaValidator validateLatest() {
     valid();
     return new ValidateLatest(strategy);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return {@link SchemaValidator}
&lt;p&gt;+   */&lt;br/&gt;
   public SchemaValidator validateAll() {&lt;br/&gt;
     valid();&lt;br/&gt;
     return new ValidateAll(strategy);&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/file/DataFileWriter.java b/lang/java/avro/src/main/java/org/apache/avro/file/DataFileWriter.java&lt;br/&gt;
index 37c46137d..07ee44985 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/file/DataFileWriter.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/file/DataFileWriter.java&lt;br/&gt;
@@ -354,7 +354,7 @@ private void writeIfBlockFull() throws IOException {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;of the two files are compatible, data blocks are copied directly without&lt;/li&gt;
	&lt;li&gt;decompression.  If the codecs are not compatible, blocks from otherFile&lt;/li&gt;
	&lt;li&gt;are uncompressed and then compressed using this file&apos;s codec.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;If the recompress flag is set all blocks are decompressed and then compressed&lt;/li&gt;
	&lt;li&gt;using this file&apos;s codec.  This is useful when the two files have compatible&lt;/li&gt;
	&lt;li&gt;compression codecs but different codec options.  For example, one might&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/file/FileReader.java b/lang/java/avro/src/main/java/org/apache/avro/file/FileReader.java&lt;br/&gt;
index 1c58f1e8d..0f96aada1 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/file/FileReader.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/file/FileReader.java&lt;br/&gt;
@@ -23,27 +23,39 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.apache.avro.Schema;&lt;/p&gt;

&lt;p&gt;-/** Interface for reading data from a file. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Interface for reading data from a file.&lt;br/&gt;
+ */&lt;br/&gt;
 public interface FileReader&amp;lt;D&amp;gt; extends Iterator&amp;lt;D&amp;gt;, Iterable&amp;lt;D&amp;gt;, Closeable {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return the schema for data in this file. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the schema for data in this file.&lt;br/&gt;
+   */&lt;br/&gt;
   Schema getSchema();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Read the next datum from the file.&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read the next datum from the file.&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param reuse an instance to reuse.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws NoSuchElementException if no more remain in the file.&lt;br/&gt;
+   * @throws java.util.NoSuchElementException if no more remain in the file.&lt;br/&gt;
    */&lt;br/&gt;
   D next(D reuse) throws IOException;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Move to the next synchronization point after a position. To process a&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Move to the next synchronization point after a position. To process a&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;range of file entires, call this with the starting position, then check&lt;/li&gt;
	&lt;li&gt;{@link #pastSync(long)}
&lt;p&gt; with the end point before each call to &lt;/p&gt;
{@link
-   * #next()}
&lt;p&gt;. */&lt;br/&gt;
+   * #next()}.&lt;br/&gt;
+   */&lt;br/&gt;
   void sync(long position) throws IOException;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return true if past the next synchronization point after a position. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return true if past the next synchronization point after a position.&lt;br/&gt;
+   */&lt;br/&gt;
   boolean pastSync(long position) throws IOException;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return the current position in the input. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the current position in the input.&lt;br/&gt;
+   */&lt;br/&gt;
   long tell() throws IOException;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; }&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/generic/GenericData.java b/lang/java/avro/src/main/java/org/apache/avro/generic/GenericData.java&lt;br/&gt;
index 8b8a2961f..a0272d75d 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/generic/GenericData.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/generic/GenericData.java&lt;br/&gt;
@@ -418,22 +418,42 @@ public int compareTo(GenericEnumSymbol that) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns a 
{@link DatumReader} for this kind of data. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns a {@link DatumReader}
&lt;p&gt; for this kind of data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema The schema to create the reader&lt;br/&gt;
+   * @return A compatible reader based on the schema&lt;br/&gt;
+   */&lt;br/&gt;
   public DatumReader createDatumReader(Schema schema) &lt;/p&gt;
{
     return new GenericDatumReader(schema, schema, this);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns a 
{@link DatumReader} for this kind of data. */&lt;br/&gt;
+  /** Returns a {@link DatumReader}
&lt;p&gt; for this kind of data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param writer The writer schema of the reader&lt;br/&gt;
+   * @param writer The reader schema of the reader&lt;br/&gt;
+   * @return A compatible reader based on the schemas&lt;br/&gt;
+   */&lt;br/&gt;
   public DatumReader createDatumReader(Schema writer, Schema reader) &lt;/p&gt;
{
     return new GenericDatumReader(writer, reader, this);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns a 
{@link DatumWriter} for this kind of data. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns a {@link DatumWriter}
&lt;p&gt; for this kind of data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema The schema to create the writer&lt;br/&gt;
+   * @return The writer based on the schema&lt;br/&gt;
+   */&lt;br/&gt;
   public DatumWriter createDatumWriter(Schema schema) &lt;/p&gt;
{
     return new GenericDatumWriter(schema, this);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns true if a Java datum matches a schema. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns true if a Java datum matches a schema.&lt;br/&gt;
+   * @param schema The schema to validate against&lt;br/&gt;
+   * @param datum The object that will be validated&lt;br/&gt;
+   * @return True if the object is compatible with the schema&lt;br/&gt;
+   */&lt;br/&gt;
   public boolean validate(Schema schema, Object datum) {&lt;br/&gt;
     switch (schema.getType()) {&lt;br/&gt;
     case RECORD:&lt;br/&gt;
@@ -482,7 +502,12 @@ public boolean validate(Schema schema, Object datum) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Renders a Java datum as &amp;lt;a href=&quot;http://www.json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Renders a Java datum as &amp;lt;a href=&quot;http://www.json.org/&quot;&amp;gt;JSON&amp;lt;/a&amp;gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param datum The datum to convert to JSON&lt;br/&gt;
+   * @return A JSON representation of the Java datum&lt;br/&gt;
+   */&lt;br/&gt;
   public String toString(Object datum) {&lt;br/&gt;
     StringBuilder buffer = new StringBuilder();&lt;br/&gt;
     toString(datum, buffer, new IdentityHashMap&amp;lt;&amp;gt;(128) );&lt;br/&gt;
@@ -618,7 +643,12 @@ private void writeEscapedString(CharSequence string, StringBuilder builder) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Create a schema given an example datum. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a schema given an example datum.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param datum The object to reflect the schema from&lt;br/&gt;
+   * @return The extracted schema&lt;br/&gt;
+   */&lt;br/&gt;
   public Schema induce(Object datum) {&lt;br/&gt;
     if (isRecord(datum)) {&lt;br/&gt;
       return getRecordSchema(datum);&lt;br/&gt;
@@ -667,37 +697,74 @@ public Schema induce(Object datum) 
{
     else throw new AvroTypeException(&quot;Can&apos;t create schema for: &quot;+datum);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by 
{@link GenericDatumReader#readRecord} to set a record fields&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by {@link GenericDatumReader#readRecord}
&lt;p&gt; to set a record fields&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;value to a record instance.  The default implementation is for 
{@link
-   * IndexedRecord}
&lt;p&gt;.*/&lt;br/&gt;
+   * IndexedRecord}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param record The raw record&lt;br/&gt;
+   * @param name The name of the field&lt;br/&gt;
+   * @param position The position of the field&lt;br/&gt;
+   * @param o The object to map the value onto&lt;br/&gt;
+   */&lt;br/&gt;
   public void setField(Object record, String name, int position, Object o) &lt;/p&gt;
{
     ((IndexedRecord)record).put(position, o);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by 
{@link GenericDatumReader#readRecord} to retrieve a record&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by {@link GenericDatumReader#readRecord}
&lt;p&gt; to retrieve a record&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;field value from a reused instance.  The default implementation is for&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* 
{@link IndexedRecord}.*/&lt;br/&gt;
+   * {@link IndexedRecord}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param record The raw record&lt;br/&gt;
+   * @param name The name of the field&lt;br/&gt;
+   * @param position The position of the field&lt;br/&gt;
+   * @return The extracted field&lt;br/&gt;
+   */&lt;br/&gt;
   public Object getField(Object record, String name, int position) &lt;/p&gt;
{
     return ((IndexedRecord)record).get(position);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Produce state for repeated calls to 
{@link
-   * #getField(Object,String,int,Object)}
&lt;p&gt; and &lt;/p&gt;
{@link
-   * #setField(Object,String,int,Object,Object)}
&lt;p&gt; on the same record.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Produce state for repeated calls to &lt;/p&gt;
{@link #getField(Object,String,int,Object)}
&lt;p&gt; and&lt;br/&gt;
+   * &lt;/p&gt;
{@link #setField(Object,String,int,Object,Object)}
&lt;p&gt; on the same record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param record The raw record&lt;br/&gt;
+   * @param schema The schema of the record&lt;br/&gt;
+   * @return Always null&lt;br/&gt;
+   */&lt;br/&gt;
   protected Object getRecordState(Object record, Schema schema) &lt;/p&gt;
{ return null; }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Version of 
{@link #setField} that has state. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Version of {@link #setField}
&lt;p&gt; that has state.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param r The raw record&lt;br/&gt;
+   * @param n The name of the field&lt;br/&gt;
+   * @param p The position of the field&lt;br/&gt;
+   * @param state The state of the object&lt;br/&gt;
+   */&lt;br/&gt;
   protected void setField(Object r, String n, int p, Object o, Object state) &lt;/p&gt;
{
     setField(r, n, p, o);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Version of 
{@link #getField} that has state. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Version of {@link #getField}
&lt;p&gt; that has state.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param record The raw record&lt;br/&gt;
+   * @param name The name of the field&lt;br/&gt;
+   * @param pos The position of the field&lt;br/&gt;
+   * @param state The state of the object&lt;br/&gt;
+   */&lt;br/&gt;
   protected Object getField(Object record, String name, int pos, Object state) &lt;/p&gt;
{
     return getField(record, name, pos);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return the index for a datum within a union.  Implemented with 
{@link
-   * Schema#getIndexNamed(String)}
&lt;p&gt; and &lt;/p&gt;
{@link #getSchemaName(Object)}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Implemented with {@link Schema#getIndexNamed(String)} and {@link #getSchemaName(Object)}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param union The schema that consists of an union&lt;br/&gt;
+   * @param datum The index for a datum within a union&lt;br/&gt;
+   */&lt;br/&gt;
   public int resolveUnion(Schema union, Object datum) {&lt;br/&gt;
     // if there is a logical type that works, use it first&lt;br/&gt;
     // this allows logical type concrete classes to overlap with supported ones&lt;br/&gt;
@@ -787,69 +854,119 @@ protected boolean instanceOf(Schema schema, Object datum) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by the default implementation of 
{@link #instanceOf}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by the default implementation of {@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is an &lt;/p&gt;
{@link Collection}&lt;br/&gt;
+   */&lt;br/&gt;
   protected boolean isArray(Object datum) {
     return datum instanceof Collection;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Called to access an array as a collection. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called to access an array as a collection.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param datum The object which is a {@link Collection}
&lt;p&gt;+   * @return The array as a collection&lt;br/&gt;
+   */&lt;br/&gt;
   protected Collection getArrayAsCollection(Object datum) &lt;/p&gt;
{
     return (Collection)datum;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by the default implementation of 
{@link #instanceOf}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by the default implementation of {@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is an &lt;/p&gt;
{@link IndexedRecord}
&lt;p&gt;+   */&lt;br/&gt;
   protected boolean isRecord(Object datum) &lt;/p&gt;
{
     return datum instanceof IndexedRecord;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called to obtain the schema of a record.  By default calls&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called to obtain the schema of a record.  By default calls&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;{GenericContainer#getSchema().  May be overridden for alternate record&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* representations. */&lt;br/&gt;
+   * representations.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param record The object which is a 
{@link GenericContainer}&lt;br/&gt;
+   * @return The record schema&lt;br/&gt;
+   */&lt;br/&gt;
   protected Schema getRecordSchema(Object record) {
     return ((GenericContainer)record).getSchema();
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Called by the default implementation of {@link #instanceOf}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by the default implementation of {@link #instanceOf}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is an Enum&lt;br/&gt;
+   */&lt;br/&gt;
   protected boolean isEnum(Object datum) {
     return datum instanceof GenericEnumSymbol;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Called to obtain the schema of a enum.  By default calls&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called to obtain the schema of a enum.  By default calls&lt;br/&gt;
    * {GenericContainer#getSchema().  May be overridden for alternate enum&lt;br/&gt;
-   * representations. */&lt;br/&gt;
+   * representations.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param enu The object which is a {@link GenericContainer}
&lt;p&gt;+   * @return The enum schema&lt;br/&gt;
+   */&lt;br/&gt;
   protected Schema getEnumSchema(Object enu) &lt;/p&gt;
{
     return ((GenericContainer)enu).getSchema();
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by the default implementation of 
{@link #instanceOf}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by the default implementation of {@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a Map&lt;br/&gt;
+   */&lt;br/&gt;
   protected boolean isMap(Object datum) &lt;/p&gt;
{
     return datum instanceof Map;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by the default implementation of 
{@link #instanceOf}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by the default implementation of {@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a fixed schema&lt;br/&gt;
+   */&lt;br/&gt;
   protected boolean isFixed(Object datum) &lt;/p&gt;
{
     return datum instanceof GenericFixed;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called to obtain the schema of a fixed.  By default calls&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called to obtain the schema of a fixed.  By default calls&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;{GenericContainer#getSchema().  May be overridden for alternate fixed&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* representations. */&lt;br/&gt;
+   * representations.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param fixed The object which is a 
{@link GenericContainer}
&lt;p&gt;+   * @return The fixed schmea&lt;br/&gt;
+   */&lt;br/&gt;
   protected Schema getFixedSchema(Object fixed) &lt;/p&gt;
{
     return ((GenericContainer)fixed).getSchema();
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by the default implementation of 
{@link #instanceOf}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by the default implementation of {@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a string&lt;br/&gt;
+   */&lt;br/&gt;
   protected boolean isString(Object datum) &lt;/p&gt;
{
     return datum instanceof CharSequence;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by the default implementation of 
{@link #instanceOf}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by the default implementation of {@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a byte&lt;br/&gt;
+   */&lt;br/&gt;
   protected boolean isBytes(Object datum) &lt;/p&gt;
{
     return datum instanceof ByteBuffer;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;br/&gt;
+  /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Called by the default implementation of 
{@link #instanceOf}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a int&lt;br/&gt;
    */&lt;br/&gt;
   protected boolean isInteger(Object datum) {&lt;br/&gt;
     return datum instanceof Integer;&lt;br/&gt;
@@ -857,6 +974,8 @@ protected boolean isInteger(Object datum) {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Called by the default implementation of {@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a long&lt;br/&gt;
    */&lt;br/&gt;
   protected boolean isLong(Object datum) {&lt;br/&gt;
     return datum instanceof Long;&lt;br/&gt;
@@ -864,6 +983,8 @@ protected boolean isLong(Object datum) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Called by the default implementation of 
{@link #instanceOf}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a float&lt;br/&gt;
    */&lt;br/&gt;
   protected boolean isFloat(Object datum) {&lt;br/&gt;
     return datum instanceof Float;&lt;br/&gt;
@@ -871,6 +992,8 @@ protected boolean isFloat(Object datum) {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Called by the default implementation of {@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a double&lt;br/&gt;
    */&lt;br/&gt;
   protected boolean isDouble(Object datum) {&lt;br/&gt;
     return datum instanceof Double;&lt;br/&gt;
@@ -878,6 +1001,8 @@ protected boolean isDouble(Object datum) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Called by the default implementation of 
{@link #instanceOf}
&lt;p&gt;.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return True if it is a boolean&lt;br/&gt;
    */&lt;br/&gt;
   protected boolean isBoolean(Object datum) {&lt;br/&gt;
     return datum instanceof Boolean;&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/BinaryDecoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/BinaryDecoder.java&lt;br/&gt;
index 7d996d27b..35aa08f96 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/io/BinaryDecoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/BinaryDecoder.java&lt;br/&gt;
@@ -26,9 +26,9 @@&lt;br/&gt;
 import org.apache.avro.util.Utf8;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /** An &lt;/p&gt;
{@link Decoder} for binary-format data.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * Instances are created using {@link DecoderFactory}.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * This class may read-ahead and buffer bytes from the source beyond what is&lt;br/&gt;
  * required to serve its read methods.&lt;br/&gt;
  * The number of unused bytes in the buffer can be accessed by&lt;br/&gt;
@@ -101,7 +101,7 @@ BinaryDecoder configure(byte[] data, int offset, int length) {&lt;br/&gt;
    * it exists) from this Decoder. The old source&apos;s state no longer depends on&lt;br/&gt;
    * this Decoder and its InputStream interface will continue to drain the&lt;br/&gt;
    * remaining buffer and source data.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * The decoder will read from the new source. The source will generally&lt;br/&gt;
    * replace the buffer with its own. If the source allocates a new buffer, it&lt;br/&gt;
    * will create it with size bufferSize.&lt;br/&gt;
@@ -442,7 +442,7 @@ public int readIndex() throws IOException {&lt;br/&gt;
    * Returns true if the current BinaryDecoder is at the end of its source data and&lt;br/&gt;
    * cannot read any further without throwing an EOFException or other&lt;br/&gt;
    * IOException.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * Not all implementations of BinaryDecoder support isEnd(). Implementations that do&lt;br/&gt;
    * not support isEnd() will throw a&lt;br/&gt;
    * {@link java.lang.UnsupportedOperationException}.&lt;br/&gt;
@@ -471,12 +471,12 @@ public boolean isEnd() throws IOException {&lt;br/&gt;
    * Ensures that buf&lt;span class=&quot;error&quot;&gt;&amp;#91;pos + num - 1&amp;#93;&lt;/span&gt; is not out of the buffer array bounds.&lt;br/&gt;
    * However, buf&lt;span class=&quot;error&quot;&gt;&amp;#91;pos + num -1&amp;#93;&lt;/span&gt; may be &amp;gt;= limit if there is not enough data left&lt;br/&gt;
    * in the source to fill the array with num bytes.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * This method allows readers to read ahead by num bytes safely without&lt;br/&gt;
    * checking for EOF at each byte. However, readers must ensure that their&lt;br/&gt;
    * reads are valid by checking that their read did not advance past the limit&lt;br/&gt;
    * before adjusting pos.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * num must be less than the buffer size and greater than 0&lt;br/&gt;
    */&lt;br/&gt;
   private void ensureBounds(int num) throws IOException {&lt;br/&gt;
@@ -585,16 +585,16 @@ void setBuf(byte[] buf, int offset, int length) {&lt;br/&gt;
    * InputStream&apos;s API is a barrier to performance due to several quirks:&lt;br/&gt;
    * InputStream does not in general require that as many bytes as possible have&lt;br/&gt;
    * been read when filling a buffer.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * InputStream&apos;s terminating conditions for a read are two-fold: EOFException&lt;br/&gt;
    * and &apos;-1&apos; on the return from read(). Implementations are supposed to return&lt;br/&gt;
    * &apos;-1&apos; on EOF but often do not. The extra terminating conditions cause extra&lt;br/&gt;
    * conditionals on both sides of the API, and slow performance significantly.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * ByteSource implementations provide read() and skip() variants that have&lt;br/&gt;
    * stronger guarantees than InputStream, freeing client code to be simplified&lt;br/&gt;
    * and faster.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link skipSourceBytes} and {@link readRaw} are guaranteed to have read or&lt;br/&gt;
    * skipped as many bytes as possible, or throw EOFException.&lt;br/&gt;
    * {@link trySkipBytes} and {@link tryRead} are guaranteed to attempt to read&lt;br/&gt;
@@ -604,7 +604,7 @@ void setBuf(byte[] buf, int offset, int length) {&lt;br/&gt;
    * also be detected by a client if an EOFException is thrown from&lt;br/&gt;
    * {@link skipSourceBytes} or {@link readRaw}, or if {@link trySkipBytes} or&lt;br/&gt;
    * {@link tryRead} return 0;&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * A ByteSource also implements the InputStream contract for use by APIs that&lt;br/&gt;
    * require it. The InputStream interface must take into account buffering in&lt;br/&gt;
    * any decoder that this ByteSource is attached to. The other methods do not&lt;br/&gt;
@@ -678,7 +678,7 @@ protected abstract void readRaw(byte[] data, int off, int len)&lt;br/&gt;
      * Attempts to copy up to &amp;lt;i&amp;gt;len&amp;lt;/i&amp;gt; bytes from the source into data,&lt;br/&gt;
      * starting at index &amp;lt;i&amp;gt;off&amp;lt;/i&amp;gt;. Returns the actual number of bytes copied&lt;br/&gt;
      * which may be between 0 and &amp;lt;i&amp;gt;len&amp;lt;/i&amp;gt;.&lt;br/&gt;
-     * &amp;lt;p/&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
      * This method must attempt to read as much as possible from the source.&lt;br/&gt;
      * Returns 0 when at the end of stream/channel/file/etc.&lt;br/&gt;
      *&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/BinaryEncoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/BinaryEncoder.java&lt;br/&gt;
index 971c94818..eb66b7efd 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/BinaryEncoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/BinaryEncoder.java&lt;br/&gt;
@@ -24,7 +24,7 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * An abstract {@link Encoder} for Avro&apos;s binary encoding.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * To construct and configure instances, use {@link EncoderFactory}&lt;br/&gt;
  *&lt;br/&gt;
  * @see EncoderFactory&lt;br/&gt;
@@ -118,7 +118,7 @@ public void writeIndex(int unionIndex) throws IOException {&lt;br/&gt;
   /**&lt;br/&gt;
    * Returns the number of bytes currently buffered by this encoder. If this&lt;br/&gt;
    * Encoder does not buffer, this will always return zero.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * Call {@link #flush()} to empty the buffer to the underlying output.&lt;br/&gt;
    */&lt;br/&gt;
   public abstract int bytesBuffered();&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/BlockingBinaryEncoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/BlockingBinaryEncoder.java&lt;br/&gt;
index 3c7095c04..dde312e2b 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/BlockingBinaryEncoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/BlockingBinaryEncoder.java&lt;br/&gt;
@@ -29,13 +29,13 @@&lt;br/&gt;
  * arbitrarily long arrays and maps may be written and subsequently read without&lt;br/&gt;
  * exhausting memory. Values are buffered until the specified block size would&lt;br/&gt;
  * be exceeded, minimizing block overhead.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * Use {@link EncoderFactory#blockingBinaryEncoder(OutputStream, BinaryEncoder)}&lt;br/&gt;
  * to construct and configure.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * BlockingBinaryEncoder buffers writes, data may not appear on the output until&lt;br/&gt;
  * {@link #flush()} is called.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * BlockingBinaryEncoder is not thread-safe&lt;br/&gt;
  *&lt;br/&gt;
  * @see BinaryEncoder&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/BufferedBinaryEncoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/BufferedBinaryEncoder.java&lt;br/&gt;
index c5403eafb..fc930cc8c 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/BufferedBinaryEncoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/BufferedBinaryEncoder.java&lt;br/&gt;
@@ -27,17 +27,17 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * An {@link Encoder} for Avro&apos;s binary encoding.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * This implementation buffers output to enhance performance.&lt;br/&gt;
  * Output may not appear on the underlying output until flush() is called.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * {@link DirectBinaryEncoder} can be used in place of this implementation if&lt;br/&gt;
  * the buffering semantics are not desired, and the performance difference&lt;br/&gt;
  * is acceptable.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * To construct or reconfigure, use&lt;br/&gt;
  * {@link EncoderFactory#binaryEncoder(OutputStream, BinaryEncoder)}.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * To change the buffer size, configure the factory instance used to&lt;br/&gt;
  * create instances with {@link EncoderFactory#configureBufferSize(int)}&lt;br/&gt;
  *  @see Encoder&lt;br/&gt;
@@ -189,11 +189,11 @@ public int bytesBuffered() {&lt;br/&gt;
   /**&lt;br/&gt;
    * ByteSink abstracts the destination of written data from the core workings&lt;br/&gt;
    * of BinaryEncoder.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * Currently the only destination option is an OutputStream, but we may later&lt;br/&gt;
    * want to handle other constructs or specialize for certain OutputStream&lt;br/&gt;
    * Implementations such as ByteBufferOutputStream.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    */&lt;br/&gt;
   private abstract static class ByteSink {&lt;br/&gt;
     protected ByteSink() {}&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/Decoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/Decoder.java&lt;br/&gt;
index fd5de126d..16112e502 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/Decoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/Decoder.java&lt;br/&gt;
@@ -24,16 +24,16 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Low-level support for de-serializing Avro values.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  *  This class has two types of methods.  One type of methods support&lt;br/&gt;
  *  the reading of leaf values (for example, {@link #readLong} and&lt;br/&gt;
  *  {@link #readString}).&lt;br/&gt;
- *  &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  *  The other type of methods support the reading of maps and arrays.&lt;br/&gt;
  *  These methods are {@link #readArrayStart}, {@link #arrayNext},&lt;br/&gt;
  *  and similar methods for maps).  See {@link #readArrayStart} for&lt;br/&gt;
  *  details on these methods.)&lt;br/&gt;
- *  &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  *  {@link DecoderFactory} contains Decoder construction and configuration&lt;br/&gt;
  *  facilities.&lt;br/&gt;
  *  @see DecoderFactory&lt;br/&gt;
@@ -46,14 +46,14 @@&lt;br/&gt;
    * &quot;Reads&quot; a null value.  (Doesn&apos;t actually read anything, but&lt;br/&gt;
    * advances the state of the parser if the implementation is&lt;br/&gt;
    * stateful.)&lt;br/&gt;
-   *  @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   *  @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          null is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void readNull() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reads a boolean value written by {@link Encoder#writeBoolean}.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    * boolean is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
 &lt;br/&gt;
@@ -61,51 +61,51 @@&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reads an integer written by {@link Encoder#writeInt}.&lt;br/&gt;
-   * @throws AvroTypeException If encoded value is larger than&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If encoded value is larger than&lt;br/&gt;
    *          32-bits&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          int is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract int readInt() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reads a long written by {@link Encoder#writeLong}.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          long is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract long readLong() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reads a float written by {@link Encoder#writeFloat}.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    * is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract float readFloat() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reads a double written by {@link Encoder#writeDouble}.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *           is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract double readDouble() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reads a char-string written by {@link Encoder#writeString}.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    * char-string is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract Utf8 readString(Utf8 old) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reads a char-string written by {@link Encoder#writeString}.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    * char-string is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract String readString() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Discards a char-string written by {@link Encoder#writeString}.&lt;br/&gt;
-   *  @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   *  @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          char-string is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void skipString() throws IOException;&lt;br/&gt;
@@ -114,14 +114,14 @@&lt;br/&gt;
    * Reads a byte-string written by {@link Encoder#writeBytes}.&lt;br/&gt;
    * if &amp;lt;tt&amp;gt;old&amp;lt;/tt&amp;gt; is not null and has sufficient capacity to take in&lt;br/&gt;
    * the bytes being read, the bytes are returned in &amp;lt;tt&amp;gt;old&amp;lt;/tt&amp;gt;.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          byte-string is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract ByteBuffer readBytes(ByteBuffer old) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Discards a byte-string written by {@link Encoder#writeBytes}.&lt;br/&gt;
-   *  @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   *  @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          byte-string is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void skipBytes() throws IOException;&lt;br/&gt;
@@ -131,7 +131,7 @@&lt;br/&gt;
    * @param bytes The buffer to store the contents being read.&lt;br/&gt;
    * @param start The position where the data needs to be written.&lt;br/&gt;
    * @param length  The size of the binary object.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          fixed sized binary object is not the type of the next&lt;br/&gt;
    *          value to be read or the length is incorrect.&lt;br/&gt;
    * @throws IOException&lt;br/&gt;
@@ -141,7 +141,7 @@ public abstract void readFixed(byte[] bytes, int start, int length)&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * A shorthand for &amp;lt;tt&amp;gt;readFixed(bytes, 0, bytes.length)&amp;lt;/tt&amp;gt;.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          fixed sized binary object is not the type of the next&lt;br/&gt;
    *          value to be read or the length is incorrect.&lt;br/&gt;
    * @throws IOException&lt;br/&gt;
@@ -153,7 +153,7 @@ public void readFixed(byte[] bytes) throws IOException {&lt;br/&gt;
   /**&lt;br/&gt;
    * Discards fixed sized binary object.&lt;br/&gt;
    * @param length  The size of the binary object to be skipped.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          fixed sized binary object is not the type of the next&lt;br/&gt;
    *          value to be read or the length is incorrect.&lt;br/&gt;
    * @throws IOException&lt;br/&gt;
@@ -163,7 +163,7 @@ public void readFixed(byte[] bytes) throws IOException {&lt;br/&gt;
   /**&lt;br/&gt;
    * Reads an enumeration.&lt;br/&gt;
    * @return The enumeration&apos;s value.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          enumeration is not the type of the next value to be read.&lt;br/&gt;
    * @throws IOException&lt;br/&gt;
    */&lt;br/&gt;
@@ -175,14 +175,14 @@ public void readFixed(byte[] bytes) throws IOException {&lt;br/&gt;
    * indicated number of items, and then call {@link
    * #arrayNext} to find out the number of items in the next&lt;br/&gt;
    * block.  The typical pattern for consuming an array looks like:&lt;br/&gt;
-   * &amp;lt;pre&amp;gt;&lt;br/&gt;
+   * &amp;lt;pre&amp;gt;{@code&lt;br/&gt;
    *   for(long i = in.readArrayStart(); i != 0; i = in.arrayNext()) {&lt;br/&gt;
    *     for (long j = 0; j &amp;lt; i; j++) {
    *       read next element of the array;
    *     }&lt;br/&gt;
    *   }&lt;br/&gt;
-   * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-   *  @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * }&amp;lt;/pre&amp;gt;&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          array is not the type of the next value to be read */&lt;br/&gt;
   public abstract long readArrayStart() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
@@ -190,7 +190,7 @@ public void readFixed(byte[] bytes) throws IOException {&lt;br/&gt;
    * Processes the next block of an array and returns the number of items in&lt;br/&gt;
    * the block and let&apos;s the caller&lt;br/&gt;
    * read those items.&lt;br/&gt;
-   * @throws AvroTypeException When called outside of an&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException When called outside of an&lt;br/&gt;
    *         array context&lt;br/&gt;
    */&lt;br/&gt;
   public abstract long arrayNext() throws IOException;&lt;br/&gt;
@@ -205,19 +205,19 @@ public void readFixed(byte[] bytes) throws IOException {&lt;br/&gt;
    * them if possible.  It will return zero if there are no more&lt;br/&gt;
    * items to skip through, or an item count if it needs the client&apos;s&lt;br/&gt;
    * help in skipping.  The typical usage pattern is:&lt;br/&gt;
-   * &amp;lt;pre&amp;gt;&lt;br/&gt;
-   *   for(long i = in.skipArray(); i != 0; i = i.skipArray()) {&lt;br/&gt;
-   *     for (long j = 0; j &amp;lt; i; j++) {
-   *       read and discard the next element of the array;
-   *     }&lt;br/&gt;
+   * &amp;lt;pre&amp;gt;{@code&lt;br/&gt;
+   * for(long i = in.skipArray(); i != 0; i = i.skipArray()) {&lt;br/&gt;
+   *   for (long j = 0; j &amp;lt; i; j++) {
+   *     read and discard the next element of the array;
    *   }&lt;br/&gt;
-   * &amp;lt;/pre&amp;gt;&lt;br/&gt;
+   * }&lt;br/&gt;
+   * }&amp;lt;/pre&amp;gt;&lt;br/&gt;
    * Note that this method can automatically skip through items if a&lt;br/&gt;
    * byte-count is found in the underlying data, or if a schema has&lt;br/&gt;
    * been provided to the implementation, but&lt;br/&gt;
    * otherwise the client will have to skip through items itself.&lt;br/&gt;
    *&lt;br/&gt;
-   *  @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          array is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract long skipArray() throws IOException;&lt;br/&gt;
@@ -226,10 +226,10 @@ public void readFixed(byte[] bytes) throws IOException {&lt;br/&gt;
    * Reads and returns the size of the next block of map-entries.&lt;br/&gt;
    * Similar to {@link #readArrayStart}.&lt;br/&gt;
    *&lt;br/&gt;
-   *  As an example, let&apos;s say you want to read a map of records,&lt;br/&gt;
-   *  the record consisting of an Long field and a Boolean field.&lt;br/&gt;
-   *  Your code would look something like this:&lt;br/&gt;
-   * &amp;lt;pre&amp;gt;&lt;br/&gt;
+   * As an example, let&apos;s say you want to read a map of records,&lt;br/&gt;
+   * the record consisting of an Long field and a Boolean field.&lt;br/&gt;
+   * Your code would look something like this:&lt;br/&gt;
+   * &amp;lt;pre&amp;gt;{@code&lt;br/&gt;
    *   Map&amp;lt;String,Record&amp;gt; m = new HashMap&amp;lt;String,Record&amp;gt;();&lt;br/&gt;
    *   Record reuse = new Record();&lt;br/&gt;
    *   for(long i = in.readMapStart(); i != 0; i = in.readMapNext()) {&lt;br/&gt;
@@ -240,8 +240,9 @@ public void readFixed(byte[] bytes) throws IOException {
    *       m.put(key, reuse);
    *     }&lt;br/&gt;
    *   }&lt;br/&gt;
-   * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * }&amp;lt;/pre&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *         map is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract long readMapStart() throws IOException;&lt;br/&gt;
@@ -249,7 +250,7 @@ public void readFixed(byte[] bytes) throws IOException {&lt;br/&gt;
   /**&lt;br/&gt;
    * Processes the next block of map entries and returns the count of them.&lt;br/&gt;
    * Similar to {@link #arrayNext}.  See {@link #readMapStart} for details.&lt;br/&gt;
-   * @throws AvroTypeException When called outside of a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException When called outside of a&lt;br/&gt;
    *         map context&lt;br/&gt;
    */&lt;br/&gt;
   public abstract long mapNext() throws IOException;&lt;br/&gt;
@@ -260,7 +261,7 @@ public void readFixed(byte[] bytes) throws IOException {&lt;br/&gt;
    * As an example, let&apos;s say you want to skip a map of records,&lt;br/&gt;
    * the record consisting of an Long field and a Boolean field.&lt;br/&gt;
    * Your code would look something like this:&lt;br/&gt;
-   * &amp;lt;pre&amp;gt;&lt;br/&gt;
+   * &amp;lt;pre&amp;gt;{@code&lt;br/&gt;
    *   for(long i = in.skipMap(); i != 0; i = in.skipMap()) {&lt;br/&gt;
    *     for (long j = 0; j &amp;lt; i; j++) {&lt;br/&gt;
    *       in.skipString();  // Discard key&lt;br/&gt;
@@ -268,15 +269,16 @@ public void readFixed(byte[] bytes) throws IOException {
    *       in.readBoolean(); // Discard boolean-field of value
    *     }&lt;br/&gt;
    *   }&lt;br/&gt;
-   * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-   *  @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * }&amp;lt;/pre&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *          array is not the type of the next value to be read */&lt;br/&gt;
 &lt;br/&gt;
   public abstract long skipMap() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reads the tag of a union written by {@link Encoder#writeIndex}.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful reader and&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful reader and&lt;br/&gt;
    *         union is not the type of the next value to be read&lt;br/&gt;
    */&lt;br/&gt;
   public abstract int readIndex() throws IOException;&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/DecoderFactory.java b/lang/java/avro/src/main/java/org/apache/avro/io/DecoderFactory.java&lt;br/&gt;
index ddb369795..3326bb1c9 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/DecoderFactory.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/DecoderFactory.java&lt;br/&gt;
@@ -24,7 +24,7 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * A factory for creating and configuring {@link Decoder}
&lt;p&gt;s.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Factories are thread-safe, and are generally cached by applications for&lt;/li&gt;
	&lt;li&gt;performance reasons. Multiple instances are only required if multiple&lt;/li&gt;
	&lt;li&gt;concurrent configurations are needed.&lt;br/&gt;
@@ -103,13 +103,13 @@ public BinaryDecoder createBinaryDecoder(InputStream in, BinaryDecoder reuse) {&lt;/li&gt;
	&lt;li&gt;Creates or reinitializes a 
{@link BinaryDecoder} with the input stream&lt;br/&gt;
    * provided as the source of data. If &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; is provided, it will be&lt;br/&gt;
    * reinitialized to the given input stream.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link BinaryDecoder}
&lt;p&gt; instances returned by this method buffer their input,&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;reading up to 
{@link #getConfiguredBufferSize()}
&lt;p&gt; bytes past the minimum&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;required to satisfy read requests in order to achieve better performance.&lt;/li&gt;
	&lt;li&gt;If the buffering is not desired, use&lt;/li&gt;
	&lt;li&gt;{@link #directBinaryDecoder(InputStream, BinaryDecoder)}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;{@link BinaryDecoder#inputStream()} provides a view on the data that is&lt;br/&gt;
    * buffer-aware, for users that need to interleave access to data&lt;br/&gt;
    * with the Decoder API.&lt;br/&gt;
@@ -140,17 +140,17 @@ public BinaryDecoder binaryDecoder(InputStream in, BinaryDecoder reuse) {&lt;br/&gt;
    * Creates or reinitializes a {@link BinaryDecoder} with the input stream&lt;br/&gt;
    * provided as the source of data. If &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; is provided, it will be&lt;br/&gt;
    * reinitialized to the given input stream.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link BinaryDecoder} instances returned by this method do not buffer their input.&lt;br/&gt;
    * In most cases a buffering BinaryDecoder is sufficient in combination with&lt;br/&gt;
    * {@link BinaryDecoder#inputStream()}
&lt;p&gt; which provides a buffer-aware view on&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;the data.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;A &quot;direct&quot; BinaryDecoder does not read ahead from an InputStream or other data source&lt;/li&gt;
	&lt;li&gt;that cannot be rewound.  From the perspective of a client, a &quot;direct&quot; decoder&lt;/li&gt;
	&lt;li&gt;must never read beyond the minimum necessary bytes to service a 
{@link BinaryDecoder}&lt;br/&gt;
    * API read request.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * In the case that the improved performance of a buffering implementation does not outweigh the&lt;br/&gt;
    * inconvenience of its buffering semantics, a &quot;direct&quot; decoder can be&lt;br/&gt;
    * used.&lt;br/&gt;
@@ -193,7 +193,7 @@ public BinaryDecoder createBinaryDecoder(byte[] bytes, int offset,&lt;br/&gt;
    * provided as the source of data. If &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; is provided, it will&lt;br/&gt;
    * attempt to reinitialize &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; to the new byte array. This instance&lt;br/&gt;
    * will use the provided byte array as its buffer.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link BinaryDecoder#inputStream()} provides a view on the data that is&lt;br/&gt;
    * buffer-aware and can provide a view of the data not yet read by Decoder API&lt;br/&gt;
    * methods.&lt;br/&gt;
@@ -237,7 +237,7 @@ public BinaryDecoder binaryDecoder(byte[] bytes, BinaryDecoder reuse) {&lt;br/&gt;
   /**&lt;br/&gt;
    * Creates a {@link JsonDecoder} using the InputStrim provided for reading&lt;br/&gt;
    * data that conforms to the Schema provided.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    *&lt;br/&gt;
    * @param schema&lt;br/&gt;
    *          The Schema for data read from this JsonEncoder. Cannot be null.&lt;br/&gt;
@@ -254,7 +254,7 @@ public JsonDecoder jsonDecoder(Schema schema, InputStream input)&lt;br/&gt;
   /**&lt;br/&gt;
    * Creates a {@link JsonDecoder} using the String provided for reading data&lt;br/&gt;
    * that conforms to the Schema provided.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    *&lt;br/&gt;
    * @param schema&lt;br/&gt;
    *          The Schema for data read from this JsonEncoder. Cannot be null.&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/DirectBinaryDecoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/DirectBinaryDecoder.java&lt;br/&gt;
index 4577b472c..0effc3a5a 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/DirectBinaryDecoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/DirectBinaryDecoder.java&lt;br/&gt;
@@ -27,7 +27,7 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  *  A non-buffering version of {@link BinaryDecoder}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*  &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;This implementation will not read-ahead from the provided InputStream&lt;/li&gt;
	&lt;li&gt;beyond the minimum required to service the API requests.&lt;br/&gt;
  *&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/DirectBinaryEncoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/DirectBinaryEncoder.java&lt;br/&gt;
index 8626eef48..11a410417 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/io/DirectBinaryEncoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/DirectBinaryEncoder.java&lt;br/&gt;
@@ -22,15 +22,15 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;An 
{@link Encoder} for Avro&apos;s binary encoding that does not buffer output.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * This encoder does not buffer writes, and as a result is slower than&lt;br/&gt;
  * {@link BufferedBinaryEncoder}. However, it is lighter-weight and useful when the&lt;br/&gt;
  * buffering in BufferedBinaryEncoder is not desired and/or the Encoder is&lt;br/&gt;
  * very short lived.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * To construct, use&lt;br/&gt;
  * {@link EncoderFactory#directBinaryEncoder(OutputStream, BinaryEncoder)}&lt;br/&gt;
- *  &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * DirectBinaryEncoder is not thread-safe&lt;br/&gt;
  * @see BinaryEncoder&lt;br/&gt;
  * @see EncoderFactory&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/Encoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/Encoder.java&lt;br/&gt;
index e7a31a469..63452b5d2 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/Encoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/Encoder.java&lt;br/&gt;
@@ -25,12 +25,12 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Low-level support for serializing Avro values.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * This class has two types of methods.  One type of methods support&lt;br/&gt;
  * the writing of leaf values (for example, {@link #writeLong} and&lt;br/&gt;
  * {@link #writeString}).  These methods have analogs in {@link
  * Decoder}.&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * The other type of methods support the writing of maps and arrays.&lt;br/&gt;
  * These methods are {@link #writeArrayStart}, {@link
  * #startItem}, and {@link #writeArrayEnd} (and similar methods for&lt;br/&gt;
@@ -38,7 +38,7 @@&lt;br/&gt;
  * buffering required to break large maps and arrays into blocks,&lt;br/&gt;
  * which is necessary for applications that want to do streaming.&lt;br/&gt;
  * (See {@link #writeArrayStart} for details on these methods.)&lt;br/&gt;
- * &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * {@link EncoderFactory} contains Encoder construction and configuration&lt;br/&gt;
  * facilities.&lt;br/&gt;
  *  @see EncoderFactory&lt;br/&gt;
@@ -49,49 +49,49 @@&lt;br/&gt;
   /**&lt;br/&gt;
    * &quot;Writes&quot; a null value.  (Doesn&apos;t actually write anything, but&lt;br/&gt;
    * advances the state of the parser if this class is stateful.)&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    *         null is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeNull() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Write a boolean value.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * boolean is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeBoolean(boolean b) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Writes a 32-bit integer.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and an&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and an&lt;br/&gt;
    * integer is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeInt(int n) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Write a 64-bit integer.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * long is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeLong(long n) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /** Write a float.&lt;br/&gt;
    * @throws IOException&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * float is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeFloat(float f) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Write a double.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * double is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeDouble(double d) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Write a Unicode character string.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * char-string is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeString(Utf8 utf8) throws IOException;&lt;br/&gt;
@@ -100,7 +100,7 @@&lt;br/&gt;
    * Write a Unicode character string.  The default implementation converts&lt;br/&gt;
    * the String to a {@link org.apache.avro.util.Utf8}.  Some Encoder&lt;br/&gt;
    * implementations may want to do something different as a performance optimization.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * char-string is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public void writeString(String str) throws IOException {&lt;br/&gt;
@@ -111,7 +111,7 @@ public void writeString(String str) throws IOException {&lt;br/&gt;
    * Write a Unicode character string.  If the CharSequence is an&lt;br/&gt;
    * {@link org.apache.avro.util.Utf8} it writes this directly, otherwise&lt;br/&gt;
    * the CharSequence is converted to a String via toString() and written.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * char-string is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public void writeString(CharSequence charSequence) throws IOException {&lt;br/&gt;
@@ -123,14 +123,14 @@ public void writeString(CharSequence charSequence) throws IOException {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Write a byte string.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    *         byte-string is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeBytes(ByteBuffer bytes) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Write a byte string.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * byte-string is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeBytes(byte[] bytes, int start, int len) throws IOException;&lt;br/&gt;
@@ -139,7 +139,7 @@ public void writeString(CharSequence charSequence) throws IOException {&lt;br/&gt;
    * Writes a byte string.&lt;br/&gt;
    * Equivalent to &amp;lt;tt&amp;gt;writeBytes(bytes, 0, bytes.length)&amp;lt;/tt&amp;gt;&lt;br/&gt;
    * @throws IOException&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * byte-string is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public void writeBytes(byte[] bytes) throws IOException {&lt;br/&gt;
@@ -152,7 +152,7 @@ public void writeBytes(byte[] bytes) throws IOException {&lt;br/&gt;
    * @param start The position within &amp;lt;tt&amp;gt;bytes&amp;lt;/tt&amp;gt; where the contents&lt;br/&gt;
    * start.&lt;br/&gt;
    * @param len The number of bytes to write.&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * byte-string is not expected&lt;br/&gt;
    * @throws IOException&lt;br/&gt;
    */&lt;br/&gt;
@@ -182,7 +182,7 @@ public void writeFixed(ByteBuffer bytes) throws IOException {&lt;br/&gt;
   /**&lt;br/&gt;
    * Writes an enumeration.&lt;br/&gt;
    * @param e&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and an enumeration&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and an enumeration&lt;br/&gt;
    * is not expected or the &amp;lt;tt&amp;gt;e&amp;lt;/tt&amp;gt; is out of range.&lt;br/&gt;
    * @throws IOException&lt;br/&gt;
    */&lt;br/&gt;
@@ -213,7 +213,7 @@ public void writeFixed(ByteBuffer bytes) throws IOException {
    *  }&lt;br/&gt;
    *  out.writeArrayEnd();&lt;br/&gt;
    *  &amp;lt;/pre&amp;gt;&lt;br/&gt;
-   *  @throws AvroTypeException If this is a stateful writer and an&lt;br/&gt;
+   *  @throws org.apache.avro.AvroTypeException If this is a stateful writer and an&lt;br/&gt;
    *          array is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeArrayStart() throws IOException;&lt;br/&gt;
@@ -234,7 +234,7 @@ public void writeFixed(ByteBuffer bytes) throws IOException {&lt;br/&gt;
   /**&lt;br/&gt;
    * Start a new item of an array or map.&lt;br/&gt;
    * See {@link #writeArrayStart} for usage information.&lt;br/&gt;
-   * @throws AvroTypeException If called outside of an array or map context&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If called outside of an array or map context&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void startItem() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
@@ -242,9 +242,9 @@ public void writeFixed(ByteBuffer bytes) throws IOException {&lt;br/&gt;
    * Call this method to finish writing an array.&lt;br/&gt;
    * See {@link #writeArrayStart} for usage information.&lt;br/&gt;
    *&lt;br/&gt;
-   * @throws AvroTypeException If items written does not match count&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If items written does not match count&lt;br/&gt;
    *          provided to {@link #writeArrayStart}&lt;br/&gt;
-   * @throws AvroTypeException If not currently inside an array&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If not currently inside an array&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeArrayEnd() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
@@ -255,7 +255,8 @@ public void writeFixed(ByteBuffer bytes) throws IOException {&lt;br/&gt;
    * As an example of usage, let&apos;s say you want to write a map of&lt;br/&gt;
    * records, the record consisting of an Long field and a Boolean&lt;br/&gt;
    * field.  Your code would look something like this:&lt;br/&gt;
-   * &amp;lt;pre&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
+   * &amp;lt;pre&amp;gt;{@code&lt;br/&gt;
    * out.writeMapStart();&lt;br/&gt;
    * out.setItemCount(list.size());&lt;br/&gt;
    * for (Map.Entry&amp;lt;String,Record&amp;gt; entry : map.entrySet()) {&lt;br/&gt;
@@ -265,8 +266,9 @@ public void writeFixed(ByteBuffer bytes) throws IOException {
    *   out.writeBoolean(entry.getValue().boolField);
    * }&lt;br/&gt;
    * out.writeMapEnd();&lt;br/&gt;
-   * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * }&amp;lt;/pre&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * map is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeMapStart() throws IOException;&lt;br/&gt;
@@ -275,9 +277,9 @@ public void writeFixed(ByteBuffer bytes) throws IOException {&lt;br/&gt;
    * Call this method to terminate the inner-most, currently-opened&lt;br/&gt;
    * map.  See {@link #writeArrayStart} for more details.&lt;br/&gt;
    *&lt;br/&gt;
-   * @throws AvroTypeException If items written does not match count&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If items written does not match count&lt;br/&gt;
    *          provided to {@link #writeMapStart}&lt;br/&gt;
-   * @throws AvroTypeException If not currently inside a map&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If not currently inside a map&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeMapEnd() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
@@ -291,7 +293,7 @@ public void writeFixed(ByteBuffer bytes) throws IOException {&lt;br/&gt;
    * out.writeLong(record.longField);&lt;br/&gt;
    * out.writeBoolean(record.boolField);&lt;br/&gt;
    * &amp;lt;/pre&amp;gt;&lt;br/&gt;
-   * @throws AvroTypeException If this is a stateful writer and a&lt;br/&gt;
+   * @throws org.apache.avro.AvroTypeException If this is a stateful writer and a&lt;br/&gt;
    * map is not expected&lt;br/&gt;
    */&lt;br/&gt;
   public abstract void writeIndex(int unionIndex) throws IOException;&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/EncoderFactory.java b/lang/java/avro/src/main/java/org/apache/avro/io/EncoderFactory.java&lt;br/&gt;
index 941c19990..cfb03c063 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/EncoderFactory.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/EncoderFactory.java&lt;br/&gt;
@@ -26,7 +26,7 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * A factory for creating and configuring {@link Encoder}
&lt;p&gt; instances.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Factory methods that create Encoder instances are thread-safe.&lt;/li&gt;
	&lt;li&gt;Multiple instances with different configurations can be cached&lt;/li&gt;
	&lt;li&gt;by an application.&lt;br/&gt;
@@ -128,7 +128,7 @@ public EncoderFactory configureBlockSize(int size) {&lt;/li&gt;
	&lt;li&gt;{@link BinaryEncoder} instances created with&lt;br/&gt;
    * #blockingBinaryEncoder(OutputStream, BinaryEncoder)&lt;br/&gt;
    * will have block buffers of this size.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * @see #configureBlockSize(int)&lt;br/&gt;
    * @see #blockingBinaryEncoder(OutputStream, BinaryEncoder)&lt;br/&gt;
    * @return The preferred block size, in bytes.&lt;br/&gt;
@@ -142,14 +142,12 @@ public int getBlockSize() {&lt;br/&gt;
    * provided as the destination for written data. If &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; is provided,&lt;br/&gt;
    * an attempt will be made to reconfigure &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; rather than construct a&lt;br/&gt;
    * new instance, but this is not guaranteed, a new instance may be returned.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * The {@link BinaryEncoder}
&lt;p&gt; implementation returned may buffer its output.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Data may not appear on the underlying OutputStream until&lt;/li&gt;
	&lt;li&gt;{@link Encoder#flush()} is called.  The buffer size is configured with&lt;br/&gt;
-   * {@link #configureBufferSize(int)}.&lt;br/&gt;
-   * &amp;lt;/p&amp;gt;  If buffering is not desired, and lower performance is acceptable, use&lt;br/&gt;
+   * {@link #configureBufferSize(int)}. If buffering is not desired, and lower performance is acceptable, use&lt;br/&gt;
    * {@link #directBinaryEncoder(OutputStream, BinaryEncoder)}&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
    * {@link BinaryEncoder} instances returned by this method are not thread-safe&lt;br/&gt;
    *&lt;br/&gt;
    * @param out&lt;br/&gt;
@@ -163,7 +161,6 @@ public int getBlockSize() {&lt;br/&gt;
    *         &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; is null, this will be a new instance. If &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt;&lt;br/&gt;
    *         is not null, then the returned instance may be a new instance or&lt;br/&gt;
    *         &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; reconfigured to use &amp;lt;i&amp;gt;out&amp;lt;/i&amp;gt;.&lt;br/&gt;
-   * @throws IOException&lt;br/&gt;
    * @see BufferedBinaryEncoder&lt;br/&gt;
    * @see Encoder&lt;br/&gt;
    */&lt;br/&gt;
@@ -176,22 +173,22 @@ public BinaryEncoder binaryEncoder(OutputStream out, BinaryEncoder reuse) {&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
-   * Creates or reinitializes a {@link BinaryEncoder} with the OutputStream&lt;br/&gt;
+   * Creates or reinitialize a {@link BinaryEncoder} with the OutputStream&lt;br/&gt;
    * provided as the destination for written data. If &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; is provided,&lt;br/&gt;
    * an attempt will be made to reconfigure &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; rather than construct a&lt;br/&gt;
    * new instance, but this is not guaranteed, a new instance may be returned.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * The {@link BinaryEncoder} implementation returned does not buffer its&lt;br/&gt;
    * output, calling {@link Encoder#flush()}
&lt;p&gt; will simply cause the wrapped&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;OutputStream to be flushed.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Performance of unbuffered writes can be significantly slower than buffered&lt;/li&gt;
	&lt;li&gt;writes.  
{@link #binaryEncoder(OutputStream, BinaryEncoder)}
&lt;p&gt; returns&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;BinaryEncoder instances that are tuned for performance but may buffer output.&lt;/li&gt;
	&lt;li&gt;The unbuffered, &apos;direct&apos; encoder may be desired when buffering semantics are&lt;/li&gt;
	&lt;li&gt;problematic, or if the lifetime of the encoder is so short that the buffer&lt;/li&gt;
	&lt;li&gt;would not be useful.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;{@link BinaryEncoder} instances returned by this method are not thread-safe.&lt;br/&gt;
    *&lt;br/&gt;
    * @param out&lt;br/&gt;
@@ -221,17 +218,17 @@ public BinaryEncoder directBinaryEncoder(OutputStream out, BinaryEncoder reuse)&lt;br/&gt;
    * provided as the destination for written data. If &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; is provided,&lt;br/&gt;
    * an attempt will be made to reconfigure &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; rather than construct a&lt;br/&gt;
    * new instance, but this is not guaranteed, a new instance may be returned.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * The {@link BinaryEncoder}
&lt;p&gt; implementation returned buffers its output,&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;calling 
{@link Encoder#flush()} is required for output to appear on the underlying&lt;br/&gt;
    * OutputStream.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * The returned BinaryEncoder implements the Avro binary encoding using blocks&lt;br/&gt;
    * delimited with byte sizes for Arrays and Maps.  This allows for some decoders&lt;br/&gt;
    * to skip over large Arrays or Maps without decoding the contents, but adds&lt;br/&gt;
    * some overhead.  The default block size is configured with&lt;br/&gt;
    * {@link #configureBlockSize(int)}&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link BinaryEncoder} instances returned by this method are not thread-safe.&lt;br/&gt;
    *&lt;br/&gt;
    * @param out&lt;br/&gt;
@@ -245,7 +242,6 @@ public BinaryEncoder directBinaryEncoder(OutputStream out, BinaryEncoder reuse)&lt;br/&gt;
    *         &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; is null, this will be a new instance. If &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt;&lt;br/&gt;
    *         is not null, then the returned instance may be a new instance or&lt;br/&gt;
    *         &amp;lt;i&amp;gt;reuse&amp;lt;/i&amp;gt; reconfigured to use &amp;lt;i&amp;gt;out&amp;lt;/i&amp;gt;.&lt;br/&gt;
-   * @throws IOException&lt;br/&gt;
    * @see BlockingBinaryEncoder&lt;br/&gt;
    * @see Encoder&lt;br/&gt;
    */&lt;br/&gt;
@@ -264,10 +260,10 @@ public BinaryEncoder blockingBinaryEncoder(OutputStream out,&lt;br/&gt;
   /**&lt;br/&gt;
    * Creates a {@link JsonEncoder} using the OutputStream provided for writing&lt;br/&gt;
    * data conforming to the Schema provided.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link JsonEncoder} buffers its output. Data may not appear on the&lt;br/&gt;
    * underlying OutputStream until {@link Encoder#flush()}
&lt;p&gt; is called.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;{@link JsonEncoder} is not thread-safe.&lt;br/&gt;
    *&lt;br/&gt;
    * @param schema&lt;br/&gt;
@@ -285,10 +281,10 @@ public JsonEncoder jsonEncoder(Schema schema, OutputStream out)&lt;br/&gt;
   /**&lt;br/&gt;
    * Creates a {@link JsonEncoder}
&lt;p&gt; using the OutputStream provided for writing&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;data conforming to the Schema provided with optional pretty printing.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;{@link JsonEncoder} buffers its output. Data may not appear on the&lt;br/&gt;
    * underlying OutputStream until {@link Encoder#flush()} is called.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link JsonEncoder}
&lt;p&gt; is not thread-safe.&lt;br/&gt;
    *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param schema&lt;br/&gt;
@@ -308,10 +304,10 @@ public JsonEncoder jsonEncoder(Schema schema, OutputStream out, boolean pretty)&lt;br/&gt;
   /**&lt;/li&gt;
	&lt;li&gt;Creates a 
{@link JsonEncoder} using the {@link JsonGenerator} provided for&lt;br/&gt;
    * output of data conforming to the Schema provided.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link JsonEncoder}
&lt;p&gt; buffers its output. Data may not appear on the&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;underlying output until 
{@link Encoder#flush()} is called.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * {@link JsonEncoder} is not thread-safe.&lt;br/&gt;
    *&lt;br/&gt;
    * @param schema&lt;br/&gt;
@@ -332,10 +328,10 @@ public JsonEncoder jsonEncoder(Schema schema, JsonGenerator gen)&lt;br/&gt;
    * Creates a {@link ValidatingEncoder} that wraps the Encoder provided.&lt;br/&gt;
    * This ValidatingEncoder will ensure that operations against it conform&lt;br/&gt;
    * to the schema provided.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * Many {@link Encoder}s buffer their output. Data may not appear on the&lt;br/&gt;
    * underlying output until {@link Encoder#flush()}
&lt;p&gt; is called.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;{@link ValidatingEncoder}
&lt;p&gt; is not thread-safe.&lt;br/&gt;
    *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param schema&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/JsonDecoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/JsonDecoder.java&lt;br/&gt;
index 1dcb8dd15..072d3fbbe 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/io/JsonDecoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/JsonDecoder.java&lt;br/&gt;
@@ -44,7 +44,7 @@&lt;br/&gt;
 import org.codehaus.jackson.ObjectCodec;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /** A &lt;/p&gt;
{@link Decoder} for Avro&apos;s JSON data encoding.&lt;br/&gt;
- * &amp;lt;/p&amp;gt;&lt;br/&gt;
+ * &amp;lt;p&amp;gt;&lt;br/&gt;
  * Construct using {@link DecoderFactory}.&lt;br/&gt;
  * &amp;lt;/p&amp;gt;&lt;br/&gt;
  * JsonDecoder is not thread-safe.&lt;br/&gt;
@@ -90,9 +90,9 @@ private static Symbol getSymbol(Schema schema) {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reconfigures this JsonDecoder to use the InputStream provided.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * If the InputStream provided is null, a NullPointerException is thrown.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * Otherwise, this JsonDecoder will reset its state and then&lt;br/&gt;
    * reconfigure its input.&lt;br/&gt;
    * @param in&lt;br/&gt;
@@ -114,9 +114,9 @@ public JsonDecoder configure(InputStream in) throws IOException {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reconfigures this JsonDecoder to use the String provided for input.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * If the String provided is null, a NullPointerException is thrown.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * Otherwise, this JsonDecoder will reset its state and then&lt;br/&gt;
    * reconfigure its input.&lt;br/&gt;
    * @param in&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/JsonEncoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/JsonEncoder.java&lt;br/&gt;
index 426b86c19..179ceaa22 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/JsonEncoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/JsonEncoder.java&lt;br/&gt;
@@ -35,12 +35,11 @@&lt;br/&gt;
 import org.codehaus.jackson.util.MinimalPrettyPrinter;&lt;br/&gt;
 &lt;br/&gt;
 /** An {@link Encoder} for Avro&apos;s JSON data encoding.&lt;br/&gt;
- * &amp;lt;/p&amp;gt;&lt;br/&gt;
  * Construct using {@link EncoderFactory}.&lt;br/&gt;
- * &amp;lt;/p&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * JsonEncoder buffers output, and data may not appear on the output&lt;br/&gt;
  * until {@link Encoder#flush()} is called.&lt;br/&gt;
- * &amp;lt;/p&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
  * JsonEncoder is not thread-safe.&lt;br/&gt;
  * */&lt;br/&gt;
 public class JsonEncoder extends ParsingEncoder implements Parser.ActionHandler {&lt;br/&gt;
@@ -102,9 +101,9 @@ public void writeRootValueSeparator(JsonGenerator jg)&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reconfigures this JsonEncoder to use the output stream provided.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * If the OutputStream provided is null, a NullPointerException is thrown.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * Otherwise, this JsonEncoder will flush its current output and then&lt;br/&gt;
    * reconfigure its output to use a default UTF8 JsonGenerator that writes&lt;br/&gt;
    * to the provided OutputStream.&lt;br/&gt;
@@ -121,9 +120,9 @@ public JsonEncoder configure(OutputStream out) throws IOException {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Reconfigures this JsonEncoder to output to the JsonGenerator provided.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * If the JsonGenerator provided is null, a NullPointerException is thrown.&lt;br/&gt;
-   * &amp;lt;p/&amp;gt;&lt;br/&gt;
+   *&lt;br/&gt;
    * Otherwise, this JsonEncoder will flush its current output and then&lt;br/&gt;
    * reconfigure its output to use the provided JsonGenerator.&lt;br/&gt;
    *&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/ValidatingDecoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/ValidatingDecoder.java&lt;br/&gt;
index 6a607f821..39c1a636d 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/io/ValidatingDecoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/ValidatingDecoder.java&lt;br/&gt;
@@ -30,10 +30,10 @@&lt;br/&gt;
 /**&lt;br/&gt;
  * An implementation of {@link Decoder}
&lt;p&gt; that ensures that the sequence&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;of operations conforms to a schema.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Use 
{@link DecoderFactory#validatingDecoder(Schema, Decoder)}
&lt;p&gt; to construct&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;and configure.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;ValidatingDecoder is not thread-safe.&lt;/li&gt;
	&lt;li&gt;@see Decoder&lt;/li&gt;
	&lt;li&gt;@see DecoderFactory&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/io/ValidatingEncoder.java b/lang/java/avro/src/main/java/org/apache/avro/io/ValidatingEncoder.java&lt;br/&gt;
index a95504fe3..4a7c74f89 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/io/ValidatingEncoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/io/ValidatingEncoder.java&lt;br/&gt;
@@ -31,10 +31,10 @@&lt;br/&gt;
 /**&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;An implementation of 
{@link Encoder}
&lt;p&gt; that wraps another Encoder and&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;ensures that the sequence of operations conforms to the provided schema.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Use 
{@link EncoderFactory#validatingEncoder(Schema, Encoder)}
&lt;p&gt; to construct&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;and configure.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* &amp;lt;p/&amp;gt;&lt;br/&gt;
+ *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;ValidatingEncoder is not thread-safe.&lt;/li&gt;
	&lt;li&gt;@see Encoder&lt;/li&gt;
	&lt;li&gt;@see EncoderFactory&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/message/BinaryMessageEncoder.java b/lang/java/avro/src/main/java/org/apache/avro/message/BinaryMessageEncoder.java&lt;br/&gt;
index e4eb43ef5..66fc94e1c 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/message/BinaryMessageEncoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/message/BinaryMessageEncoder.java&lt;br/&gt;
@@ -46,7 +46,7 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;{@link GenericData data model} to deconstruct datum instances described by&lt;br/&gt;
    * the {@link Schema schema}.&lt;br/&gt;
    * &amp;lt;p&amp;gt;&lt;br/&gt;
-   * Buffers returned by {@link #encode(D)} are copied and will not be modified&lt;br/&gt;
+   * Buffers returned by {@link #encode(Object)} are copied and will not be modified&lt;br/&gt;
    * by future calls to {@code encode}.&lt;br/&gt;
    *&lt;br/&gt;
    * @param model the {@link GenericData data model}
&lt;p&gt; for datum instances&lt;br/&gt;
@@ -61,7 +61,7 @@ public BinaryMessageEncoder(GenericData model, Schema schema) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;{@link GenericData data model} to deconstruct datum instances described by&lt;br/&gt;
    * the {@link Schema schema}.&lt;br/&gt;
    * &amp;lt;p&amp;gt;&lt;br/&gt;
-   * If {@code shouldCopy} is true, then buffers returned by {@link #encode(D)}&lt;br/&gt;
+   * If {@code shouldCopy} is true, then buffers returned by {@link #encode(Object)}&lt;br/&gt;
    * are copied and will not be modified by future calls to {@code encode}.&lt;br/&gt;
    * &amp;lt;p&amp;gt;&lt;br/&gt;
    * If {@code shouldCopy} is false, then buffers returned by {@code encode}&lt;br/&gt;
diff --git a/lang/java/avro/src/main/java/org/apache/avro/message/RawMessageEncoder.java b/lang/java/avro/src/main/java/org/apache/avro/message/RawMessageEncoder.java&lt;br/&gt;
index d85d20e85..eb9476e57 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/message/RawMessageEncoder.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/message/RawMessageEncoder.java&lt;br/&gt;
@@ -57,7 +57,7 @@ protected BufferOutputStream initialValue() {&lt;br/&gt;
    * {@link GenericData data model}
&lt;p&gt; to deconstruct datum instances described by&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;the 
{@link Schema schema}.&lt;br/&gt;
    * &amp;lt;p&amp;gt;&lt;br/&gt;
-   * Buffers returned by {@link #encode(D)} are copied and will not be modified&lt;br/&gt;
+   * Buffers returned by {@link #encode(Object)} are copied and will not be modified&lt;br/&gt;
    * by future calls to {@code encode}.&lt;br/&gt;
    *&lt;br/&gt;
    * @param model the {@link GenericData data model} for datum instances&lt;br/&gt;
@@ -72,7 +72,7 @@ public RawMessageEncoder(GenericData model, Schema schema) {&lt;br/&gt;
    * {@link GenericData data model} to deconstruct datum instances described by&lt;br/&gt;
    * the {@link Schema schema}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* If 
{@code shouldCopy} is true, then buffers returned by {@link #encode(D)}&lt;br/&gt;
+   * If {@code shouldCopy}
&lt;p&gt; is true, then buffers returned by &lt;/p&gt;
{@link #encode(Object)}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;are copied and will not be modified by future calls to 
{@code encode}.&lt;br/&gt;
    * &amp;lt;p&amp;gt;&lt;br/&gt;
    * If {@code shouldCopy} is false, then buffers returned by {@code encode}
&lt;p&gt;diff --git a/lang/java/avro/src/main/java/org/apache/avro/specific/FixedSize.java b/lang/java/avro/src/main/java/org/apache/avro/specific/FixedSize.java&lt;br/&gt;
index 3068e9582..4a36cea84 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/avro/src/main/java/org/apache/avro/specific/FixedSize.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/specific/FixedSize.java&lt;br/&gt;
@@ -31,7 +31,10 @@&lt;br/&gt;
 @Target(
{ElementType.TYPE}
&lt;p&gt;)&lt;br/&gt;
 @Documented&lt;br/&gt;
 public @interface FixedSize &lt;/p&gt;
{
-  /** The declared size of instances of classes with this annotation. */
+  /**
+   * The declared size of instances of classes with this annotation.
+   * @return The size of the fixed size field
+   */
   int value();
 }&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/java/avro/src/main/java/org/apache/avro/specific/SpecificData.java b/lang/java/avro/src/main/java/org/apache/avro/specific/SpecificData.java&lt;br/&gt;
index 44de5c434..734854b81 100644&lt;br/&gt;
&amp;#8212; a/lang/java/avro/src/main/java/org/apache/avro/specific/SpecificData.java&lt;br/&gt;
+++ b/lang/java/avro/src/main/java/org/apache/avro/specific/SpecificData.java&lt;br/&gt;
@@ -119,7 +119,9 @@ public DatumWriter createDatumWriter(Schema schema) &lt;/p&gt;
{
     return new SpecificDatumWriter(schema, this);
   }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return the singleton instance. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @return the singleton instance.&lt;br/&gt;
+   */&lt;br/&gt;
   public static SpecificData get() 
{ return INSTANCE; }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   @Override&lt;br/&gt;
@@ -148,7 +150,11 @@ protected Schema getEnumSchema(Object datum) {&lt;br/&gt;
   private static final Class NO_CLASS = new Object(){}.getClass();&lt;br/&gt;
   private static final Schema NULL_SCHEMA = Schema.create(Schema.Type.NULL);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return the class that implements a schema, or null if none exists. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the class that implements a schema, or null if none exists.&lt;br/&gt;
+   * @param schema The schema of which we want to determine the class&lt;br/&gt;
+   * @return The class that belongs to the schema&lt;br/&gt;
+   */&lt;br/&gt;
   public Class getClass(Schema schema) {&lt;br/&gt;
     switch (schema.getType()) {&lt;br/&gt;
     case FIXED:&lt;br/&gt;
@@ -203,7 +209,10 @@ private Class getWrapper(Schema schema) 
{
     return getClass(schema);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns the Java class name indicated by a schema&apos;s name and namespace. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param schema The schema of which we want to determine the class name&lt;br/&gt;
+   * @return Java class name indicated by a schema&apos;s name and namespace.&lt;br/&gt;
+   */&lt;br/&gt;
   public static String getClassName(Schema schema) 
{
     String namespace = schema.getNamespace();
     String name = schema.getName();
@@ -231,7 +240,11 @@ public Schema load(java.lang.reflect.Type type)
             }
&lt;p&gt;           });&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Find the schema for a Java type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Find the schema for a Java type.&lt;br/&gt;
+   * @param type The type of which we want to determine the schema&lt;br/&gt;
+   * @return The schema for the given java type&lt;br/&gt;
+   */&lt;br/&gt;
   public Schema getSchema(java.lang.reflect.Type type) {&lt;br/&gt;
     try {&lt;br/&gt;
       return schemaCache.get(type);&lt;br/&gt;
@@ -241,7 +254,13 @@ public Schema getSchema(java.lang.reflect.Type type) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Create the schema for a Java type. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create the schema for a Java type.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param type The type of the schema&lt;br/&gt;
+   * @param names The names for the schema&lt;br/&gt;
+   * @return The generated schema&lt;br/&gt;
+   */&lt;br/&gt;
   @SuppressWarnings(value=&quot;unchecked&quot;)&lt;br/&gt;
   protected Schema createSchema(java.lang.reflect.Type type,&lt;br/&gt;
                                 Map&amp;lt;String,Schema&amp;gt; names) {&lt;br/&gt;
@@ -314,12 +333,21 @@ protected String getSchemaName(Object datum) 
{
     return super.getSchemaName(datum);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** True iff a class should be serialized with toString(). */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * @param c If the class can be converted to a String&lt;br/&gt;
+   * @return True iff a class should be serialized with toString().&lt;br/&gt;
+   */&lt;br/&gt;
   protected boolean isStringable(Class&amp;lt;?&amp;gt; c) 
{
     return stringableClasses.contains(c);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return the protocol for a Java interface. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the protocol for a Java interface.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface The class that is a protocol&lt;br/&gt;
+   * @throws NoSuchFieldException The class is not a protocol&lt;br/&gt;
+   * @return The protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public Protocol getProtocol(Class iface) {&lt;br/&gt;
     try {&lt;br/&gt;
       Protocol p = (Protocol)(iface.getDeclaredField(&quot;PROTOCOL&quot;).get(null));&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/CallFuture.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/CallFuture.java&lt;br/&gt;
index cc1f847f3..14eb7c732 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/main/java/org/apache/avro/ipc/CallFuture.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/CallFuture.java&lt;br/&gt;
@@ -26,6 +26,8 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A Future implementation for RPCs.&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; the type parameter&lt;br/&gt;
  */&lt;br/&gt;
 public class CallFuture&amp;lt;T&amp;gt; implements Future&amp;lt;T&amp;gt;, Callback&amp;lt;T&amp;gt; {&lt;br/&gt;
   private final CountDownLatch latch = new CountDownLatch(1);&lt;br/&gt;
@@ -43,6 +45,7 @@ public CallFuture() {&lt;br/&gt;
   /**&lt;/li&gt;
	&lt;li&gt;Creates a CallFuture with a chained Callback which will be invoked&lt;/li&gt;
	&lt;li&gt;when this CallFuture&apos;s Callback methods are invoked.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param chainedCallback the chained Callback to set.&lt;br/&gt;
    */&lt;br/&gt;
   public CallFuture(Callback&amp;lt;T&amp;gt; chainedCallback) {&lt;br/&gt;
@@ -82,8 +85,8 @@ public void handleError(Throwable error) {&lt;/li&gt;
	&lt;li&gt;Using 
{@link #get()} or {@link #get(long, TimeUnit)} is usually&lt;br/&gt;
    * preferred because these methods block until the result is available or&lt;br/&gt;
    * an error occurs.&lt;br/&gt;
-   * @return the value of the response, or null if no result was returned or&lt;br/&gt;
-   * the RPC has not yet completed.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the value of the response, or null if no result was returned or the RPC has not yet completed.&lt;br/&gt;
    */&lt;br/&gt;
   public T getResult() {&lt;br/&gt;
     return result;&lt;br/&gt;
@@ -93,8 +96,8 @@ public T getResult() {&lt;br/&gt;
    * Gets the error that was thrown during RPC execution.  Does not block.&lt;br/&gt;
    * Either {@link #get()}
&lt;p&gt; or &lt;/p&gt;
{@link #get(long, TimeUnit)}
&lt;p&gt; should be called&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;first because these methods block until the RPC has completed.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @return the RPC error that was thrown, or null if no error has occurred or&lt;/li&gt;
	&lt;li&gt;* if the RPC has not yet completed.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the RPC error that was thrown, or null if no error has occurred or if the RPC has not yet completed.&lt;br/&gt;
    */&lt;br/&gt;
   public Throwable getError() {&lt;br/&gt;
     return error;&lt;br/&gt;
@@ -135,6 +138,7 @@ public T get(long timeout, TimeUnit unit)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Waits for the CallFuture to complete without returning the result.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@throws InterruptedException if interrupted.&lt;br/&gt;
    */&lt;br/&gt;
   public void await() throws InterruptedException {&lt;br/&gt;
@@ -143,10 +147,11 @@ public void await() throws InterruptedException {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Waits for the CallFuture to complete without returning the result.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param timeout the maximum time to wait.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @param unit the time unit of the timeout argument.&lt;br/&gt;
+   * @param unit    the time unit of the timeout argument.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@throws InterruptedException if interrupted.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws TimeoutException if the wait timed out.&lt;br/&gt;
+   * @throws TimeoutException     if the wait timed out.&lt;br/&gt;
    */&lt;br/&gt;
   public void await(long timeout, TimeUnit unit)&lt;br/&gt;
     throws InterruptedException, TimeoutException {&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Callback.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Callback.java&lt;br/&gt;
index ac61c4b23..6d39a2c47 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Callback.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Callback.java&lt;br/&gt;
@@ -23,16 +23,20 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;For each request with an asynchronous callback,&lt;/li&gt;
	&lt;li&gt;either 
{@link #handleResult(Object)}
&lt;p&gt; or &lt;/p&gt;
{@link #handleError(Throwable)}&lt;/li&gt;
	&lt;li&gt;will be invoked.&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;T&amp;gt; the type parameter&lt;br/&gt;
  */&lt;br/&gt;
 public interface Callback&amp;lt;T&amp;gt; {&lt;br/&gt;
   /**&lt;/li&gt;
	&lt;li&gt;Receives a callback result.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param result the result returned in the callback.&lt;br/&gt;
    */&lt;br/&gt;
   void handleResult(T result);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Receives an error.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param error the error returned in the callback.&lt;br/&gt;
    */&lt;br/&gt;
   void handleError(Throwable error);&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/DatagramServer.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/DatagramServer.java&lt;br/&gt;
index 1f56519dd..453f0f616 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/main/java/org/apache/avro/ipc/DatagramServer.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/DatagramServer.java&lt;br/&gt;
@@ -27,8 +27,10 @@&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** A datagram-based server implementation. This uses a simple, non-standard&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* wire protocol and is not intended for production services. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * A datagram-based server implementation. This uses a simple, non-standard&lt;br/&gt;
+ * wire protocol and is not intended for production services.&lt;br/&gt;
+ */&lt;br/&gt;
 public class DatagramServer extends Thread implements Server {&lt;br/&gt;
   private static final Logger LOG =&lt;br/&gt;
     LoggerFactory.getLogger(DatagramServer.class);&lt;br/&gt;
@@ -37,6 +39,13 @@&lt;br/&gt;
   private final DatagramChannel channel;&lt;br/&gt;
   private final Transceiver transceiver;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Datagram server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   * @param addr      the addr&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public DatagramServer(Responder responder, SocketAddress addr)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     String name = &quot;DatagramServer on &quot;+addr;&lt;br/&gt;
@@ -69,6 +78,12 @@ public void run() {&lt;/p&gt;

&lt;p&gt;   public void close() &lt;/p&gt;
{ this.interrupt(); }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The entry point of application.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param arg the input arguments&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void main(String[] arg) throws Exception {&lt;br/&gt;
     DatagramServer server = new DatagramServer(null, new InetSocketAddress(0));&lt;br/&gt;
     server.start();&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/DatagramTransceiver.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/DatagramTransceiver.java&lt;br/&gt;
index 70c0545b3..10a4c98ef 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/DatagramTransceiver.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/DatagramTransceiver.java&lt;br/&gt;
@@ -28,8 +28,10 @@&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;/p&gt;

&lt;p&gt;-/** A datagram-based &lt;/p&gt;
{@link Transceiver} implementation. This uses a simple,&lt;br/&gt;
- * non-standard wire protocol and is not intended for production services. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * A datagram-based {@link Transceiver}
&lt;p&gt; implementation. This uses a simple,&lt;br/&gt;
+ * non-standard wire protocol and is not intended for production services.&lt;br/&gt;
+ */&lt;br/&gt;
 public class DatagramTransceiver extends Transceiver {&lt;br/&gt;
   private static final Logger LOG&lt;br/&gt;
     = LoggerFactory.getLogger(DatagramTransceiver.class);&lt;br/&gt;
@@ -42,11 +44,22 @@&lt;/p&gt;

&lt;p&gt;   public String getRemoteName() &lt;/p&gt;
{ return remote.toString(); }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Datagram transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param remote the remote&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public DatagramTransceiver(SocketAddress remote) throws IOException &lt;/p&gt;
{
     this(DatagramChannel.open());
     this.remote = remote;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Datagram transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param channel the channel&lt;br/&gt;
+   */&lt;br/&gt;
   public DatagramTransceiver(DatagramChannel channel) &lt;/p&gt;
{
     this.channel = channel;
   }
&lt;p&gt;diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/HttpServer.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/HttpServer.java&lt;br/&gt;
index 917a7230a..2813f3d10 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/HttpServer.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/HttpServer.java&lt;br/&gt;
@@ -31,26 +31,50 @@&lt;br/&gt;
 import org.eclipse.jetty.servlet.ServletHandler;&lt;br/&gt;
 import org.eclipse.jetty.servlet.ServletHolder;&lt;/p&gt;

&lt;p&gt;-/** An HTTP-based RPC &lt;/p&gt;
{@link Server}. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * An HTTP-based RPC {@link Server}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
 public class HttpServer implements Server {&lt;br/&gt;
   private org.eclipse.jetty.server.Server server;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Constructs a server to run on the named port. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Constructs a server to run on the named port.  @param responder the responder&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param port the port&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public HttpServer(Responder responder, int port) throws IOException 
{
     this(new ResponderServlet(responder), null, port);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Constructs a server to run on the named port. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Constructs a server to run on the named port.  @param servlet the servlet&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param port the port&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public HttpServer(ResponderServlet servlet, int port) throws IOException 
{
     this(servlet, null, port);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Constructs a server to run on the named port on the specified address. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Constructs a server to run on the named port on the specified address.  @param responder the responder&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param bindAddress the bind address&lt;br/&gt;
+   * @param port        the port&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public HttpServer(Responder responder, String bindAddress, int port) throws IOException 
{
     this(new ResponderServlet(responder), bindAddress, port);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Constructs a server to run on the named port on the specified address. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Constructs a server to run on the named port on the specified address.  @param servlet the servlet&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param bindAddress the bind address&lt;br/&gt;
+   * @param port        the port&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public HttpServer(ResponderServlet servlet, String bindAddress, int port) throws IOException 
{
     this.server = new org.eclipse.jetty.server.Server();
     ServerConnector connector = new ServerConnector(this.server);
@@ -69,12 +93,26 @@ public HttpServer(ResponderServlet servlet, String bindAddress, int port) throws
     server.setHandler(sch);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Constructs a server to run with the given ConnectionFactory on the given address/port. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Constructs a server to run with the given ConnectionFactory on the given address/port.  @param responder the responder&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param connectionFactory the connection factory&lt;br/&gt;
+   * @param bindAddress       the bind address&lt;br/&gt;
+   * @param port              the port&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public HttpServer(Responder responder, ConnectionFactory connectionFactory, String bindAddress, int port) throws IOException 
{
     this(new ResponderServlet(responder), connectionFactory, bindAddress, port);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Constructs a server to run with the given ConnectionFactory on the given address/port. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Constructs a server to run with the given ConnectionFactory on the given address/port.  @param servlet the servlet&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param connectionFactory the connection factory&lt;br/&gt;
+   * @param bindAddress       the bind address&lt;br/&gt;
+   * @param port              the port&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public HttpServer(ResponderServlet servlet, ConnectionFactory connectionFactory, String bindAddress, int port) throws IOException {&lt;br/&gt;
     this.server = new org.eclipse.jetty.server.Server();&lt;br/&gt;
     HttpConfiguration httpConfig = new HttpConfiguration();&lt;br/&gt;
@@ -94,7 +132,10 @@ public HttpServer(ResponderServlet servlet, ConnectionFactory connectionFactory,&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs a server to run with the given connector.&lt;br/&gt;
    *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*  @deprecated - use the Constructors that take a ConnectionFactory&lt;br/&gt;
+   * @param servlet   the servlet&lt;br/&gt;
+   * @param connector the connector&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   * @deprecated - use the Constructors that take a ConnectionFactory&lt;br/&gt;
    */&lt;br/&gt;
   @Deprecated&lt;br/&gt;
   public HttpServer(ResponderServlet servlet, Connector connector) throws IOException 
{
@@ -106,16 +147,25 @@ public HttpServer(ResponderServlet servlet, Connector connector) throws IOExcept
     server.setHandler(handler);
     handler.addServletWithMapping(new ServletHolder(servlet), &quot;/*&quot;);
   }
&lt;p&gt;+&lt;br/&gt;
   /**&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs a server to run with the given connector.&lt;br/&gt;
    *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*  @deprecated - use the Constructors that take a ConnectionFactory&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   * @param connector the connector&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   * @deprecated - use the Constructors that take a ConnectionFactory&lt;br/&gt;
    */&lt;br/&gt;
   @Deprecated&lt;br/&gt;
   public HttpServer(Responder responder, Connector connector) throws IOException 
{
     this(new ResponderServlet(responder), connector);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Add connector.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param connector the connector&lt;br/&gt;
+   */&lt;br/&gt;
   public void addConnector(Connector connector) &lt;/p&gt;
{
     server.addConnector(connector);
   }
&lt;p&gt;diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/HttpTransceiver.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/HttpTransceiver.java&lt;br/&gt;
index a46fcd405..012eb8e34 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/HttpTransceiver.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/HttpTransceiver.java&lt;br/&gt;
@@ -29,8 +29,13 @@&lt;br/&gt;
 import java.net.URL;&lt;br/&gt;
 import java.net.HttpURLConnection;&lt;/p&gt;

&lt;p&gt;-/** An HTTP-based &lt;/p&gt;
{@link Transceiver} implementation. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * An HTTP-based {@link Transceiver}
&lt;p&gt; implementation.&lt;br/&gt;
+ */&lt;br/&gt;
 public class HttpTransceiver extends Transceiver {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Content type.&lt;br/&gt;
+   */&lt;br/&gt;
   static final String CONTENT_TYPE = &quot;avro/binary&quot;;&lt;/p&gt;

&lt;p&gt;   private URL url;&lt;br/&gt;
@@ -38,14 +43,27 @@&lt;br/&gt;
   private HttpURLConnection connection;&lt;br/&gt;
   private int timeout;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Http transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param url the url&lt;br/&gt;
+   */&lt;br/&gt;
   public HttpTransceiver(URL url) &lt;/p&gt;
{ this.url = url; }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Http transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param url   the url&lt;br/&gt;
+   * @param proxy the proxy&lt;br/&gt;
+   */&lt;br/&gt;
   public HttpTransceiver(URL url, Proxy proxy) &lt;/p&gt;
{
     this(url);
     this.proxy = proxy;
   }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Set the connect and read timeouts, in milliseconds. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Set the connect and read timeouts, in milliseconds.  @param timeout the timeout&lt;br/&gt;
+   */&lt;br/&gt;
   public void setTimeout(int timeout) 
{ this.timeout = timeout; }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   public String getRemoteName() &lt;/p&gt;
{ return this.url.toString(); }
&lt;p&gt;@@ -82,6 +100,12 @@ public synchronized void writeBuffers(List&amp;lt;ByteBuffer&amp;gt; buffers)&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets length.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param buffers the buffers&lt;br/&gt;
+   * @return the length&lt;br/&gt;
+   */&lt;br/&gt;
   static int getLength(List&amp;lt;ByteBuffer&amp;gt; buffers) {&lt;br/&gt;
     int length = 0;&lt;br/&gt;
     for (ByteBuffer buffer : buffers) {&lt;br/&gt;
@@ -92,6 +116,13 @@ static int getLength(List&amp;lt;ByteBuffer&amp;gt; buffers) &lt;/p&gt;
{
     return length;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Read buffers list.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param in the in&lt;br/&gt;
+   * @return the list&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   static List&amp;lt;ByteBuffer&amp;gt; readBuffers(InputStream in)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     List&amp;lt;ByteBuffer&amp;gt; buffers = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -113,6 +144,13 @@ static int getLength(List&amp;lt;ByteBuffer&amp;gt; buffers) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Write buffers.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param buffers the buffers&lt;br/&gt;
+   * @param out     the out&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   static void writeBuffers(List&amp;lt;ByteBuffer&amp;gt; buffers, OutputStream out)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     for (ByteBuffer buffer : buffers) {&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Ipc.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Ipc.java&lt;br/&gt;
index 06bf04168..3a623e2e6 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Ipc.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Ipc.java&lt;br/&gt;
@@ -22,11 +22,18 @@&lt;br/&gt;
 import java.net.InetSocketAddress;&lt;br/&gt;
 import java.net.URI;&lt;/p&gt;

&lt;p&gt;-/** IPC utilities, including client and server factories. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * IPC utilities, including client and server factories.&lt;br/&gt;
+ */&lt;br/&gt;
 public class Ipc {&lt;br/&gt;
   private Ipc() {}                                // no public ctor&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Create a client 
{@link Transceiver} connecting to the provided URI. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a client {@link Transceiver}
&lt;p&gt; connecting to the provided URI.  @param uri the uri&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static Transceiver createTransceiver(URI uri) throws IOException &lt;/p&gt;
{
     if (&quot;http&quot;.equals(uri.getScheme()))
        return new HttpTransceiver(uri.toURL());
@@ -37,8 +44,14 @@ else if (&quot;avro&quot;.equals(uri.getScheme()))
       throw new IOException(&quot;unknown uri scheme: &quot;+uri);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Create a 
{@link Server} listening at the named URI using the provided&lt;br/&gt;
-   * responder. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a {@link Server}
&lt;p&gt; listening at the named URI using the provided&lt;br/&gt;
+   * responder.  @param responder the responder&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param uri the uri&lt;br/&gt;
+   * @return the server&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static Server createServer(Responder responder,&lt;br/&gt;
                                     URI uri) throws IOException {&lt;br/&gt;
     if (&quot;http&quot;.equals(uri.getScheme()))&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/LocalTransceiver.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/LocalTransceiver.java&lt;br/&gt;
index c9041368e..03f420fda 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/main/java/org/apache/avro/ipc/LocalTransceiver.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/LocalTransceiver.java&lt;br/&gt;
@@ -21,10 +21,17 @@&lt;br/&gt;
 import java.nio.ByteBuffer;&lt;br/&gt;
 import java.util.List;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** Implementation of IPC that remains in process. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Implementation of IPC that remains in process.&lt;br/&gt;
+ */&lt;br/&gt;
 public class LocalTransceiver extends Transceiver {&lt;br/&gt;
   private Responder responder;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Local transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   */&lt;br/&gt;
   public LocalTransceiver(Responder responder) &lt;/p&gt;
{
     this.responder = responder;
   }&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyServer.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyServer.java&lt;br/&gt;
index 2e299a013..1aa662db5 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyServer.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyServer.java&lt;br/&gt;
@@ -64,23 +64,37 @@&lt;br/&gt;
   private final CountDownLatch closed = new CountDownLatch(1);&lt;br/&gt;
   private final ExecutionHandler executionHandler;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Netty server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   * @param addr      the addr&lt;br/&gt;
+   */&lt;br/&gt;
   public NettyServer(Responder responder, InetSocketAddress addr) {
     this(responder, addr, new NioServerSocketChannelFactory
          (Executors .newCachedThreadPool(), Executors.newCachedThreadPool()));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Netty server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder      the responder&lt;br/&gt;
+   * @param addr           the addr&lt;br/&gt;
+   * @param channelFactory the channel factory&lt;br/&gt;
+   */&lt;br/&gt;
   public NettyServer(Responder responder, InetSocketAddress addr,&lt;br/&gt;
                      ChannelFactory channelFactory) {
       this(responder, addr, channelFactory, null);
   }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
-   * @param executionHandler if not null, will be inserted into the Netty&lt;br/&gt;
-   *                         pipeline. Use this when your responder does&lt;br/&gt;
-   *                         long, non-cpu bound processing (see Netty&apos;s&lt;br/&gt;
-   *                         ExecutionHandler javadoc).&lt;br/&gt;
-   * @param pipelineFactory  Avro-related handlers will be added on top of&lt;br/&gt;
-   *                         what this factory creates&lt;br/&gt;
+   * Instantiates a new Netty server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder        the responder&lt;br/&gt;
+   * @param addr             the addr&lt;br/&gt;
+   * @param channelFactory   the channel factory&lt;br/&gt;
+   * @param pipelineFactory  Avro-related handlers will be added on top of                         what this factory creates&lt;br/&gt;
+   * @param executionHandler if not null, will be inserted into the Netty                         pipeline. Use this when your responder does                         long, non-cpu bound processing (see Netty&apos;s                         ExecutionHandler javadoc).&lt;br/&gt;
    */&lt;br/&gt;
   public NettyServer(Responder responder, InetSocketAddress addr,&lt;br/&gt;
                      ChannelFactory channelFactory,&lt;br/&gt;
@@ -108,10 +122,12 @@ public ChannelPipeline getPipeline() throws Exception {&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
-   * @param executionHandler if not null, will be inserted into the Netty&lt;br/&gt;
-   *                         pipeline. Use this when your responder does&lt;br/&gt;
-   *                         long, non-cpu bound processing (see Netty&apos;s&lt;br/&gt;
-   *                         ExecutionHandler javadoc).&lt;br/&gt;
+   * Instantiates a new Netty server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder        the responder&lt;br/&gt;
+   * @param addr             the addr&lt;br/&gt;
+   * @param channelFactory   the channel factory&lt;br/&gt;
+   * @param executionHandler if not null, will be inserted into the Netty                         pipeline. Use this when your responder does                         long, non-cpu bound processing (see Netty&apos;s                         ExecutionHandler javadoc).&lt;br/&gt;
    */&lt;br/&gt;
   public NettyServer(Responder responder, InetSocketAddress addr,&lt;br/&gt;
                      ChannelFactory channelFactory,&lt;br/&gt;
@@ -148,6 +164,7 @@ public void join() throws InterruptedException {&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
+   * Gets num active connections.&lt;br/&gt;
    *&lt;br/&gt;
    * @return The number of clients currently connected to this server.&lt;br/&gt;
    */&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyTransceiver.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyTransceiver.java&lt;br/&gt;
index 107aac8ba..0c19bec38 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyTransceiver.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyTransceiver.java&lt;br/&gt;
@@ -59,12 +59,26 @@&lt;br/&gt;
  * A Netty-based {@link Transceiver} implementation.&lt;br/&gt;
  */&lt;br/&gt;
 public class NettyTransceiver extends Transceiver {&lt;br/&gt;
-  /** If not specified, the default connection timeout will be used (60 sec). */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * If not specified, the default connection timeout will be used (60 sec).&lt;br/&gt;
+   */&lt;br/&gt;
   public static final long DEFAULT_CONNECTION_TIMEOUT_MILLIS = 60 * 1000L;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant NETTY_CONNECT_TIMEOUT_OPTION.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final String NETTY_CONNECT_TIMEOUT_OPTION =&lt;br/&gt;
       &quot;connectTimeoutMillis&quot;;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant NETTY_TCP_NODELAY_OPTION.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final String NETTY_TCP_NODELAY_OPTION = &quot;tcpNoDelay&quot;;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant NETTY_KEEPALIVE_OPTION.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final String NETTY_KEEPALIVE_OPTION = &quot;keepAlive&quot;;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant DEFAULT_TCP_NODELAY_VALUE.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final boolean DEFAULT_TCP_NODELAY_VALUE = true;&lt;br/&gt;
 &lt;br/&gt;
   private static final Logger LOG = LoggerFactory.getLogger(NettyTransceiver.class&lt;br/&gt;
@@ -79,7 +93,13 @@&lt;br/&gt;
   private final ClientBootstrap bootstrap;&lt;br/&gt;
   private final InetSocketAddress remoteAddr;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Channel future.&lt;br/&gt;
+   */&lt;br/&gt;
   volatile ChannelFuture channelFuture;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Stopping.&lt;br/&gt;
+   */&lt;br/&gt;
   volatile boolean stopping;&lt;br/&gt;
   private final Object channelFutureLock = new Object();&lt;br/&gt;
 &lt;br/&gt;
@@ -91,6 +111,9 @@&lt;br/&gt;
   private Channel channel;       // Synchronized on stateLock&lt;br/&gt;
   private Protocol remote;       // Synchronized on stateLock&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Netty transceiver.&lt;br/&gt;
+   */&lt;br/&gt;
   NettyTransceiver() {&lt;br/&gt;
     channelFactory = null;&lt;br/&gt;
     connectTimeoutMillis = 0L;&lt;br/&gt;
@@ -103,6 +126,7 @@&lt;br/&gt;
    * Creates a NettyTransceiver, and attempts to connect to the given address.&lt;br/&gt;
    * {@link #DEFAULT_CONNECTION_TIMEOUT_MILLIS} is used for the connection&lt;br/&gt;
    * timeout.&lt;br/&gt;
+   *&lt;br/&gt;
    * @param addr the address to connect to.&lt;br/&gt;
    * @throws IOException if an error occurs connecting to the given address.&lt;br/&gt;
    */&lt;br/&gt;
@@ -112,10 +136,9 @@ public NettyTransceiver(InetSocketAddress addr) throws IOException {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Creates a NettyTransceiver, and attempts to connect to the given address.&lt;br/&gt;
-   * @param addr the address to connect to.&lt;br/&gt;
-   * @param connectTimeoutMillis maximum amount of time to wait for connection&lt;br/&gt;
-   * establishment in milliseconds, or null to use&lt;br/&gt;
-   * {@link #DEFAULT_CONNECTION_TIMEOUT_MILLIS}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param addr                 the address to connect to.&lt;br/&gt;
+   * @param connectTimeoutMillis maximum amount of time to wait for connection establishment in milliseconds, or null to use {@link #DEFAULT_CONNECTION_TIMEOUT_MILLIS}.&lt;br/&gt;
    * @throws IOException if an error occurs connecting to the given address.&lt;br/&gt;
    */&lt;br/&gt;
   public NettyTransceiver(InetSocketAddress addr,&lt;br/&gt;
@@ -132,7 +155,8 @@ public NettyTransceiver(InetSocketAddress addr,&lt;br/&gt;
    * Creates a NettyTransceiver, and attempts to connect to the given address.&lt;br/&gt;
    * {@link #DEFAULT_CONNECTION_TIMEOUT_MILLIS} is used for the connection&lt;br/&gt;
    * timeout.&lt;br/&gt;
-   * @param addr the address to connect to.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param addr           the address to connect to.&lt;br/&gt;
    * @param channelFactory the factory to use to create a new Netty Channel.&lt;br/&gt;
    * @throws IOException if an error occurs connecting to the given address.&lt;br/&gt;
    */&lt;br/&gt;
@@ -143,11 +167,10 @@ public NettyTransceiver(InetSocketAddress addr, ChannelFactory channelFactory)&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Creates a NettyTransceiver, and attempts to connect to the given address.&lt;br/&gt;
-   * @param addr the address to connect to.&lt;br/&gt;
-   * @param channelFactory the factory to use to create a new Netty Channel.&lt;br/&gt;
-   * @param connectTimeoutMillis maximum amount of time to wait for connection&lt;br/&gt;
-   * establishment in milliseconds, or null to use&lt;br/&gt;
-   * {@link #DEFAULT_CONNECTION_TIMEOUT_MILLIS}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param addr                 the address to connect to.&lt;br/&gt;
+   * @param channelFactory       the factory to use to create a new Netty Channel.&lt;br/&gt;
+   * @param connectTimeoutMillis maximum amount of time to wait for connection establishment in milliseconds, or null to use {@link #DEFAULT_CONNECTION_TIMEOUT_MILLIS}.&lt;br/&gt;
    * @throws IOException if an error occurs connecting to the given address.&lt;br/&gt;
    */&lt;br/&gt;
   public NettyTransceiver(InetSocketAddress addr, ChannelFactory channelFactory,&lt;br/&gt;
@@ -163,10 +186,10 @@ public NettyTransceiver(InetSocketAddress addr, ChannelFactory channelFactory,&lt;br/&gt;
    * to prevent connect/disconnect attempts from hanging indefinitely.  It is&lt;br/&gt;
    * also recommended that the {@link #NETTY_TCP_NODELAY_OPTION} option be set&lt;br/&gt;
    * to true to minimize RPC latency.&lt;br/&gt;
-   * @param addr the address to connect to.&lt;br/&gt;
-   * @param channelFactory the factory to use to create a new Netty Channel.&lt;br/&gt;
-   * @param nettyClientBootstrapOptions map of Netty ClientBootstrap options&lt;br/&gt;
-   * to use.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param addr                        the address to connect to.&lt;br/&gt;
+   * @param channelFactory              the factory to use to create a new Netty Channel.&lt;br/&gt;
+   * @param nettyClientBootstrapOptions map of Netty ClientBootstrap options to use.&lt;br/&gt;
    * @throws IOException if an error occurs connecting to the given address.&lt;br/&gt;
    */&lt;br/&gt;
   public NettyTransceiver(InetSocketAddress addr, ChannelFactory channelFactory,&lt;br/&gt;
@@ -224,6 +247,7 @@ public ChannelPipeline getPipeline() throws Exception {&lt;br/&gt;
   /**&lt;br/&gt;
    * Creates a Netty ChannelUpstreamHandler for handling events on the&lt;br/&gt;
    * Netty client channel.&lt;br/&gt;
+   *&lt;br/&gt;
    * @return the ChannelUpstreamHandler to use.&lt;br/&gt;
    */&lt;br/&gt;
   protected ChannelUpstreamHandler createNettyClientAvroHandler() {&lt;br/&gt;
@@ -232,8 +256,8 @@ protected ChannelUpstreamHandler createNettyClientAvroHandler() {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Creates the default options map for the Netty ClientBootstrap.&lt;br/&gt;
-   * @param connectTimeoutMillis connection timeout in milliseconds, or null&lt;br/&gt;
-   * if no timeout is desired.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param connectTimeoutMillis connection timeout in milliseconds, or null if no timeout is desired.&lt;br/&gt;
    * @return the map of Netty bootstrap options.&lt;br/&gt;
    */&lt;br/&gt;
   protected static Map&amp;lt;String, Object&amp;gt; buildDefaultBootstrapOptions(&lt;br/&gt;
@@ -423,6 +447,7 @@ public void close() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Closes this transceiver and disconnects from the remote peer.&lt;br/&gt;
    * Cancels all pending RPCs and sends an IOException to all pending callbacks.&lt;br/&gt;
+   *&lt;br/&gt;
    * @param awaitCompletion if true, will block until the close has completed.&lt;br/&gt;
    */&lt;br/&gt;
   public void close(boolean awaitCompletion) {&lt;br/&gt;
@@ -555,11 +580,15 @@ public void setRemote(Protocol protocol) {&lt;br/&gt;
    * a {@link Callback} if an error occurs while writing to the channel.&lt;br/&gt;
    */&lt;br/&gt;
   protected class WriteFutureListener implements ChannelFutureListener {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Callback.&lt;br/&gt;
+     */&lt;br/&gt;
     protected final Callback&amp;lt;List&amp;lt;ByteBuffer&amp;gt;&amp;gt; callback;&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a WriteFutureListener that notifies the given callback&lt;br/&gt;
      * if an error occurs writing data to the channel.&lt;br/&gt;
+     *&lt;br/&gt;
      * @param callback the callback to notify, or null to skip notification.&lt;br/&gt;
      */&lt;br/&gt;
     public WriteFutureListener(Callback&amp;lt;List&amp;lt;ByteBuffer&amp;gt;&amp;gt; callback) {&lt;br/&gt;
@@ -633,9 +662,8 @@ public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a NettyTransceiverThreadFactory that creates threads with the&lt;br/&gt;
      * specified name.&lt;br/&gt;
-     * @param prefix the name prefix to use for all threads created by this&lt;br/&gt;
-     * ThreadFactory.  A unique ID will be appended to this prefix to form the&lt;br/&gt;
-     * final thread name.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param prefix the name prefix to use for all threads created by this ThreadFactory.  A unique ID will be appended to this prefix to form the final thread name.&lt;br/&gt;
      */&lt;br/&gt;
     public NettyTransceiverThreadFactory(String prefix) {&lt;br/&gt;
       this.prefix = prefix;&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyTransportCodec.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyTransportCodec.java&lt;br/&gt;
index 80f1f83f0..3cc79d7c3 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyTransportCodec.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/NettyTransportCodec.java&lt;br/&gt;
@@ -41,25 +41,54 @@&lt;br/&gt;
     private int serial; // to track each call in client side&lt;br/&gt;
     private List&amp;lt;ByteBuffer&amp;gt; datas;&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Netty data pack.&lt;br/&gt;
+     */&lt;br/&gt;
     public NettyDataPack() {}&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Netty data pack.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param serial the serial&lt;br/&gt;
+     * @param datas  the datas&lt;br/&gt;
+     */&lt;br/&gt;
     public NettyDataPack(int serial, List&amp;lt;ByteBuffer&amp;gt; datas) {
       this.serial = serial;
       this.datas = datas;
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets serial.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param serial the serial&lt;br/&gt;
+     */&lt;br/&gt;
     public void setSerial(int serial) {
       this.serial = serial;
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Gets serial.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the serial&lt;br/&gt;
+     */&lt;br/&gt;
     public int getSerial() {
       return serial;
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Sets datas.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param datas the datas&lt;br/&gt;
+     */&lt;br/&gt;
     public void setDatas(List&amp;lt;ByteBuffer&amp;gt; datas) {
       this.datas = datas;
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Gets datas.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the datas&lt;br/&gt;
+     */&lt;br/&gt;
     public List&amp;lt;ByteBuffer&amp;gt; getDatas() {
       return datas;
     }&lt;br/&gt;
@@ -124,6 +153,9 @@ private ByteBuffer getLengthHeader(ByteBuffer buf) {&lt;br/&gt;
     private static final long SIZEOF_REF = 8L; // mem usage of 64-bit pointer&lt;br/&gt;
 &lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Netty frame decoder.&lt;br/&gt;
+     */&lt;br/&gt;
     public NettyFrameDecoder() {
       maxMem = Runtime.getRuntime().maxMemory();
     }&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/RPCContext.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/RPCContext.java&lt;br/&gt;
index 161b8d699..181d9b2b3 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/RPCContext.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/RPCContext.java&lt;br/&gt;
@@ -31,37 +31,62 @@&lt;br/&gt;
  * including handshake and call metadata. Note: this data includes&lt;br/&gt;
  * full copies of the RPC payload, so plugins which store RPCContexts&lt;br/&gt;
  * beyond the life of each call should be conscious of memory use.&lt;br/&gt;
- *&lt;br/&gt;
  */&lt;br/&gt;
 public class RPCContext {&lt;br/&gt;
 &lt;br/&gt;
   private HandshakeRequest handshakeRequest;&lt;br/&gt;
   private HandshakeResponse handshakeResponse;&lt;br/&gt;
 &lt;br/&gt;
-  protected Map&amp;lt;String,ByteBuffer&amp;gt; requestCallMeta, responseCallMeta;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Request call meta.&lt;br/&gt;
+   */&lt;br/&gt;
+  protected Map&amp;lt;String,ByteBuffer&amp;gt; requestCallMeta, /**&lt;br/&gt;
+   * The Response call meta.&lt;br/&gt;
+   */&lt;br/&gt;
+  responseCallMeta;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Response.&lt;br/&gt;
+   */&lt;br/&gt;
   protected Object response;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Error.&lt;br/&gt;
+   */&lt;br/&gt;
   protected Exception error;&lt;br/&gt;
   private Message message;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Request payload.&lt;br/&gt;
+   */&lt;br/&gt;
   List&amp;lt;ByteBuffer&amp;gt; requestPayload;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Response payload.&lt;br/&gt;
+   */&lt;br/&gt;
   List&amp;lt;ByteBuffer&amp;gt; responsePayload;&lt;br/&gt;
 &lt;br/&gt;
-  /** Set the handshake request of this RPC. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Set the handshake request of this RPC.  @param handshakeRequest the handshake request&lt;br/&gt;
+   */&lt;br/&gt;
   public void setHandshakeRequest(HandshakeRequest handshakeRequest) {
     this.handshakeRequest = handshakeRequest;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Get the handshake request of this RPC. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Get the handshake request of this RPC.  @return the handshake request&lt;br/&gt;
+   */&lt;br/&gt;
   public HandshakeRequest getHandshakeRequest() {
     return this.handshakeRequest;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Set the handshake response of this RPC. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Set the handshake response of this RPC.  @param handshakeResponse the handshake response&lt;br/&gt;
+   */&lt;br/&gt;
   public void setHandshakeResponse(HandshakeResponse handshakeResponse) {
     this.handshakeResponse = handshakeResponse;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Get the handshake response of this RPC. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Get the handshake response of this RPC.  @return the handshake response&lt;br/&gt;
+   */&lt;br/&gt;
   public HandshakeResponse getHandshakeResponse() {
     return this.handshakeResponse;
   }&lt;br/&gt;
@@ -69,8 +94,8 @@ public HandshakeResponse getHandshakeResponse() {&lt;br/&gt;
   /**&lt;br/&gt;
    * This is an access method for the handshake state&lt;br/&gt;
    * provided by the client to the server.&lt;br/&gt;
-   * @return a map representing handshake state from&lt;br/&gt;
-   * the client to the server&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return a map representing handshake state from the client to the server&lt;br/&gt;
    */&lt;br/&gt;
   public Map&amp;lt;String,ByteBuffer&amp;gt; requestHandshakeMeta() {&lt;br/&gt;
     if (handshakeRequest.meta == null)&lt;br/&gt;
@@ -78,6 +103,11 @@ public HandshakeResponse getHandshakeResponse() {
     return handshakeRequest.meta;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets request handshake meta.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param newmeta the newmeta&lt;br/&gt;
+   */&lt;br/&gt;
   void setRequestHandshakeMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {
     handshakeRequest.meta = newmeta;
   }&lt;br/&gt;
@@ -85,8 +115,8 @@ void setRequestHandshakeMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {&lt;br/&gt;
   /**&lt;br/&gt;
    * This is an access method for the handshake state&lt;br/&gt;
    * provided by the server back to the client&lt;br/&gt;
-   * @return a map representing handshake state from&lt;br/&gt;
-   * the server to the client&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return a map representing handshake state from the server to the client&lt;br/&gt;
    */&lt;br/&gt;
   public Map&amp;lt;String,ByteBuffer&amp;gt; responseHandshakeMeta() {&lt;br/&gt;
     if (handshakeResponse.meta == null)&lt;br/&gt;
@@ -94,6 +124,11 @@ void setRequestHandshakeMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {
     return handshakeResponse.meta;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets response handshake meta.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param newmeta the newmeta&lt;br/&gt;
+   */&lt;br/&gt;
   void setResponseHandshakeMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {
     handshakeResponse.meta = newmeta;
   }&lt;br/&gt;
@@ -101,8 +136,8 @@ void setResponseHandshakeMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {&lt;br/&gt;
   /**&lt;br/&gt;
    * This is an access method for the per-call state&lt;br/&gt;
    * provided by the client to the server.&lt;br/&gt;
-   * @return a map representing per-call state from&lt;br/&gt;
-   * the client to the server&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return a map representing per-call state from the client to the server&lt;br/&gt;
    */&lt;br/&gt;
   public Map&amp;lt;String,ByteBuffer&amp;gt; requestCallMeta() {&lt;br/&gt;
     if (requestCallMeta == null) {&lt;br/&gt;
@@ -111,6 +146,11 @@ void setResponseHandshakeMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {
     return requestCallMeta;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets request call meta.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param newmeta the newmeta&lt;br/&gt;
+   */&lt;br/&gt;
   void setRequestCallMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {
     requestCallMeta = newmeta;
   }&lt;br/&gt;
@@ -118,8 +158,8 @@ void setRequestCallMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {&lt;br/&gt;
   /**&lt;br/&gt;
    * This is an access method for the per-call state&lt;br/&gt;
    * provided by the server back to the client.&lt;br/&gt;
-   * @return a map representing per-call state from&lt;br/&gt;
-   * the server to the client&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return a map representing per-call state from the server to the client&lt;br/&gt;
    */&lt;br/&gt;
   public Map&amp;lt;String,ByteBuffer&amp;gt; responseCallMeta() {&lt;br/&gt;
     if (responseCallMeta == null) {&lt;br/&gt;
@@ -128,10 +168,20 @@ void setRequestCallMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {
     return responseCallMeta;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets response call meta.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param newmeta the newmeta&lt;br/&gt;
+   */&lt;br/&gt;
   void setResponseCallMeta(Map&amp;lt;String,ByteBuffer&amp;gt; newmeta) {
     responseCallMeta = newmeta;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets response.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param response the response&lt;br/&gt;
+   */&lt;br/&gt;
   void setResponse(Object response) {&lt;br/&gt;
     this.response = response;&lt;br/&gt;
     this.error = null;&lt;br/&gt;
@@ -141,13 +191,18 @@ void setResponse(Object response) {&lt;br/&gt;
    * The response object generated at the server,&lt;br/&gt;
    * if it exists.  If an exception was generated,&lt;br/&gt;
    * this will be null.&lt;br/&gt;
-   * @return the response created by this RPC, no&lt;br/&gt;
-   * null if an exception was generated&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the response created by this RPC, no null if an exception was generated&lt;br/&gt;
    */&lt;br/&gt;
   public Object response() {
     return response;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param error the error&lt;br/&gt;
+   */&lt;br/&gt;
   void setError(Exception error) {&lt;br/&gt;
     this.response = null;&lt;br/&gt;
     this.error = error;&lt;br/&gt;
@@ -156,8 +211,8 @@ void setError(Exception error) {&lt;br/&gt;
   /**&lt;br/&gt;
    * The exception generated at the server,&lt;br/&gt;
    * or null if no such exception has occurred&lt;br/&gt;
-   * @return the exception generated at the server, or&lt;br/&gt;
-   * null if no such exception&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the exception generated at the server, or null if no such exception&lt;br/&gt;
    */&lt;br/&gt;
   public Exception error() {&lt;br/&gt;
     return error;&lt;br/&gt;
@@ -166,49 +221,61 @@ public Exception error() {&lt;br/&gt;
   /**&lt;br/&gt;
    * Indicates whether an exception was generated&lt;br/&gt;
    * at the server&lt;br/&gt;
-   * @return true is an exception was generated at&lt;br/&gt;
-   * the server, or false if not&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return true is an exception was generated at the server, or false if not&lt;br/&gt;
    */&lt;br/&gt;
   public boolean isError() {
     return error != null;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Sets the {@link Message} corresponding to this RPC */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets the {@link Message} corresponding to this RPC  @param message the message&lt;br/&gt;
+   */&lt;br/&gt;
   public void setMessage(Message message) {
     this.message = message;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns the {@link Message} corresponding to this RPC&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns the {@link Message} corresponding to this RPC&lt;br/&gt;
+   *&lt;br/&gt;
    * @return this RPC&apos;s {@link Message}&lt;br/&gt;
    */&lt;br/&gt;
   public Message getMessage() { return message; }&lt;br/&gt;
 &lt;br/&gt;
-  /** Sets the serialized payload of the request in this RPC. Will&lt;br/&gt;
-   * not include handshake or meta-data. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets the serialized payload of the request in this RPC. Will&lt;br/&gt;
+   * not include handshake or meta-data.  @param payload the payload&lt;br/&gt;
+   */&lt;br/&gt;
   public void setRequestPayload(List&amp;lt;ByteBuffer&amp;gt; payload) {
     this.requestPayload = payload;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns the serialized payload of the request in this RPC. Will only be&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns the serialized payload of the request in this RPC. Will only be&lt;br/&gt;
    * generated from a Requestor and will not include handshake or meta-data.&lt;br/&gt;
    * If the request payload has not been set yet, returns null.&lt;br/&gt;
    *&lt;br/&gt;
-   * @return this RPC&apos;s request payload.*/&lt;br/&gt;
+   * @return this RPC&apos;s request payload.&lt;br/&gt;
+   */&lt;br/&gt;
   public List&amp;lt;ByteBuffer&amp;gt; getRequestPayload() {
     return this.requestPayload;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns the serialized payload of the response in this RPC. Will only be&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns the serialized payload of the response in this RPC. Will only be&lt;br/&gt;
    * generated from a Responder and will not include handshake or meta-data.&lt;br/&gt;
    * If the response payload has not been set yet, returns null.&lt;br/&gt;
    *&lt;br/&gt;
-   * @return this RPC&apos;s response payload.*/&lt;br/&gt;
+   * @return this RPC&apos;s response payload.&lt;br/&gt;
+   */&lt;br/&gt;
   public List&amp;lt;ByteBuffer&amp;gt; getResponsePayload() {
     return this.responsePayload;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Sets the serialized payload of the response in this RPC. Will&lt;br/&gt;
-   * not include handshake or meta-data. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Sets the serialized payload of the response in this RPC. Will&lt;br/&gt;
+   * not include handshake or meta-data.  @param payload the payload&lt;br/&gt;
+   */&lt;br/&gt;
   public void setResponsePayload(List&amp;lt;ByteBuffer&amp;gt; payload) {
     this.responsePayload = payload;
   }&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/RPCPlugin.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/RPCPlugin.java&lt;br/&gt;
index abce0e743..ca09857fb 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/RPCPlugin.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/RPCPlugin.java&lt;br/&gt;
@@ -28,24 +28,28 @@&lt;br/&gt;
   /**&lt;br/&gt;
    * Called on the client before the initial RPC handshake to&lt;br/&gt;
    * setup any handshake metadata for this plugin&lt;br/&gt;
+   *&lt;br/&gt;
    * @param context the handshake rpc context&lt;br/&gt;
    */&lt;br/&gt;
   public void clientStartConnect(RPCContext context) { }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Called on the server during the RPC handshake&lt;br/&gt;
+   *&lt;br/&gt;
    * @param context the handshake rpc context&lt;br/&gt;
    */&lt;br/&gt;
   public void serverConnecting(RPCContext context) { }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Called on the client after the initial RPC handshake&lt;br/&gt;
+   *&lt;br/&gt;
    * @param context the handshake rpc context&lt;br/&gt;
    */&lt;br/&gt;
   public void clientFinishConnect(RPCContext context) { }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * This method is invoked at the client before it issues the RPC call.&lt;br/&gt;
+   *&lt;br/&gt;
    * @param context the per-call rpc context (in/out parameter)&lt;br/&gt;
    */&lt;br/&gt;
   public void clientSendRequest(RPCContext context) { }&lt;br/&gt;
@@ -54,6 +58,7 @@ public void clientSendRequest(RPCContext context) { }&lt;br/&gt;
   /**&lt;br/&gt;
    * This method is invoked at the RPC server when the request is received,&lt;br/&gt;
    * but before the call itself is executed&lt;br/&gt;
+   *&lt;br/&gt;
    * @param context the per-call rpc context (in/out parameter)&lt;br/&gt;
    */&lt;br/&gt;
   public void serverReceiveRequest(RPCContext context) { }&lt;br/&gt;
@@ -61,6 +66,7 @@ public void serverReceiveRequest(RPCContext context) { }&lt;br/&gt;
   /**&lt;br/&gt;
    * This method is invoked at the server before the response is executed,&lt;br/&gt;
    * but before the response has been formulated&lt;br/&gt;
+   *&lt;br/&gt;
    * @param context the per-call rpc context (in/out parameter)&lt;br/&gt;
    */&lt;br/&gt;
   public void serverSendResponse(RPCContext context) { }&lt;br/&gt;
@@ -68,6 +74,7 @@ public void serverSendResponse(RPCContext context) { }&lt;br/&gt;
   /**&lt;br/&gt;
    * This method is invoked at the client after the call is executed,&lt;br/&gt;
    * and after the client receives the response&lt;br/&gt;
+   *&lt;br/&gt;
    * @param context the per-call rpc context&lt;br/&gt;
    */&lt;br/&gt;
   public void clientReceiveResponse(RPCContext context) { }&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Requestor.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Requestor.java&lt;br/&gt;
index 92d77d781..da4fcd719 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Requestor.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Requestor.java&lt;br/&gt;
@@ -48,7 +48,9 @@&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
 &lt;br/&gt;
-/** Base class for the client side of a protocol interaction. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Base class for the client side of a protocol interaction.&lt;br/&gt;
+ */&lt;br/&gt;
 public abstract class Requestor {&lt;br/&gt;
   private static final Logger LOG = LoggerFactory.getLogger(Requestor.class);&lt;br/&gt;
 &lt;br/&gt;
@@ -65,11 +67,32 @@&lt;br/&gt;
   private final Transceiver transceiver;&lt;br/&gt;
   private final ReentrantLock handshakeLock = new ReentrantLock();&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Rpc meta plugins.&lt;br/&gt;
+   */&lt;br/&gt;
   protected final List&amp;lt;RPCPlugin&amp;gt; rpcMetaPlugins;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets local.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the local&lt;br/&gt;
+   */&lt;br/&gt;
   public Protocol getLocal() { return local; }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the transceiver&lt;br/&gt;
+   */&lt;br/&gt;
   public Transceiver getTransceiver() { return transceiver; }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param local       the local&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   protected Requestor(Protocol local, Transceiver transceiver)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     this.local = local;&lt;br/&gt;
@@ -81,6 +104,7 @@ protected Requestor(Protocol local, Transceiver transceiver)&lt;br/&gt;
   /**&lt;br/&gt;
    * Adds a new plugin to manipulate RPC metadata.  Plugins&lt;br/&gt;
    * are executed in the order that they are added.&lt;br/&gt;
+   *&lt;br/&gt;
    * @param plugin a plugin that will manipulate RPC metadata&lt;br/&gt;
    */&lt;br/&gt;
   public void addRPCPlugin(RPCPlugin plugin) {&lt;br/&gt;
@@ -89,7 +113,13 @@ public void addRPCPlugin(RPCPlugin plugin) {&lt;br/&gt;
 &lt;br/&gt;
   private static final EncoderFactory ENCODER_FACTORY = new EncoderFactory();&lt;br/&gt;
 &lt;br/&gt;
-  /** Writes a request message and reads a response or error message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Writes a request message and reads a response or error message.  @param messageName the message name&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param request the request&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public Object request(String messageName, Object request)&lt;br/&gt;
     throws Exception {
     // Initialize request
@@ -117,11 +147,11 @@ public Object request(String messageName, Object request)
    * Writes a request message and returns the result through a Callback.
    * Clients can also use a Future interface by creating a new CallFuture&amp;lt;T&amp;gt;,
    * passing it in as the Callback parameter, and then waiting on that Future.
-   * @param &amp;lt;T&amp;gt; the return type of the message.
+   *
+   * @param &amp;lt;T&amp;gt;         the return type of the message.
    * @param messageName the name of the message to invoke.
-   * @param request the request data to send.
-   * @param callback the callback which will be invoked when the response is returned
-   * or an error occurs.
+   * @param request     the request data to send.
+   * @param callback    the callback which will be invoked when the response is returned or an error occurs.
    * @throws Exception if an error occurs sending the message.
    */
   public &amp;lt;T&amp;gt; void request(String messageName, Object request, Callback&amp;lt;T&amp;gt; callback)
@@ -129,7 +159,13 @@ public Object request(String messageName, Object request)
     request(new Request(messageName, request, new RPCContext()), callback);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Writes a request message and returns the result through a Callback. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Writes a request message and returns the result through a Callback.  @param &amp;lt;T&amp;gt;  the type parameter&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param request  the request&lt;br/&gt;
+   * @param callback the callback&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   &amp;lt;T&amp;gt; void request(Request request, Callback&amp;lt;T&amp;gt; callback)&lt;br/&gt;
     throws Exception {&lt;br/&gt;
     Transceiver t = getTransceiver();&lt;br/&gt;
@@ -264,7 +300,11 @@ private void setRemote(HandshakeResponse handshake) throws IOException {
     REMOTE_PROTOCOLS.putIfAbsent(remoteHash, remote);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Return the remote protocol.  Force a handshake if required. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the remote protocol.  Force a handshake if required.  @return the remote&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public Protocol getRemote() throws IOException {&lt;br/&gt;
     if (remote != null) return remote;            // already have it&lt;br/&gt;
     MD5 remoteHash = REMOTE_HASHES.get(transceiver.getRemoteName());&lt;br/&gt;
@@ -294,30 +334,68 @@ public Protocol getRemote() throws IOException {&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
 &lt;br/&gt;
-  /** Writes a request message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Writes a request message.  @param schema the schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param request the request&lt;br/&gt;
+   * @param out     the out&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract void writeRequest(Schema schema, Object request,&lt;br/&gt;
                                     Encoder out) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read response object.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param in     the in&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Deprecated                                     // for compatibility in 1.5&lt;br/&gt;
   public Object readResponse(Schema schema, Decoder in) throws IOException {
     return readResponse(schema, schema, in);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Reads a response message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Reads a response message.  @param writer the writer&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param reader the reader&lt;br/&gt;
+   * @param in     the in&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract Object readResponse(Schema writer, Schema reader, Decoder in)&lt;br/&gt;
     throws IOException;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read error object.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param in     the in&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Deprecated                                     // for compatibility in 1.5&lt;br/&gt;
   public Object readError(Schema schema, Decoder in) throws IOException {
     return readError(schema, schema, in);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Reads an error message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Reads an error message.  @param writer the writer&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param reader the reader&lt;br/&gt;
+   * @param in     the in&lt;br/&gt;
+   * @return the exception&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract Exception readError(Schema writer, Schema reader, Decoder in)&lt;br/&gt;
     throws IOException;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Handles callbacks from transceiver invocations.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; the type parameter&lt;br/&gt;
    */&lt;br/&gt;
   protected class TransceiverCallback&amp;lt;T&amp;gt; implements Callback&amp;lt;List&amp;lt;ByteBuffer&amp;gt;&amp;gt; {&lt;br/&gt;
     private final Request request;&lt;br/&gt;
@@ -325,7 +403,8 @@ public abstract Exception readError(Schema writer, Schema reader, Decoder in)&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a TransceiverCallback.&lt;br/&gt;
-     * @param request the request to set.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param request  the request to set.&lt;br/&gt;
      * @param callback the callback to set.&lt;br/&gt;
      */&lt;br/&gt;
     public TransceiverCallback(Request request, Callback&amp;lt;T&amp;gt; callback) {&lt;br/&gt;
@@ -390,9 +469,10 @@ public void handleError(Throwable error) {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a Request.&lt;br/&gt;
+     *&lt;br/&gt;
      * @param messageName the name of the message to invoke.&lt;br/&gt;
-     * @param request the request data to send.&lt;br/&gt;
-     * @param context the RPC context to use.&lt;br/&gt;
+     * @param request     the request data to send.&lt;br/&gt;
+     * @param context     the RPC context to use.&lt;br/&gt;
      */&lt;br/&gt;
     public Request(String messageName, Object request, RPCContext context) {&lt;br/&gt;
       this(messageName, request, context, null);&lt;br/&gt;
@@ -400,10 +480,11 @@ public Request(String messageName, Object request, RPCContext context) {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a Request.&lt;br/&gt;
+     *&lt;br/&gt;
      * @param messageName the name of the message to invoke.&lt;br/&gt;
-     * @param request the request data to send.&lt;br/&gt;
-     * @param context the RPC context to use.&lt;br/&gt;
-     * @param encoder the BinaryEncoder to use to serialize the request.&lt;br/&gt;
+     * @param request     the request data to send.&lt;br/&gt;
+     * @param context     the RPC context to use.&lt;br/&gt;
+     * @param encoder     the BinaryEncoder to use to serialize the request.&lt;br/&gt;
      */&lt;br/&gt;
     public Request(String messageName, Object request, RPCContext context,&lt;br/&gt;
                    BinaryEncoder encoder) {&lt;br/&gt;
@@ -416,6 +497,7 @@ public Request(String messageName, Object request, RPCContext context,&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Copy constructor.&lt;br/&gt;
+     *&lt;br/&gt;
      * @param other Request from which to copy fields.&lt;br/&gt;
      */&lt;br/&gt;
     public Request(Request other) {&lt;br/&gt;
@@ -427,6 +509,7 @@ public Request(Request other) {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Gets the message name.&lt;br/&gt;
+     *&lt;br/&gt;
      * @return the message name.&lt;br/&gt;
      */&lt;br/&gt;
     public String getMessageName() {&lt;br/&gt;
@@ -435,6 +518,7 @@ public String getMessageName() {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Gets the RPC context.&lt;br/&gt;
+     *&lt;br/&gt;
      * @return the RPC context.&lt;br/&gt;
      */&lt;br/&gt;
     public RPCContext getContext() {&lt;br/&gt;
@@ -443,6 +527,7 @@ public RPCContext getContext() {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Gets the Message associated with this request.&lt;br/&gt;
+     *&lt;br/&gt;
      * @return this request&apos;s message.&lt;br/&gt;
      */&lt;br/&gt;
     public Message getMessage() {&lt;br/&gt;
@@ -457,6 +542,7 @@ public Message getMessage() {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Gets the request data, generating it first if necessary.&lt;br/&gt;
+     *&lt;br/&gt;
      * @return the request data.&lt;br/&gt;
      * @throws Exception if an error occurs generating the request data.&lt;br/&gt;
      */&lt;br/&gt;
@@ -503,6 +589,7 @@ public Message getMessage() {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a Response.&lt;br/&gt;
+     *&lt;br/&gt;
      * @param request the Request associated with this response.&lt;br/&gt;
      */&lt;br/&gt;
     public Response(Request request) {&lt;br/&gt;
@@ -511,8 +598,9 @@ public Response(Request request) {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a Creates a Response.&lt;br/&gt;
+     *&lt;br/&gt;
      * @param request the Request associated with this response.&lt;br/&gt;
-     * @param in the BinaryDecoder to use to deserialize the response.&lt;br/&gt;
+     * @param in      the BinaryDecoder to use to deserialize the response.&lt;br/&gt;
      */&lt;br/&gt;
     public Response(Request request, BinaryDecoder in) {&lt;br/&gt;
       this.request = request;&lt;br/&gt;
@@ -521,6 +609,7 @@ public Response(Request request, BinaryDecoder in) {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Gets the RPC response, reading/deserializing it first if necessary.&lt;br/&gt;
+     *&lt;br/&gt;
      * @return the RPC response.&lt;br/&gt;
      * @throws Exception if an error occurs reading/deserializing the response.&lt;br/&gt;
      */&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Responder.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Responder.java&lt;br/&gt;
index 796f7785b..cb601d098 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Responder.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Responder.java&lt;br/&gt;
@@ -47,7 +47,9 @@&lt;br/&gt;
 import org.apache.avro.specific.SpecificDatumReader;&lt;br/&gt;
 import org.apache.avro.specific.SpecificDatumWriter;&lt;br/&gt;
 &lt;br/&gt;
-/** Base class for the server side of a protocol interaction. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Base class for the server side of a protocol interaction.&lt;br/&gt;
+ */&lt;br/&gt;
 public abstract class Responder {&lt;br/&gt;
   private static final Logger LOG = LoggerFactory.getLogger(Responder.class);&lt;br/&gt;
 &lt;br/&gt;
@@ -66,8 +68,16 @@&lt;br/&gt;
 &lt;br/&gt;
   private final Protocol local;&lt;br/&gt;
   private final MD5 localHash;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Rpc meta plugins.&lt;br/&gt;
+   */&lt;br/&gt;
   protected final List&amp;lt;RPCPlugin&amp;gt; rpcMetaPlugins;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param local the local&lt;br/&gt;
+   */&lt;br/&gt;
   protected Responder(Protocol local) {&lt;br/&gt;
     this.local = local;&lt;br/&gt;
     this.localHash = new MD5();&lt;br/&gt;
@@ -77,31 +87,47 @@ protected Responder(Protocol local) {
       new CopyOnWriteArrayList&amp;lt;&amp;gt;();
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Return the remote protocol.  Accesses a {@link ThreadLocal} that&apos;s set&lt;br/&gt;
-   * around calls to {@link #respond(Protocol.Message, Object)}. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the remote protocol.  Accesses a {@link ThreadLocal} that&apos;s set&lt;br/&gt;
+   * around calls to {@link #respond(Protocol.Message, Object)}.  @return the remote&lt;br/&gt;
+   */&lt;br/&gt;
   public static Protocol getRemote() { return REMOTE.get(); }&lt;br/&gt;
 &lt;br/&gt;
-  /** Return the local protocol. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the local protocol.  @return the local&lt;br/&gt;
+   */&lt;br/&gt;
   public Protocol getLocal() { return local; }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Adds a new plugin to manipulate per-call metadata.  Plugins&lt;br/&gt;
    * are executed in the order that they are added.&lt;br/&gt;
+   *&lt;br/&gt;
    * @param plugin a plugin that will manipulate RPC metadata&lt;br/&gt;
    */&lt;br/&gt;
   public void addRPCPlugin(RPCPlugin plugin) {
     rpcMetaPlugins.add(plugin);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Called by a server to deserialize a request, compute and serialize&lt;br/&gt;
-   * a response or error. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by a server to deserialize a request, compute and serialize&lt;br/&gt;
+   * a response or error.  @param buffers the buffers&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the list&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public List&amp;lt;ByteBuffer&amp;gt; respond(List&amp;lt;ByteBuffer&amp;gt; buffers) throws IOException {
     return respond(buffers, null);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Called by a server to deserialize a request, compute and serialize a&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by a server to deserialize a request, compute and serialize a&lt;br/&gt;
    * response or error.  Transceiver is used by connection-based servers to&lt;br/&gt;
-   * track handshake status of connection. */&lt;br/&gt;
+   * track handshake status of connection.  @param buffers the buffers&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param connection the connection&lt;br/&gt;
+   * @return the list&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public List&amp;lt;ByteBuffer&amp;gt; respond(List&amp;lt;ByteBuffer&amp;gt; buffers,&lt;br/&gt;
                                   Transceiver connection) throws IOException {
     Decoder in = DecoderFactory.get().binaryDecoder(
@@ -240,19 +266,44 @@ private Protocol handshake(Decoder in, Encoder out, Transceiver connection)
     return remote;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Computes the response for a message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Computes the response for a message.  @param message the message&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param request the request&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract Object respond(Message message, Object request)&lt;br/&gt;
     throws Exception;&lt;br/&gt;
 &lt;br/&gt;
-  /** Reads a request message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Reads a request message.  @param actual the actual&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param expected the expected&lt;br/&gt;
+   * @param in       the in&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract Object readRequest(Schema actual, Schema expected, Decoder in)&lt;br/&gt;
     throws IOException;&lt;br/&gt;
 &lt;br/&gt;
-  /** Writes a response message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Writes a response message.  @param schema the schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param response the response&lt;br/&gt;
+   * @param out      the out&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract void writeResponse(Schema schema, Object response,&lt;br/&gt;
                                      Encoder out) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
-  /** Writes an error message. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Writes an error message.  @param schema the schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param error the error&lt;br/&gt;
+   * @param out   the out&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract void writeError(Schema schema, Object error,&lt;br/&gt;
                                   Encoder out) throws IOException;&lt;br/&gt;
 &lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/ResponderServlet.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/ResponderServlet.java&lt;br/&gt;
index 397371cc3..2690ab944 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/ResponderServlet.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/ResponderServlet.java&lt;br/&gt;
@@ -29,10 +29,18 @@&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.avro.AvroRuntimeException;&lt;br/&gt;
 &lt;br/&gt;
-/** An {@link HttpServlet} that responds to Avro RPC requests. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * An {@link HttpServlet} that responds to Avro RPC requests.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ResponderServlet extends HttpServlet {&lt;br/&gt;
   private Responder responder;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Responder servlet.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public ResponderServlet(Responder responder) throws IOException {     this.responder = responder;   }
&lt;p&gt;diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/SaslSocketServer.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/SaslSocketServer.java&lt;br/&gt;
index eb4569f8d..d3b737ea5 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/SaslSocketServer.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/SaslSocketServer.java&lt;br/&gt;
@@ -30,19 +30,32 @@&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;/p&gt;

&lt;p&gt;-/** A &lt;/p&gt;
{@link Server} that uses {@link javax.security.sasl} for authentication&lt;br/&gt;
- * and encryption. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * A {@link Server}
&lt;p&gt; that uses &lt;/p&gt;
{@link javax.security.sasl} for authentication&lt;br/&gt;
+ * and encryption.&lt;br/&gt;
+ */&lt;br/&gt;
 public class SaslSocketServer extends SocketServer {&lt;br/&gt;
   private static final Logger LOG = LoggerFactory.getLogger(SaslServer.class);&lt;br/&gt;
 &lt;br/&gt;
   private static abstract class SaslServerFactory {
+    /**
+     * Gets server.
+     *
+     * @return the server
+     * @throws SaslException the sasl exception
+     */
     protected abstract SaslServer getServer() throws SaslException;
   }&lt;br/&gt;
 &lt;br/&gt;
   private SaslServerFactory factory;&lt;br/&gt;
 &lt;br/&gt;
-  /** Create using SASL&apos;s anonymous (&amp;lt;a&lt;br/&gt;
-   * href=&quot;http://www.ietf.org/rfc/rfc2245.txt&quot;&amp;gt;RFC 2245) mechanism. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create using SASL&apos;s anonymous (&amp;lt;a&lt;br/&gt;
+   * href=&quot;http://www.ietf.org/rfc/rfc2245.txt&quot;&amp;gt;RFC 2245) mechanism.  @param responder the responder&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param addr the addr&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SaslSocketServer(Responder responder, SocketAddress addr)&lt;br/&gt;
     throws IOException {
     this(responder, addr,
@@ -51,7 +64,17 @@ public SaslSocketServer(Responder responder, SocketAddress addr)
          });&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create using the specified {@link SaslServer} parameters. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create using the specified {@link SaslServer} parameters.  @param responder the responder&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param addr       the addr&lt;br/&gt;
+   * @param mechanism  the mechanism&lt;br/&gt;
+   * @param protocol   the protocol&lt;br/&gt;
+   * @param serverName the server name&lt;br/&gt;
+   * @param props      the props&lt;br/&gt;
+   * @param cbh        the cbh&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SaslSocketServer(Responder responder, SocketAddress addr,&lt;br/&gt;
                           final String mechanism, final String protocol,&lt;br/&gt;
                           final String serverName, final Map&amp;lt;String,?&amp;gt; props,&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/SaslSocketTransceiver.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/SaslSocketTransceiver.java&lt;br/&gt;
index b934fd14a..b534dc587 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/SaslSocketTransceiver.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/SaslSocketTransceiver.java&lt;br/&gt;
@@ -39,15 +39,33 @@&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
 &lt;br/&gt;
-/** A {@link Transceiver} that uses {@link javax.security.sasl}
&lt;p&gt; for&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* authentication and encryption. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * A 
{@link Transceiver} that uses {@link javax.security.sasl} for&lt;br/&gt;
+ * authentication and encryption.&lt;br/&gt;
+ */&lt;br/&gt;
 public class SaslSocketTransceiver extends Transceiver {&lt;br/&gt;
   private static final Logger LOG =&lt;br/&gt;
     LoggerFactory.getLogger(SaslSocketTransceiver.class);&lt;br/&gt;
 &lt;br/&gt;
   private static final ByteBuffer EMPTY = ByteBuffer.allocate(0);&lt;br/&gt;
 &lt;br/&gt;
-  private static enum Status { START, CONTINUE, FAIL, COMPLETE }&lt;br/&gt;
+  private static enum Status {
+    /**
+     * Start status.
+     */
+    START,
+    /**
+     * Continue status.
+     */
+    CONTINUE,
+    /**
+     * Fail status.
+     */
+    FAIL,
+    /**
+     * Complete status.
+     */
+    COMPLETE }&lt;br/&gt;
 &lt;br/&gt;
   private SaslParticipant sasl;&lt;br/&gt;
   private SocketChannel channel;&lt;br/&gt;
@@ -60,13 +78,24 @@&lt;br/&gt;
   private ByteBuffer writeHeader = ByteBuffer.allocate(4);&lt;br/&gt;
   private ByteBuffer zeroHeader = ByteBuffer.allocate(4).putInt(0);&lt;br/&gt;
 &lt;br/&gt;
-  /** Create using SASL&apos;s anonymous (&amp;lt;a&lt;br/&gt;
-   * href=&quot;http://www.ietf.org/rfc/rfc2245.txt&quot;&amp;gt;RFC 2245) mechanism. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create using SASL&apos;s anonymous RFC 2245 mechanism.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param address The socket to connect to&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   * @see &amp;lt;a href=&quot;http://www.ietf.org/rfc/rfc2245.txt&quot;&amp;gt;RFC 2245&amp;lt;/a&amp;gt;&lt;br/&gt;
+   */&lt;br/&gt;
   public SaslSocketTransceiver(SocketAddress address) throws IOException {
     this(address, new AnonymousClient());
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create using the specified {@link SaslClient}. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create using the specified {@link SaslClient}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param address    The socket to connect to&lt;br/&gt;
+   * @param saslClient The sasl client that you want to use&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SaslSocketTransceiver(SocketAddress address, SaslClient saslClient)&lt;br/&gt;
     throws IOException {
     this.sasl = new SaslParticipant(saslClient);
@@ -76,7 +105,13 @@ public SaslSocketTransceiver(SocketAddress address, SaslClient saslClient)
     open(true);
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create using the specified {@link SaslServer}. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create using the specified {@link SaslServer}.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param channel    The channel to use to connect&lt;br/&gt;
+   * @param saslServer The sasl server that you want to connect to&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SaslSocketTransceiver(SocketChannel channel, SaslServer saslServer)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     this.sasl = new SaslParticipant(saslServer);&lt;br/&gt;
@@ -313,18 +348,39 @@ private void writeFully(ByteBuffer... buffers) throws IOException {&lt;br/&gt;
    * unfortunately don&apos;t share a common superclass.&lt;br/&gt;
    */&lt;br/&gt;
   private static class SaslParticipant {&lt;br/&gt;
-    // One of these will always be null.&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Server.&lt;br/&gt;
+     */&lt;br/&gt;
+// One of these will always be null.&lt;br/&gt;
     public SaslServer server;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Client.&lt;br/&gt;
+     */&lt;br/&gt;
     public SaslClient client;&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Sasl participant.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param server the server&lt;br/&gt;
+     */&lt;br/&gt;
     public SaslParticipant(SaslServer server) {
       this.server = server;
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Sasl participant.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param client the client&lt;br/&gt;
+     */&lt;br/&gt;
     public SaslParticipant(SaslClient client) {
       this.client = client;
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Gets mechanism name.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the mechanism name&lt;br/&gt;
+     */&lt;br/&gt;
     public String getMechanismName() {&lt;br/&gt;
       if (client != null)&lt;br/&gt;
         return client.getMechanismName();&lt;br/&gt;
@@ -332,6 +388,11 @@ public String getMechanismName() {
         return server.getMechanismName();
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Is complete boolean.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the boolean&lt;br/&gt;
+     */&lt;br/&gt;
     public boolean isComplete() {&lt;br/&gt;
       if (client != null)&lt;br/&gt;
         return client.isComplete();&lt;br/&gt;
@@ -339,6 +400,11 @@ public boolean isComplete() {
         return server.isComplete();
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Dispose.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws SaslException the sasl exception&lt;br/&gt;
+     */&lt;br/&gt;
     public void dispose() throws SaslException {&lt;br/&gt;
       if (client != null)&lt;br/&gt;
         client.dispose();&lt;br/&gt;
@@ -346,6 +412,13 @@ public void dispose() throws SaslException {
         server.dispose();
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Unwrap byte [ ].&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param buf the buf&lt;br/&gt;
+     * @return the byte [ ]&lt;br/&gt;
+     * @throws SaslException the sasl exception&lt;br/&gt;
+     */&lt;br/&gt;
     public byte[] unwrap(byte[] buf) throws SaslException {&lt;br/&gt;
       if (client != null)&lt;br/&gt;
         return client.unwrap(buf, 0, buf.length);&lt;br/&gt;
@@ -353,10 +426,26 @@ public void dispose() throws SaslException {
         return server.unwrap(buf, 0, buf.length);
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Wrap byte [ ].&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param buf the buf&lt;br/&gt;
+     * @return the byte [ ]&lt;br/&gt;
+     * @throws SaslException the sasl exception&lt;br/&gt;
+     */&lt;br/&gt;
     public byte[] wrap(byte[] buf) throws SaslException {
       return wrap(buf, 0, buf.length);
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Wrap byte [ ].&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param buf   the buf&lt;br/&gt;
+     * @param start the start&lt;br/&gt;
+     * @param len   the len&lt;br/&gt;
+     * @return the byte [ ]&lt;br/&gt;
+     * @throws SaslException the sasl exception&lt;br/&gt;
+     */&lt;br/&gt;
     public byte[] wrap(byte[] buf, int start, int len) throws SaslException {&lt;br/&gt;
       if (client != null)&lt;br/&gt;
         return client.wrap(buf, start, len);&lt;br/&gt;
@@ -364,6 +453,12 @@ public void dispose() throws SaslException {
         return server.wrap(buf, start, len);
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Gets negotiated property.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param propName the prop name&lt;br/&gt;
+     * @return the negotiated property&lt;br/&gt;
+     */&lt;br/&gt;
     public Object getNegotiatedProperty(String propName) {&lt;br/&gt;
       if (client != null)&lt;br/&gt;
         return client.getNegotiatedProperty(propName);&lt;br/&gt;
@@ -371,6 +466,13 @@ public Object getNegotiatedProperty(String propName) {
         return server.getNegotiatedProperty(propName);
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Evaluate byte [ ].&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param buf the buf&lt;br/&gt;
+     * @return the byte [ ]&lt;br/&gt;
+     * @throws SaslException the sasl exception&lt;br/&gt;
+     */&lt;br/&gt;
     public byte[] evaluate(byte[] buf) throws SaslException {&lt;br/&gt;
       if (client != null)&lt;br/&gt;
         return client.evaluateChallenge(buf);&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Server.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Server.java&lt;br/&gt;
index b27517b8f..1b1fe3ea3 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Server.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Server.java&lt;br/&gt;
@@ -18,18 +18,28 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.avro.ipc;&lt;br/&gt;
 &lt;br/&gt;
-/** A server listening on a port. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * A server listening on a port.&lt;br/&gt;
+ */&lt;br/&gt;
 public interface Server {
-  /** The port this server runs on. */
+  /**
+   * The port this server runs on.  @return the port
+   */
   int getPort();
 
-  /** Start this server. */
+  /**
+   * Start this server.
+   */
   void start();
 
-  /** Stop this server. */
+  /**
+   * Stop this server.
+   */
   void close();
 
-  /** Wait for this server to exit. */
+  /**
+   * Wait for this server to exit.  @throws InterruptedException the interrupted exception
+   */
   void join() throws InterruptedException;
 
 }&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/SocketServer.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/SocketServer.java&lt;br/&gt;
index bc0d661af..279b32f1c 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/SocketServer.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/SocketServer.java&lt;br/&gt;
@@ -33,8 +33,10 @@&lt;br/&gt;
 import org.apache.avro.Protocol.Message;&lt;br/&gt;
 import org.apache.avro.ipc.generic.GenericResponder;&lt;br/&gt;
 &lt;br/&gt;
-/** A socket-based server implementation. This uses a simple, non-standard wire&lt;br/&gt;
+/**&lt;br/&gt;
+ * A socket-based server implementation. This uses a simple, non-standard wire&lt;br/&gt;
  * protocol and is not intended for production services.&lt;br/&gt;
+ *&lt;br/&gt;
  * @deprecated use {@link SaslSocketServer} instead.&lt;br/&gt;
  */&lt;br/&gt;
 public class SocketServer extends Thread implements Server {&lt;br/&gt;
@@ -44,6 +46,13 @@&lt;br/&gt;
   private ServerSocketChannel channel;&lt;br/&gt;
   private ThreadGroup group;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Socket server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   * @param addr      the addr&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SocketServer(Responder responder, SocketAddress addr)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     String name = &quot;SocketServer on &quot;+addr;&lt;br/&gt;
@@ -87,8 +96,13 @@ public void close() {
     group.interrupt();
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Creates an appropriate {@link Transceiver}
&lt;p&gt; for this server.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;* Returns a 
{@link SocketTransceiver} by default. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Creates an appropriate {@link Transceiver} for this server.&lt;br/&gt;
+   * Returns a {@link SocketTransceiver}
&lt;p&gt; by default.  @param channel the channel&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   protected Transceiver getTransceiver(SocketChannel channel)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     return new SocketTransceiver(channel);&lt;br/&gt;
@@ -96,9 +110,21 @@ protected Transceiver getTransceiver(SocketChannel channel)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   private class Connection implements Runnable {&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * The Channel.&lt;br/&gt;
+     */&lt;br/&gt;
     SocketChannel channel;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Xc.&lt;br/&gt;
+     */&lt;br/&gt;
     Transceiver xc;&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Connection.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param channel the channel&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public Connection(SocketChannel channel) throws IOException {&lt;br/&gt;
       this.channel = channel;&lt;/p&gt;

&lt;p&gt;@@ -129,6 +155,12 @@ public void run() {&lt;/p&gt;

&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The entry point of application.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param arg the input arguments&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void main(String[] arg) throws Exception {&lt;br/&gt;
     Responder responder =&lt;br/&gt;
       new GenericResponder(Protocol.parse(&quot;&lt;/p&gt;
{\&quot;protocol\&quot;: \&quot;X\&quot;}
&lt;p&gt;&quot;)) {&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/SocketTransceiver.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/SocketTransceiver.java&lt;br/&gt;
index 73dec52c1..157c3a4dd 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/SocketTransceiver.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/SocketTransceiver.java&lt;br/&gt;
@@ -31,8 +31,10 @@&lt;/p&gt;

&lt;p&gt; import org.apache.avro.Protocol;&lt;/p&gt;

&lt;p&gt;-/** A socket-based &lt;/p&gt;
{@link Transceiver} implementation.  This uses a simple,&lt;br/&gt;
+/**&lt;br/&gt;
+ * A socket-based {@link Transceiver}
&lt;p&gt; implementation.  This uses a simple,&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;non-standard wire protocol and is not intended for production services.&lt;br/&gt;
+ *&lt;/li&gt;
	&lt;li&gt;@deprecated use 
{@link SaslSocketTransceiver}
&lt;p&gt; instead.&lt;br/&gt;
  */&lt;br/&gt;
 public class SocketTransceiver extends Transceiver {&lt;br/&gt;
@@ -44,10 +46,22 @@&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   private Protocol remote;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Socket transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param address the address&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SocketTransceiver(SocketAddress address) throws IOException &lt;/p&gt;
{
     this(SocketChannel.open(address));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Socket transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param channel the channel&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SocketTransceiver(SocketChannel channel) throws IOException {&lt;br/&gt;
     this.channel = channel;&lt;br/&gt;
     this.channel.socket().setTcpNoDelay(true);&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Transceiver.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Transceiver.java&lt;br/&gt;
index f1b081a12..f1ac82346 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/Transceiver.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/Transceiver.java&lt;br/&gt;
@@ -26,10 +26,18 @@&lt;/p&gt;

&lt;p&gt; import org.apache.avro.Protocol;&lt;/p&gt;

&lt;p&gt;-/** Base transport class used by &lt;/p&gt;
{@link Requestor}. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Base transport class used by {@link Requestor}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
 public abstract class Transceiver implements Closeable {&lt;br/&gt;
   private final ReentrantLock channelLock = new ReentrantLock();&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets remote name.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the remote name&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract String getRemoteName() throws IOException;&lt;/p&gt;

&lt;p&gt;   /**&lt;br/&gt;
@@ -48,9 +56,14 @@ public void unlockChannel() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called by 
{@link Requestor#request(String,Object)} for two-way messages.&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by {@link Requestor#request(String, Object)} for two-way messages.&lt;br/&gt;
    * By default calls {@link #writeBuffers(List)} followed by&lt;br/&gt;
-   * {@link #readBuffers()}. */&lt;br/&gt;
+   * {@link #readBuffers()}.  @param request the request&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the list&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public List&amp;lt;ByteBuffer&amp;gt; transceive(List&amp;lt;ByteBuffer&amp;gt; request)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     lockChannel();&lt;br/&gt;
@@ -63,7 +76,11 @@ public void unlockChannel() {&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
-   * Called by {@link Requestor#request(String,Object,Callback)} for two-way messages using callbacks.&lt;br/&gt;
+   * Called by {@link Requestor#request(String, Object, Callback)} for two-way messages using callbacks.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param request  the request&lt;br/&gt;
+   * @param callback the callback&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   public void transceive(List&amp;lt;ByteBuffer&amp;gt; request, Callback&amp;lt;List&amp;lt;ByteBuffer&amp;gt;&amp;gt; callback)&lt;br/&gt;
     throws IOException {
@@ -76,30 +93,44 @@ public void transceive(List&amp;lt;ByteBuffer&amp;gt; request, Callback&amp;lt;List&amp;lt;ByteBuffer&amp;gt;&amp;gt; call
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Called by the default definition of {@link #transceive(List)}.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by the default definition of {@link #transceive(List)}. @return the list&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract List&amp;lt;ByteBuffer&amp;gt; readBuffers() throws IOException;&lt;br/&gt;
 &lt;br/&gt;
-  /** Called by {@link Requestor#request(String,Object)}
&lt;p&gt; for one-way messages.*/&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called by &lt;/p&gt;
{@link Requestor#request(String, Object)}
&lt;p&gt; for one-way messages. @param buffers the buffers&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public abstract void writeBuffers(List&amp;lt;ByteBuffer&amp;gt; buffers)&lt;br/&gt;
     throws IOException;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** True if a handshake has been completed for this connection.  Used to&lt;br/&gt;
+  /**&lt;br/&gt;
+   * True if a handshake has been completed for this connection.  Used to&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;determine whether a handshake need be completed prior to a one-way&lt;/li&gt;
	&lt;li&gt;message.  Requests and responses are always prefixed by handshakes, but&lt;/li&gt;
	&lt;li&gt;one-way messages.  If the first request sent over a connection is one-way,&lt;/li&gt;
	&lt;li&gt;then a handshake-only response is returned.  Subsequent one-way messages&lt;/li&gt;
	&lt;li&gt;over the connection will have no response data sent.  Returns false by&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* default. */&lt;br/&gt;
+   * default.  @return the boolean&lt;br/&gt;
+   */&lt;br/&gt;
   public boolean isConnected() 
{ return false; }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Called with the remote protocol when a handshake has been completed.&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Called with the remote protocol when a handshake has been completed.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;After this has been called and while a connection is maintained, 
{@link
-   * #isConnected()}
&lt;p&gt; should return true and #getRemote() should return this&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* protocol.  Does nothing by default. */&lt;br/&gt;
+   * #isConnected()}* should return true and #getRemote() should return this&lt;br/&gt;
+   * protocol.  Does nothing by default.  @param protocol the protocol&lt;br/&gt;
+   */&lt;br/&gt;
   public void setRemote(Protocol protocol) {}&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns the protocol passed to 
{@link #setRemote(Protocol)}.  Throws&lt;br/&gt;
-   * IllegalStateException by default. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns the protocol passed to {@link #setRemote(Protocol)}
&lt;p&gt;.  Throws&lt;br/&gt;
+   * IllegalStateException by default.  @return the remote&lt;br/&gt;
+   */&lt;br/&gt;
   public Protocol getRemote() &lt;/p&gt;
{
     throw new IllegalStateException(&quot;Not connected.&quot;);
   }
&lt;p&gt;diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/generic/GenericRequestor.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/generic/GenericRequestor.java&lt;br/&gt;
index 018a07a8f..b2dcc350d 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/main/java/org/apache/avro/ipc/generic/GenericRequestor.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/generic/GenericRequestor.java&lt;br/&gt;
@@ -33,15 +33,35 @@&lt;br/&gt;
 import org.apache.avro.ipc.Requestor;&lt;br/&gt;
 import org.apache.avro.ipc.Transceiver;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** &lt;/p&gt;
{@link Requestor} implementation for generic Java data. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * {@link Requestor}
&lt;p&gt; implementation for generic Java data.&lt;br/&gt;
+ */&lt;br/&gt;
 public class GenericRequestor extends Requestor {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Data.&lt;br/&gt;
+   */&lt;br/&gt;
   GenericData data;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Generic requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol    the protocol&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public GenericRequestor(Protocol protocol, Transceiver transceiver)&lt;br/&gt;
     throws IOException &lt;/p&gt;
{
     this(protocol, transceiver, GenericData.get());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Generic requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol    the protocol&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @param data        the data&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public GenericRequestor(Protocol protocol, Transceiver transceiver,&lt;br/&gt;
                           GenericData data)&lt;br/&gt;
     throws IOException &lt;/p&gt;
{
@@ -49,6 +69,11 @@ public GenericRequestor(Protocol protocol, Transceiver transceiver,
     this.data = data;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets generic data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the generic data&lt;br/&gt;
+   */&lt;br/&gt;
   public GenericData getGenericData() &lt;/p&gt;
{ return data; }&lt;br/&gt;
 &lt;br/&gt;
   @Override&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/generic/GenericResponder.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/generic/GenericResponder.java&lt;br/&gt;
index 814b1e98f..218d2a3ea 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/generic/GenericResponder.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/generic/GenericResponder.java&lt;br/&gt;
@@ -32,26 +32,57 @@&lt;br/&gt;
 import org.apache.avro.io.DatumWriter;&lt;br/&gt;
 import org.apache.avro.ipc.Responder;&lt;br/&gt;
 &lt;br/&gt;
-/** {@link Responder} implementation for generic Java data. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * {@link Responder} implementation for generic Java data.&lt;br/&gt;
+ */&lt;br/&gt;
 public abstract class GenericResponder extends Responder {&lt;br/&gt;
   private GenericData data;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Generic responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param local the local&lt;br/&gt;
+   */&lt;br/&gt;
   public GenericResponder(Protocol local) {
     this(local, GenericData.get());
 
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Generic responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param local the local&lt;br/&gt;
+   * @param data  the data&lt;br/&gt;
+   */&lt;br/&gt;
   public GenericResponder(Protocol local, GenericData data) {
     super(local);
     this.data = data;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets generic data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the generic data&lt;br/&gt;
+   */&lt;br/&gt;
   public GenericData getGenericData() { return data; }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets datum writer.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @return the datum writer&lt;br/&gt;
+   */&lt;br/&gt;
   protected DatumWriter&amp;lt;Object&amp;gt; getDatumWriter(Schema schema) &lt;/p&gt;
{
     return new GenericDatumWriter&amp;lt;&amp;gt;(schema, data);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets datum reader.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param actual   the actual&lt;br/&gt;
+   * @param expected the expected&lt;br/&gt;
+   * @return the datum reader&lt;br/&gt;
+   */&lt;br/&gt;
   protected DatumReader&amp;lt;Object&amp;gt; getDatumReader(Schema actual, Schema expected) &lt;/p&gt;
{
     return new GenericDatumReader&amp;lt;&amp;gt;(actual, expected, data);
   }
&lt;p&gt;diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/reflect/ReflectRequestor.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/reflect/ReflectRequestor.java&lt;br/&gt;
index 026365c62..7eeacd221 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/reflect/ReflectRequestor.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/reflect/ReflectRequestor.java&lt;br/&gt;
@@ -31,31 +31,68 @@&lt;br/&gt;
 import org.apache.avro.ipc.Transceiver;&lt;br/&gt;
 import org.apache.avro.ipc.specific.SpecificRequestor;&lt;/p&gt;

&lt;p&gt;-/** A &lt;/p&gt;
{@link org.apache.avro.ipc.Requestor} for existing interfaces. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * A {@link org.apache.avro.ipc.Requestor}
&lt;p&gt; for existing interfaces.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ReflectRequestor extends SpecificRequestor {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Reflect requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface       the iface&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectRequestor(Class&amp;lt;?&amp;gt; iface, Transceiver transceiver)&lt;br/&gt;
     throws IOException &lt;/p&gt;
{
     this(iface, transceiver, new ReflectData(iface.getClassLoader()));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Reflect requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol    the protocol&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   protected ReflectRequestor(Protocol protocol, Transceiver transceiver)&lt;br/&gt;
     throws IOException &lt;/p&gt;
{
     this(protocol, transceiver, ReflectData.get());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Reflect requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface       the iface&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @param data        the data&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectRequestor(Class&amp;lt;?&amp;gt; iface, Transceiver transceiver,&lt;br/&gt;
                           ReflectData data)&lt;br/&gt;
     throws IOException &lt;/p&gt;
{
     this(data.getProtocol(iface), transceiver, data);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Reflect requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol    the protocol&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @param data        the data&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectRequestor(Protocol protocol, Transceiver transceiver,&lt;br/&gt;
                           ReflectData data)&lt;br/&gt;
     throws IOException {
     super(protocol, transceiver, data);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets reflect data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the reflect data&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectData getReflectData() { return (ReflectData)getSpecificData(); }&lt;br/&gt;
 &lt;br/&gt;
   @Override&lt;br/&gt;
@@ -68,14 +105,29 @@ public ReflectRequestor(Protocol protocol, Transceiver transceiver,&lt;br/&gt;
     return new ReflectDatumReader&amp;lt;&amp;gt;(writer, reader, getReflectData());&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a proxy instance whose methods invoke RPCs. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a proxy instance whose methods invoke RPCs.  @param &amp;lt;T&amp;gt;  the type parameter&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface       the iface&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @return the client&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static &amp;lt;T&amp;gt; T getClient(Class&amp;lt;T&amp;gt; iface, Transceiver transceiver)&lt;br/&gt;
     throws IOException {
     return getClient(iface, transceiver,
                      new ReflectData(iface.getClassLoader()));
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a proxy instance whose methods invoke RPCs. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a proxy instance whose methods invoke RPCs.  @param &amp;lt;T&amp;gt;  the type parameter&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface       the iface&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @param reflectData the reflect data&lt;br/&gt;
+   * @return the client&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
   public static &amp;lt;T&amp;gt; T getClient(Class&amp;lt;T&amp;gt; iface, Transceiver transceiver,&lt;br/&gt;
                                 ReflectData reflectData) throws IOException {
@@ -86,7 +138,14 @@ public ReflectRequestor(Protocol protocol, Transceiver transceiver,
        new ReflectRequestor(protocol, transceiver, reflectData));
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Create a proxy instance whose methods invoke RPCs. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a proxy instance whose methods invoke RPCs.  @param &amp;lt;T&amp;gt;  the type parameter&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface the iface&lt;br/&gt;
+   * @param rreq  the rreq&lt;br/&gt;
+   * @return the client&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
   public static &amp;lt;T&amp;gt; T getClient(Class&amp;lt;T&amp;gt; iface, ReflectRequestor rreq)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/reflect/ReflectResponder.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/reflect/ReflectResponder.java&lt;br/&gt;
index a7b30230d..2b141476c 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/reflect/ReflectResponder.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/reflect/ReflectResponder.java&lt;br/&gt;
@@ -30,24 +30,57 @@&lt;br/&gt;
 import org.apache.avro.reflect.ReflectDatumReader;&lt;br/&gt;
 import org.apache.avro.reflect.ReflectDatumWriter;&lt;br/&gt;
 &lt;br/&gt;
-/** {@link org.apache.avro.ipc.Responder} for existing interfaces.*/&lt;br/&gt;
+/**&lt;br/&gt;
+ * {@link org.apache.avro.ipc.Responder} for existing interfaces.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ReflectResponder extends SpecificResponder {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Reflect responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface the iface&lt;br/&gt;
+   * @param impl  the&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectResponder(Class iface, Object impl) {
     this(iface, impl, new ReflectData(impl.getClass().getClassLoader()));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Reflect responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol the protocol&lt;br/&gt;
+   * @param impl     the&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectResponder(Protocol protocol, Object impl) {
     this(protocol, impl, new ReflectData(impl.getClass().getClassLoader()));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Reflect responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface the iface&lt;br/&gt;
+   * @param impl  the&lt;br/&gt;
+   * @param data  the data&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectResponder(Class iface, Object impl, ReflectData data) {
     this(data.getProtocol(iface), impl, data);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Reflect responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol the protocol&lt;br/&gt;
+   * @param impl     the&lt;br/&gt;
+   * @param data     the data&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectResponder(Protocol protocol, Object impl, ReflectData data) {
     super(protocol, impl, data);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets reflect data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the reflect data&lt;br/&gt;
+   */&lt;br/&gt;
   public ReflectData getReflectData() { return (ReflectData)getSpecificData(); }&lt;br/&gt;
 &lt;br/&gt;
   @Override&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/specific/SpecificRequestor.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/specific/SpecificRequestor.java&lt;br/&gt;
index 1bd1fd577..c22c2bac1 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/specific/SpecificRequestor.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/specific/SpecificRequestor.java&lt;br/&gt;
@@ -40,26 +40,61 @@&lt;br/&gt;
 import org.apache.avro.specific.SpecificDatumReader;&lt;br/&gt;
 import org.apache.avro.specific.SpecificDatumWriter;&lt;br/&gt;
 &lt;br/&gt;
-/** {@link org.apache.avro.ipc.Requestor Requestor} for generated interfaces. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * {@link org.apache.avro.ipc.Requestor Requestor} for generated interfaces.&lt;br/&gt;
+ */&lt;br/&gt;
 public class SpecificRequestor extends Requestor implements InvocationHandler {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Data.&lt;br/&gt;
+   */&lt;br/&gt;
   SpecificData data;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Specific requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface       the iface&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificRequestor(Class&amp;lt;?&amp;gt; iface, Transceiver transceiver)&lt;br/&gt;
     throws IOException {
     this(iface, transceiver, new SpecificData(iface.getClassLoader()));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Specific requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol    the protocol&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   protected SpecificRequestor(Protocol protocol, Transceiver transceiver)&lt;br/&gt;
     throws IOException {
     this(protocol, transceiver, SpecificData.get());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Specific requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface       the iface&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @param data        the data&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificRequestor(Class&amp;lt;?&amp;gt; iface, Transceiver transceiver,&lt;br/&gt;
                            SpecificData data)&lt;br/&gt;
     throws IOException {     this(data.getProtocol(iface), transceiver, data);   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Specific requestor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol    the protocol&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @param data        the data&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificRequestor(Protocol protocol, Transceiver transceiver,&lt;br/&gt;
                            SpecificData data)&lt;br/&gt;
     throws IOException &lt;/p&gt;
{
@@ -67,6 +102,11 @@ public SpecificRequestor(Protocol protocol, Transceiver transceiver,
     this.data = data;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets specific data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the specific data&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificData getSpecificData() &lt;/p&gt;
{ return data; }

&lt;p&gt;   @Override&lt;br/&gt;
@@ -136,15 +176,34 @@ else if (name.equals(&quot;toString&quot;)) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets datum writer.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @return the datum writer&lt;br/&gt;
+   */&lt;br/&gt;
   protected DatumWriter&amp;lt;Object&amp;gt; getDatumWriter(Schema schema) &lt;/p&gt;
{
     return new SpecificDatumWriter&amp;lt;&amp;gt;(schema, data);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets datum reader.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @return the datum reader&lt;br/&gt;
+   */&lt;br/&gt;
   @Deprecated                                     // for compatibility in 1.5&lt;br/&gt;
   protected DatumReader&amp;lt;Object&amp;gt; getDatumReader(Schema schema) &lt;/p&gt;
{
     return getDatumReader(schema, schema);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets datum reader.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param writer the writer&lt;br/&gt;
+   * @param reader the reader&lt;br/&gt;
+   * @return the datum reader&lt;br/&gt;
+   */&lt;br/&gt;
   protected DatumReader&amp;lt;Object&amp;gt; getDatumReader(Schema writer, Schema reader) &lt;/p&gt;
{
     return new SpecificDatumReader&amp;lt;&amp;gt;(writer, reader, data);
   }
&lt;p&gt;@@ -173,14 +232,29 @@ public Exception readError(Schema writer, Schema reader, Decoder in)&lt;br/&gt;
     return new AvroRuntimeException(value.toString());&lt;br/&gt;
   }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Create a proxy instance whose methods invoke RPCs. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a proxy instance whose methods invoke RPCs.  @param &amp;lt;T&amp;gt;  the type parameter&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface       the iface&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @return the client&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static  &amp;lt;T&amp;gt; T getClient(Class&amp;lt;T&amp;gt; iface, Transceiver transceiver)&lt;br/&gt;
     throws IOException 
{
     return getClient(iface, transceiver,
                      new SpecificData(iface.getClassLoader()));
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Create a proxy instance whose methods invoke RPCs. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a proxy instance whose methods invoke RPCs.  @param &amp;lt;T&amp;gt;  the type parameter&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface       the iface&lt;br/&gt;
+   * @param transceiver the transceiver&lt;br/&gt;
+   * @param data        the data&lt;br/&gt;
+   * @return the client&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
   public static  &amp;lt;T&amp;gt; T getClient(Class&amp;lt;T&amp;gt; iface, Transceiver transceiver,&lt;br/&gt;
                                  SpecificData data)&lt;br/&gt;
@@ -192,7 +266,14 @@ public Exception readError(Schema writer, Schema reader, Decoder in)&lt;br/&gt;
        new SpecificRequestor(protocol, transceiver, data));&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Create a proxy instance whose methods invoke RPCs. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create a proxy instance whose methods invoke RPCs.  @param &amp;lt;T&amp;gt;  the type parameter&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface     the iface&lt;br/&gt;
+   * @param requestor the requestor&lt;br/&gt;
+   * @return the client&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
   public static &amp;lt;T&amp;gt; T getClient(Class&amp;lt;T&amp;gt; iface, SpecificRequestor requestor)&lt;br/&gt;
     throws IOException 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {@@ -200,7 +281,12 @@ public Exception readError(Schema writer, Schema reader, Decoder in)                                   new Class[] { iface }, requestor);   }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Return the remote protocol for a proxy. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Return the remote protocol for a proxy.  @param proxy the proxy&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the remote&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static Protocol getRemote(Object proxy) throws IOException {&lt;br/&gt;
     return ((Requestor)Proxy.getInvocationHandler(proxy)).getRemote();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/specific/SpecificResponder.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/specific/SpecificResponder.java&lt;br/&gt;
index 1c8ca08b7..51faeb8bc 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/specific/SpecificResponder.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/specific/SpecificResponder.java&lt;br/&gt;
@@ -35,27 +35,60 @@&lt;br/&gt;
 import org.apache.avro.specific.SpecificDatumWriter;&lt;br/&gt;
 import org.apache.avro.ipc.generic.GenericResponder;&lt;/p&gt;

&lt;p&gt;-/** &lt;/p&gt;
{@link org.apache.avro.ipc.Responder Responder} for generated interfaces.*/&lt;br/&gt;
+/**&lt;br/&gt;
+ * {@link org.apache.avro.ipc.Responder Responder}
&lt;p&gt; for generated interfaces.&lt;br/&gt;
+ */&lt;br/&gt;
 public class SpecificResponder extends GenericResponder {&lt;br/&gt;
   private Object impl;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Specific responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface the iface&lt;br/&gt;
+   * @param impl  the&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificResponder(Class iface, Object impl) &lt;/p&gt;
{
     this(iface, impl, new SpecificData(impl.getClass().getClassLoader()));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Specific responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol the protocol&lt;br/&gt;
+   * @param impl     the&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificResponder(Protocol protocol, Object impl) &lt;/p&gt;
{
     this(protocol, impl, new SpecificData(impl.getClass().getClassLoader()));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Specific responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param iface the iface&lt;br/&gt;
+   * @param impl  the&lt;br/&gt;
+   * @param data  the data&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificResponder(Class iface, Object impl, SpecificData data) &lt;/p&gt;
{
     this(data.getProtocol(iface), impl, data);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Specific responder.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol the protocol&lt;br/&gt;
+   * @param impl     the&lt;br/&gt;
+   * @param data     the data&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificResponder(Protocol protocol, Object impl, SpecificData data) &lt;/p&gt;
{
     super(protocol, data);
     this.impl = impl;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets specific data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the specific data&lt;br/&gt;
+   */&lt;br/&gt;
   public SpecificData getSpecificData() &lt;/p&gt;
{return (SpecificData)getGenericData();}

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/FloatHistogram.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/FloatHistogram.java&lt;br/&gt;
index a9bb670f8..1644609ce 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/FloatHistogram.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/FloatHistogram.java&lt;br/&gt;
@@ -20,12 +20,18 @@&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Specific implementation of histogram for floats,&lt;/li&gt;
	&lt;li&gt;which also keeps track of basic summary statistics.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @param &amp;lt;B&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;B&amp;gt; the type parameter&lt;br/&gt;
  */&lt;br/&gt;
 class FloatHistogram&amp;lt;B&amp;gt; extends Histogram&amp;lt;B, Float&amp;gt; {&lt;br/&gt;
   private float runningSum;&lt;br/&gt;
   private float runningSumOfSquares;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Float histogram.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param segmenter the segmenter&lt;br/&gt;
+   */&lt;br/&gt;
   public FloatHistogram(Segmenter&amp;lt;B, Float&amp;gt; segmenter) &lt;/p&gt;
{
     super(segmenter);
   }&lt;br/&gt;
@@ -37,6 +43,11 @@ public void add(Float value) {
     runningSumOfSquares += value*value;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets mean.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the mean&lt;br/&gt;
+   */&lt;br/&gt;
   public float getMean() {&lt;br/&gt;
     if (totalCount == 0) {&lt;br/&gt;
       return Float.NaN;&lt;br/&gt;
@@ -44,6 +55,11 @@ public float getMean() {
     return runningSum / totalCount;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets unbiased std dev.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the unbiased std dev&lt;br/&gt;
+   */&lt;br/&gt;
   public float getUnbiasedStdDev() {&lt;br/&gt;
     if (totalCount &amp;lt;= 1) {&lt;br/&gt;
       return Float.NaN;&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/Histogram.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/Histogram.java&lt;br/&gt;
index 26b508d30..cb0d1f2cd 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/Histogram.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/Histogram.java&lt;br/&gt;
@@ -29,10 +29,10 @@&lt;br/&gt;
  * Represents a histogram of values.  This class uses a {@link Segmenter}&lt;br/&gt;
  * to determine which bucket to place a given value into. Also stores the last&lt;br/&gt;
  * MAX_HISTORY_SIZE entries which have been added to this histogram, in order.&lt;br/&gt;
- *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;&lt;br/&gt;
  * Note that Histogram, by itself, is not synchronized.&lt;br/&gt;
- * @param &amp;lt;B&amp;gt; Bucket type.  Often String, since buckets are typically&lt;br/&gt;
- * used for their toString() representation.&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;B&amp;gt; Bucket type.  Often String, since buckets are typically used for their toString() representation.&lt;br/&gt;
  * @param &amp;lt;T&amp;gt; Type of value&lt;br/&gt;
  */&lt;br/&gt;
 class Histogram&amp;lt;B, T&amp;gt; {&lt;br/&gt;
@@ -43,52 +43,88 @@&lt;br/&gt;
 &lt;br/&gt;
   private Segmenter&amp;lt;B, T&amp;gt; segmenter;&lt;br/&gt;
   private int[] counts;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Total count.&lt;br/&gt;
+   */&lt;br/&gt;
   protected int totalCount;&lt;br/&gt;
   private LinkedList&amp;lt;T&amp;gt; recentAdditions;&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Interface to determine which bucket to place a value in.&lt;br/&gt;
-   *&lt;br/&gt;
+   * &amp;lt;p&amp;gt;&lt;br/&gt;
    * Segmenters should be immutable, so many histograms can re-use&lt;br/&gt;
    * the same segmenter.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param &amp;lt;B&amp;gt; the type parameter&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; the type parameter&lt;br/&gt;
    */&lt;br/&gt;
   interface Segmenter&amp;lt;B, T&amp;gt; {
-    /** Number of buckets to use. */
+    /**
+     * Number of buckets to use.  @return the int
+     */
     int size();
+
     /**
      * Which bucket to place value in.
      *
+     * @param value the value
      * @return Index of bucket for the value.  At least 0 and less than size().
      * @throws SegmenterException if value does not fit in a bucket.
      */
     int segment(T value);
+
     /**
      * Returns an iterator of buckets. The order of iteration
      * is consistent with the segment numbers.
+     *
+     * @return the buckets
      */
     Iterator&amp;lt;B&amp;gt; getBuckets();
 
     /**
      * Returns a List of bucket boundaries. Useful for printing
      * segmenters.
+     *
+     * @return the boundary labels
      */
     List&amp;lt;String&amp;gt; getBoundaryLabels();
 
     /**
      * Returns the bucket labels as an array;
+     *
+     * @return the bucket labels
      */
     List&amp;lt;String&amp;gt; getBucketLabels();
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Segmenter exception.&lt;br/&gt;
+   */&lt;br/&gt;
   public static class SegmenterException extends RuntimeException {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Segmenter exception.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param s the s&lt;br/&gt;
+     */&lt;br/&gt;
     public SegmenterException(String s) {
       super(s);
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Tree map segmenter.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; the type parameter&lt;br/&gt;
+   */&lt;br/&gt;
   public static class TreeMapSegmenter&amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;br/&gt;
       implements Segmenter&amp;lt;String, T&amp;gt; {&lt;br/&gt;
     private TreeMap&amp;lt;T, Integer&amp;gt; index = new TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Tree map segmenter.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param leftEndpoints the left endpoints&lt;br/&gt;
+     */&lt;br/&gt;
     public TreeMapSegmenter(SortedSet&amp;lt;T&amp;gt; leftEndpoints) {&lt;br/&gt;
       if (leftEndpoints.isEmpty()) {&lt;br/&gt;
         throw new IllegalArgumentException(&lt;br/&gt;
@@ -166,6 +202,8 @@ public void remove() {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Creates a histogram using the specified segmenter.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param segmenter the segmenter&lt;br/&gt;
    */&lt;br/&gt;
   public Histogram(Segmenter&amp;lt;B, T&amp;gt; segmenter) {&lt;br/&gt;
     this.segmenter = segmenter;&lt;br/&gt;
@@ -173,7 +211,9 @@ public Histogram(Segmenter&amp;lt;B, T&amp;gt; segmenter) {
     this.recentAdditions = new LinkedList&amp;lt;&amp;gt;();
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Tallies a value in the histogram. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Tallies a value in the histogram.  @param value the value&lt;br/&gt;
+   */&lt;br/&gt;
   public void add(T value) {&lt;br/&gt;
     int i = segmenter.segment(value);&lt;br/&gt;
     counts&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;++;&lt;br/&gt;
@@ -186,6 +226,8 @@ public void add(T value) {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Returns the underlying bucket values.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the int [ ]&lt;br/&gt;
    */&lt;br/&gt;
   public int[] getHistogram() {&lt;br/&gt;
     return counts;&lt;br/&gt;
@@ -193,6 +235,8 @@ public void add(T value) {&lt;br/&gt;
 &lt;br/&gt;
   /**&lt;br/&gt;
    * Returns the underlying segmenter used for this histogram.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the segmenter&lt;br/&gt;
    */&lt;br/&gt;
   public Segmenter&amp;lt;B, T&amp;gt; getSegmenter() {&lt;br/&gt;
     return this.segmenter;&lt;br/&gt;
@@ -201,12 +245,16 @@ public void add(T value) {&lt;br/&gt;
   /**&lt;br/&gt;
    * Returns values recently added to this histogram. These are in reverse&lt;br/&gt;
    * order (most recent first).&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the recent additions&lt;br/&gt;
    */&lt;br/&gt;
   public List&amp;lt;T&amp;gt; getRecentAdditions() {
     return this.recentAdditions;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Returns the total count of entries. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns the total count of entries.  @return the count&lt;br/&gt;
+   */&lt;br/&gt;
   public int getCount() {
     return totalCount;
   }&lt;br/&gt;
@@ -226,17 +274,41 @@ public String toString() {
     return sb.toString();
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Entry.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param &amp;lt;B&amp;gt; the type parameter&lt;br/&gt;
+   */&lt;br/&gt;
   static class Entry&amp;lt;B&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Entry.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param bucket the bucket&lt;br/&gt;
+     * @param count  the count&lt;br/&gt;
+     */&lt;br/&gt;
     public Entry(B bucket, int count) {
       this.bucket = bucket;
       this.count = count;
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Bucket.&lt;br/&gt;
+     */&lt;br/&gt;
     B bucket;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Count.&lt;br/&gt;
+     */&lt;br/&gt;
     int count;&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
   private class EntryIterator implements Iterable&amp;lt;Entry&amp;lt;B&amp;gt;&amp;gt;, Iterator&amp;lt;Entry&amp;lt;B&amp;gt;&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The .&lt;br/&gt;
+     */&lt;br/&gt;
     int i = 0;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Bucket name iterator.&lt;br/&gt;
+     */&lt;br/&gt;
     Iterator&amp;lt;B&amp;gt; bucketNameIterator = segmenter.getBuckets();&lt;br/&gt;
 &lt;br/&gt;
     @Override&lt;br/&gt;
@@ -261,6 +333,11 @@ public void remove() {&lt;br/&gt;
 &lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Entries iterable.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the iterable&lt;br/&gt;
+   */&lt;br/&gt;
   public Iterable&amp;lt;Entry&amp;lt;B&amp;gt;&amp;gt; entries() {
     return new EntryIterator();
   }&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/IntegerHistogram.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/IntegerHistogram.java&lt;br/&gt;
index 9dfcb5e51..440d83595 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/IntegerHistogram.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/IntegerHistogram.java&lt;br/&gt;
@@ -20,12 +20,18 @@&lt;br/&gt;
 /**&lt;br/&gt;
  * Specific implementation of histogram for integers,&lt;br/&gt;
  * which also keeps track of basic summary statistics.&lt;br/&gt;
- * @param &amp;lt;B&amp;gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * @param &amp;lt;B&amp;gt; the type parameter&lt;br/&gt;
  */&lt;br/&gt;
 class IntegerHistogram&amp;lt;B&amp;gt; extends Histogram&amp;lt;B, Integer&amp;gt; {&lt;br/&gt;
   private float runningSum;&lt;br/&gt;
   private float runningSumOfSquares;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Integer histogram.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param segmenter the segmenter&lt;br/&gt;
+   */&lt;br/&gt;
   public IntegerHistogram(Segmenter&amp;lt;B, Integer&amp;gt; segmenter) {     super(segmenter);   }
&lt;p&gt;@@ -37,6 +43,11 @@ public void add(Integer value) &lt;/p&gt;
{
     runningSumOfSquares += value*value;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets mean.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the mean&lt;br/&gt;
+   */&lt;br/&gt;
   public float getMean() {&lt;br/&gt;
     if (totalCount == 0) {&lt;br/&gt;
       return -1;&lt;br/&gt;
@@ -44,6 +55,11 @@ public float getMean() &lt;/p&gt;
{
     return runningSum / (float) totalCount;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets unbiased std dev.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the unbiased std dev&lt;br/&gt;
+   */&lt;br/&gt;
   public float getUnbiasedStdDev() {&lt;br/&gt;
     if (totalCount &amp;lt;= 1) {&lt;br/&gt;
       return -1;&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsPlugin.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsPlugin.java&lt;br/&gt;
index 553b4241e..37aa823a5 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsPlugin.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsPlugin.java&lt;br/&gt;
@@ -37,12 +37,14 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Collects count and latency statistics about RPC calls.  Keeps&lt;/li&gt;
	&lt;li&gt;data for every method. Can be added to a Requestor (client)&lt;/li&gt;
	&lt;li&gt;or Responder (server).&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+ * &amp;lt;p&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;This uses milliseconds as the standard unit of measure&lt;/li&gt;
	&lt;li&gt;throughout the class, stored in floats.&lt;br/&gt;
  */&lt;br/&gt;
 public class StatsPlugin extends RPCPlugin {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Static declaration of histogram buckets. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Static declaration of histogram buckets.&lt;br/&gt;
+   */&lt;br/&gt;
   static final Segmenter&amp;lt;String, Float&amp;gt; LATENCY_SEGMENTER =&lt;br/&gt;
       new Histogram.TreeMapSegmenter&amp;lt;&amp;gt;(new TreeSet&amp;lt;&amp;gt;(Arrays.asList(&lt;br/&gt;
             0f,&lt;br/&gt;
@@ -61,6 +63,9 @@&lt;br/&gt;
         60000f, // 1 minute&lt;br/&gt;
        600000f)));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * The Payload segmenter.&lt;br/&gt;
+   */&lt;br/&gt;
   static final Segmenter&amp;lt;String, Integer&amp;gt; PAYLOAD_SEGMENTER =&lt;br/&gt;
       new Histogram.TreeMapSegmenter&amp;lt;&amp;gt;(new TreeSet&amp;lt;&amp;gt;(Arrays.asList(&lt;br/&gt;
             0,&lt;br/&gt;
@@ -79,29 +84,46 @@&lt;br/&gt;
         50000,&lt;br/&gt;
        100000)));&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Per-method histograms.&lt;/li&gt;
	&lt;li&gt;* Must be accessed while holding a lock. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Per-method histograms.&lt;br/&gt;
+   * Must be accessed while holding a lock.&lt;br/&gt;
+   */&lt;br/&gt;
   Map&amp;lt;Message, FloatHistogram&amp;lt;?&amp;gt;&amp;gt; methodTimings =&lt;br/&gt;
     new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * The Send payloads.&lt;br/&gt;
+   */&lt;br/&gt;
   Map&amp;lt;Message, IntegerHistogram&amp;lt;?&amp;gt;&amp;gt; sendPayloads =&lt;br/&gt;
     new HashMap&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The Receive payloads.&lt;br/&gt;
+   */&lt;br/&gt;
   Map&amp;lt;Message, IntegerHistogram&amp;lt;?&amp;gt;&amp;gt; receivePayloads =&lt;br/&gt;
     new HashMap&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** RPCs in flight. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * RPCs in flight.&lt;br/&gt;
+   */&lt;br/&gt;
   ConcurrentMap&amp;lt;RPCContext, Stopwatch&amp;gt; activeRpcs =&lt;br/&gt;
     new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
   private Ticks ticks;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** How long I&apos;ve been alive */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * How long I&apos;ve been alive&lt;br/&gt;
+   */&lt;br/&gt;
   public Date startupTime = new Date();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   private Segmenter&amp;lt;?, Float&amp;gt; floatSegmenter;&lt;br/&gt;
   private Segmenter&amp;lt;?, Integer&amp;gt; integerSegmenter;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Construct a plugin with custom Ticks and Segmenter implementations. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Construct a plugin with custom Ticks and Segmenter implementations.  @param ticks the ticks&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param floatSegmenter   the float segmenter&lt;br/&gt;
+   * @param integerSegmenter the integer segmenter&lt;br/&gt;
+   */&lt;br/&gt;
   StatsPlugin(Ticks ticks, Segmenter&amp;lt;?, Float&amp;gt; floatSegmenter,&lt;br/&gt;
       Segmenter&amp;lt;?, Integer&amp;gt; integerSegmenter) 
{
     this.floatSegmenter = floatSegmenter;
@@ -109,8 +131,10 @@
     this.ticks = ticks;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Construct a plugin with default (system) ticks, and default&lt;/li&gt;
	&lt;li&gt;* histogram segmentation. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Construct a plugin with default (system) ticks, and default&lt;br/&gt;
+   * histogram segmentation.&lt;br/&gt;
+   */&lt;br/&gt;
   public StatsPlugin() 
{
     this(Stopwatch.SYSTEM_TICKS, LATENCY_SEGMENTER, PAYLOAD_SEGMENTER);
   }
&lt;p&gt;@@ -219,7 +243,11 @@ private void publish(RPCContext context, Stopwatch t) &lt;/p&gt;
{
     return new IntegerHistogram(integerSegmenter);
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Converts nanoseconds to milliseconds. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Converts nanoseconds to milliseconds.  @param elapsedNanos the elapsed nanos&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the float&lt;br/&gt;
+   */&lt;br/&gt;
   static float nanosToMillis(long elapsedNanos) 
{
     return elapsedNanos / 1000000.0f;
   }
&lt;p&gt;diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsServer.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsServer.java&lt;br/&gt;
index 19d818aeb..a5f178f88 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsServer.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsServer.java&lt;br/&gt;
@@ -20,6 +20,9 @@&lt;br/&gt;
 import org.eclipse.jetty.servlet.ServletHandler;&lt;br/&gt;
 import org.eclipse.jetty.servlet.ServletHolder;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+/**&lt;br/&gt;
+ * The type Stats server.&lt;br/&gt;
+ */&lt;br/&gt;
 /* This is a server that displays live information from a StatsPlugin.&lt;br/&gt;
  *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Typical usage is as follows:&lt;br/&gt;
@@ -29,9 +32,22 @@&lt;br/&gt;
  *&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
 public class StatsServer {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Http server.&lt;br/&gt;
+   */&lt;br/&gt;
   Server httpServer;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Plugin.&lt;br/&gt;
+   */&lt;br/&gt;
   StatsPlugin plugin;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Stats server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param plugin the plugin&lt;br/&gt;
+   * @param port   the port&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   /* Start a stats server on the given port,&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;responsible for the given plugin. */&lt;br/&gt;
   public StatsServer(StatsPlugin plugin, int port) throws Exception {&lt;br/&gt;
@@ -47,6 +63,11 @@ public StatsServer(StatsPlugin plugin, int port) throws Exception 
{
     httpServer.start();
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Stop.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   /* Stops this server. */&lt;br/&gt;
   public void stop() throws Exception {&lt;br/&gt;
     this.httpServer.stop();&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsServlet.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsServlet.java&lt;br/&gt;
index f51789a82..9084265ad 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsServlet.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/StatsServlet.java&lt;br/&gt;
@@ -45,7 +45,7 @@&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Exposes information provided by a StatsPlugin as&lt;/li&gt;
	&lt;li&gt;a web page.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+ * &amp;lt;p&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;This class follows the same synchronization conventions&lt;/li&gt;
	&lt;li&gt;as StatsPlugin, to avoid requiring StatsPlugin to serve&lt;/li&gt;
	&lt;li&gt;a copy of the data.&lt;br/&gt;
@@ -56,6 +56,12 @@&lt;br/&gt;
   private static final SimpleDateFormat FORMATTER =&lt;br/&gt;
     new SimpleDateFormat(&quot;dd-MMM-yyyy HH:mm:ss&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Stats servlet.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param statsPlugin the stats plugin&lt;br/&gt;
+   * @throws UnavailableException the unavailable exception&lt;br/&gt;
+   */&lt;br/&gt;
   public StatsServlet(StatsPlugin statsPlugin) throws UnavailableException {&lt;br/&gt;
     this.statsPlugin = statsPlugin;&lt;br/&gt;
     this.velocityEngine = new VelocityEngine();&lt;br/&gt;
@@ -70,33 +76,71 @@ public StatsServlet(StatsPlugin statsPlugin) throws UnavailableException &lt;/p&gt;
{
     velocityEngine.setProperty(&quot;runtime.log.logsystem.class&quot;, logChuteName);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Renderable message.&lt;br/&gt;
+   */&lt;br/&gt;
   /* Helper class to store per-message data which is passed to templates.&lt;br/&gt;
    *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The template expects a list of charts, each of which is parameterized by&lt;/li&gt;
	&lt;li&gt;map key-value string attributes. */&lt;br/&gt;
   public class RenderableMessage { // Velocity brakes if not public&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Name.&lt;br/&gt;
+     */&lt;br/&gt;
     public String name;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Num calls.&lt;br/&gt;
+     */&lt;br/&gt;
     public int numCalls;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Charts.&lt;br/&gt;
+     */&lt;br/&gt;
     public ArrayList&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt; charts;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Renderable message.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name the name&lt;br/&gt;
+     */&lt;br/&gt;
     public RenderableMessage(String name) &lt;/p&gt;
{
       this.name = name;
       this.charts = new ArrayList&amp;lt;&amp;gt;();
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * Gets charts.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the charts&lt;br/&gt;
+     */&lt;br/&gt;
     public ArrayList&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt; getCharts() &lt;/p&gt;
{
       return this.charts;
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * Gets .&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the&lt;br/&gt;
+     */&lt;br/&gt;
     public String getname() &lt;/p&gt;
{
       return this.name;
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * Gets num calls.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the num calls&lt;br/&gt;
+     */&lt;br/&gt;
     public int getNumCalls() &lt;/p&gt;
{
       return this.numCalls;
     }
&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Escape string array list.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param input the input&lt;br/&gt;
+   * @return the list&lt;br/&gt;
+   */&lt;br/&gt;
   /* Surround each string in an array with&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;quotation marks and escape existing quotes.&lt;br/&gt;
    *&lt;br/&gt;
@@ -125,6 +169,12 @@ protected void doGet(HttpServletRequest req, HttpServletResponse resp)&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Write stats.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param w the w&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   void writeStats(Writer w) throws IOException {&lt;br/&gt;
     VelocityContext context = new VelocityContext();&lt;br/&gt;
     context.put(&quot;title&quot;, &quot;Avro RPC Stats&quot;);&lt;br/&gt;
diff --git a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/Stopwatch.java b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/Stopwatch.java&lt;br/&gt;
index f9c9386ec..0b0c1334a 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/Stopwatch.java&lt;br/&gt;
+++ b/lang/java/ipc/src/main/java/org/apache/avro/ipc/stats/Stopwatch.java&lt;br/&gt;
@@ -17,18 +17,26 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.avro.ipc.stats;&lt;/p&gt;

&lt;p&gt;-/** Encapsulates the passing of time. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Encapsulates the passing of time.&lt;br/&gt;
+ */&lt;br/&gt;
 class Stopwatch  {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Encapsulates ticking time sources. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Encapsulates ticking time sources.&lt;br/&gt;
+   */&lt;br/&gt;
   interface Ticks 
{
     /**
      * Returns a number of &quot;ticks&quot; in nanoseconds.
      * This should be monotonically non-decreasing.
+     *
+     * @return the long
      */
     long ticks();
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Default System time source. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Default System time source.&lt;br/&gt;
+   */&lt;br/&gt;
   public final static Ticks SYSTEM_TICKS = new SystemTicks();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   private Ticks ticks;&lt;br/&gt;
@@ -36,11 +44,18 @@&lt;br/&gt;
   private long elapsed = -1;&lt;br/&gt;
   private boolean running;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Stopwatch.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param ticks the ticks&lt;br/&gt;
+   */&lt;br/&gt;
   public Stopwatch(Ticks ticks) &lt;/p&gt;
{
     this.ticks = ticks;
   }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Returns seconds that have elapsed since start() */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns seconds that have elapsed since start()  @return the long&lt;br/&gt;
+   */&lt;br/&gt;
   public long elapsedNanos() {&lt;br/&gt;
     if (running) {&lt;br/&gt;
       return this.ticks.ticks() - start;&lt;br/&gt;
@@ -50,14 +65,18 @@ public long elapsedNanos() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Starts the stopwatch. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Starts the stopwatch.&lt;br/&gt;
+   */&lt;br/&gt;
   public void start() 
{
     if (running) throw new IllegalStateException();
     start = ticks.ticks();
     running = true;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Stops the stopwatch and calculates the elapsed time. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Stops the stopwatch and calculates the elapsed time.&lt;br/&gt;
+   */&lt;br/&gt;
   public void stop() {&lt;br/&gt;
     if (!running) throw new IllegalStateException();&lt;br/&gt;
     elapsed = ticks.ticks() - start;&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/DataFileInteropTest.java b/lang/java/ipc/src/test/java/org/apache/avro/DataFileInteropTest.java&lt;br/&gt;
index ed4c95b41..a47c196c6 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/test/java/org/apache/avro/DataFileInteropTest.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/DataFileInteropTest.java&lt;br/&gt;
@@ -29,17 +29,28 @@&lt;br/&gt;
 import org.junit.BeforeClass;&lt;br/&gt;
 import org.junit.Test;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+/**&lt;br/&gt;
+ * The type Data file interop test.&lt;br/&gt;
+ */&lt;br/&gt;
 public class DataFileInteropTest {&lt;/p&gt;

&lt;p&gt;   private static final File DATAFILE_DIR =&lt;br/&gt;
     new File(System.getProperty(&quot;test.dir&quot;, &quot;/tmp&quot;));&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Print dir.&lt;br/&gt;
+   */&lt;br/&gt;
   @BeforeClass&lt;br/&gt;
   public static void printDir() &lt;/p&gt;
{
     System.out.println(&quot;Reading data files from directory: &quot;
         + DATAFILE_DIR.getAbsolutePath());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test generated generic.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testGeneratedGeneric() throws IOException {&lt;br/&gt;
     System.out.println(&quot;Reading with generic:&quot;);&lt;br/&gt;
@@ -51,6 +62,11 @@ public void testGeneratedGeneric() throws IOException &lt;/p&gt;
{
     readFiles(provider);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test generated specific.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testGeneratedSpecific() throws IOException {&lt;br/&gt;
     System.out.println(&quot;Reading with specific:&quot;);&lt;br/&gt;
@@ -95,7 +111,17 @@ public void testGeneratedSpecific() throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The interface Datum reader provider.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; the type parameter&lt;br/&gt;
+   */&lt;br/&gt;
   interface DatumReaderProvider&amp;lt;T extends Object&amp;gt; &lt;/p&gt;
{
+    /**
+     * Get datum reader.
+     *
+     * @return the datum reader
+     */
     public DatumReader&amp;lt;T&amp;gt; get();
   }

&lt;p&gt;diff --git a/lang/java/ipc/src/test/java/org/apache/avro/RPCMetaTestPlugin.java b/lang/java/ipc/src/test/java/org/apache/avro/RPCMetaTestPlugin.java&lt;br/&gt;
index 8ada2439b..201262810 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/RPCMetaTestPlugin.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/RPCMetaTestPlugin.java&lt;br/&gt;
@@ -35,8 +35,16 @@&lt;br/&gt;
  */&lt;br/&gt;
 public final class RPCMetaTestPlugin extends RPCPlugin {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The Key.&lt;br/&gt;
+   */&lt;br/&gt;
   protected final String key;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Rpc meta test plugin.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param keyname the keyname&lt;br/&gt;
+   */&lt;br/&gt;
   public RPCMetaTestPlugin(String keyname) &lt;/p&gt;
{
     key = keyname;
   }
&lt;p&gt;@@ -171,6 +179,11 @@ public void clientReceiveResponse(RPCContext context) &lt;/p&gt;
{
     checkRPCMetaMap(context.responseCallMeta());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Check rpc meta map.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param rpcMeta the rpc meta&lt;br/&gt;
+   */&lt;br/&gt;
   protected void checkRPCMetaMap(Map&amp;lt;String,ByteBuffer&amp;gt; rpcMeta) {&lt;br/&gt;
     Assert.assertNotNull(rpcMeta);&lt;br/&gt;
     Assert.assertTrue(&quot;key not present in map&quot;, rpcMeta.containsKey(key));&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/RandomData.java b/lang/java/ipc/src/test/java/org/apache/avro/RandomData.java&lt;br/&gt;
index 1d9d4ce5e..73c316435 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/RandomData.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/RandomData.java&lt;br/&gt;
@@ -32,16 +32,31 @@&lt;br/&gt;
 import org.apache.avro.generic.GenericRecord;&lt;br/&gt;
 import org.apache.avro.util.Utf8;&lt;/p&gt;

&lt;p&gt;-/** Generates schema data as Java objects with random values. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Generates schema data as Java objects with random values.&lt;br/&gt;
+ */&lt;br/&gt;
 public class RandomData implements Iterable&amp;lt;Object&amp;gt; {&lt;br/&gt;
   private final Schema root;&lt;br/&gt;
   private final long seed;&lt;br/&gt;
   private final int count;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Random data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param count  the count&lt;br/&gt;
+   */&lt;br/&gt;
   public RandomData(Schema schema, int count) &lt;/p&gt;
{
     this(schema, count, System.currentTimeMillis());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Random data.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param count  the count&lt;br/&gt;
+   * @param seed   the seed&lt;br/&gt;
+   */&lt;br/&gt;
   public RandomData(Schema schema, int count, long seed) {&lt;br/&gt;
     this.root = schema;&lt;br/&gt;
     this.seed = seed;&lt;br/&gt;
@@ -122,6 +137,12 @@ private static ByteBuffer randomBytes(Random rand, int maxLength) &lt;/p&gt;
{
     return bytes;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The entry point of application.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param args the input arguments&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void main(String[] args) throws Exception {&lt;br/&gt;
     if(args.length != 3) {&lt;br/&gt;
       System.out.println(&quot;Usage: RandomData &amp;lt;schemafile&amp;gt; &amp;lt;outputfile&amp;gt; &amp;lt;count&amp;gt;&quot;);&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/SimpleException.java b/lang/java/ipc/src/test/java/org/apache/avro/SimpleException.java&lt;br/&gt;
index ee0875b38..39b24ba89 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/SimpleException.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/SimpleException.java&lt;br/&gt;
@@ -17,9 +17,20 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.avro;&lt;/p&gt;

&lt;p&gt;-/** This should be a static nested class in TestProtocolReflect, but that&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* breaks CheckStyle (&lt;a href=&quot;http://jira.codehaus.org/browse/MPCHECKSTYLE-20&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://jira.codehaus.org/browse/MPCHECKSTYLE-20&lt;/a&gt;). */&lt;br/&gt;
+/**&lt;br/&gt;
+ * This should be a static nested class in TestProtocolReflect, but that&lt;br/&gt;
+ * breaks CheckStyle (&lt;a href=&quot;http://jira.codehaus.org/browse/MPCHECKSTYLE-20&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://jira.codehaus.org/browse/MPCHECKSTYLE-20&lt;/a&gt;).&lt;br/&gt;
+ */&lt;br/&gt;
 public class SimpleException extends Exception {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Simple exception.&lt;br/&gt;
+   */&lt;br/&gt;
   SimpleException() {}&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Instantiates a new Simple exception.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param message the message&lt;br/&gt;
+   */&lt;br/&gt;
   SimpleException(String message) 
{ super(message) ; }
&lt;p&gt; }&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestAnnotation.java b/lang/java/ipc/src/test/java/org/apache/avro/TestAnnotation.java&lt;br/&gt;
index 1baba683d..45b7479fa 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/test/java/org/apache/avro/TestAnnotation.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestAnnotation.java&lt;br/&gt;
@@ -22,6 +22,9 @@&lt;br/&gt;
 import java.lang.annotation.Retention;&lt;br/&gt;
 import java.lang.annotation.RetentionPolicy;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+/**&lt;br/&gt;
+ * The interface Test annotation.&lt;br/&gt;
+ */&lt;br/&gt;
 @Target(&lt;/p&gt;
{ElementType.TYPE, ElementType.FIELD, ElementType.METHOD}
&lt;p&gt;)&lt;br/&gt;
 @Retention(RetentionPolicy.RUNTIME)&lt;br/&gt;
 public @interface TestAnnotation {&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestBulkData.java b/lang/java/ipc/src/test/java/org/apache/avro/TestBulkData.java&lt;br/&gt;
index d620e9e02..359acfb1a 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestBulkData.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestBulkData.java&lt;br/&gt;
@@ -36,6 +36,9 @@&lt;/p&gt;

&lt;p&gt; import org.apache.avro.test.BulkData;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test bulk data.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestBulkData &lt;/p&gt;
{
   private static final long COUNT =
     Integer.parseInt(System.getProperty(&quot;test.count&quot;, &quot;10&quot;));
@@ -50,6 +53,9 @@
     rand.nextBytes(DATA.array());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Bulk data.&lt;br/&gt;
+   */&lt;br/&gt;
   public static class BulkDataImpl implements BulkData {&lt;br/&gt;
     public ByteBuffer read() &lt;/p&gt;
{ return DATA.duplicate(); }
&lt;p&gt;     public Void write(ByteBuffer data) {&lt;br/&gt;
@@ -62,6 +68,11 @@ public Void write(ByteBuffer data) {&lt;br/&gt;
   private static Transceiver client;&lt;br/&gt;
   private static BulkData proxy;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Start server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void startServer() throws Exception {&lt;br/&gt;
     if (server != null) return;&lt;br/&gt;
@@ -74,23 +85,44 @@ public void startServer() throws Exception &lt;/p&gt;
{
     proxy = SpecificRequestor.getClient(BulkData.class, client);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test read.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRead() throws IOException &lt;/p&gt;
{
     for (int i = 0; i &amp;lt; COUNT; i++)
       Assert.assertEquals(SIZE, proxy.read().remaining());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test write.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testWrite() throws IOException &lt;/p&gt;
{
     for (int i = 0; i &amp;lt; COUNT; i++)
       proxy.write(DATA.duplicate());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Stop server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void stopServer() throws Exception &lt;/p&gt;
{
     server.close();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The entry point of application.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param args the input arguments&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void main(String[] args) throws Exception {&lt;br/&gt;
     TestBulkData test = new TestBulkData();&lt;br/&gt;
     test.startServer();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestCompare.java b/lang/java/ipc/src/test/java/org/apache/avro/TestCompare.java&lt;br/&gt;
index ce6f340b2..24c1730c0 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestCompare.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestCompare.java&lt;br/&gt;
@@ -39,8 +39,16 @@&lt;br/&gt;
 import org.apache.avro.test.Kind;&lt;br/&gt;
 import org.apache.avro.test.MD5;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test compare.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestCompare {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test null.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNull() throws Exception {&lt;br/&gt;
     Schema schema = Schema.parse(&quot;\&quot;null\&quot;&quot;);&lt;br/&gt;
@@ -48,11 +56,21 @@ public void testNull() throws Exception &lt;/p&gt;
{
     assertEquals(0, BinaryData.compare(b, 0, b, 0, schema));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test boolean.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBoolean() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;boolean\&quot;&quot;, Boolean.FALSE, Boolean.TRUE);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test string.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testString() throws Exception {&lt;br/&gt;
     check(&quot;\&quot;string\&quot;&quot;, new Utf8(&quot;&quot;), new Utf8(&quot;a&quot;));&lt;br/&gt;
@@ -61,6 +79,11 @@ public void testString() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;string\&quot;&quot;, new Utf8(&quot;ab&quot;), new Utf8(&quot;b&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test bytes.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBytes() throws Exception {&lt;br/&gt;
     check(&quot;\&quot;bytes\&quot;&quot;,&lt;br/&gt;
@@ -74,30 +97,55 @@ public void testBytes() throws Exception {&lt;br/&gt;
           ByteBuffer.wrap(new byte[]&lt;/p&gt;
{2}
&lt;p&gt;));&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test int.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testInt() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;int\&quot;&quot;, new Integer(-1), new Integer(0));
     check(&quot;\&quot;int\&quot;&quot;, new Integer(0), new Integer(1));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test long.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testLong() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;long\&quot;&quot;, new Long(11), new Long(12));
     check(&quot;\&quot;long\&quot;&quot;, new Long(-1), new Long(1));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test float.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFloat() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;float\&quot;&quot;, new Float(1.1), new Float(1.2));
     check(&quot;\&quot;float\&quot;&quot;, new Float(-1.1), new Float(1.0));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test double.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testDouble() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;double\&quot;&quot;, new Double(1.2), new Double(1.3));
     check(&quot;\&quot;double\&quot;&quot;, new Double(-1.2), new Double(1.3));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test array.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testArray() throws Exception {&lt;br/&gt;
     String json = &quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;array\&quot;, \&quot;items\&quot;: \&quot;long\&quot;}
&lt;p&gt;&quot;;&lt;br/&gt;
@@ -110,6 +158,11 @@ public void testArray() throws Exception &lt;/p&gt;
{
     check(json, a1, a2);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRecord() throws Exception {&lt;br/&gt;
     String fields = &quot; \&quot;fields\&quot;:[&quot;&lt;br/&gt;
@@ -141,6 +194,11 @@ public void testRecord() throws Exception &lt;/p&gt;
{
     assert(!r1.equals(r3));                       // same fields, diff name
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test enum.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEnum() throws Exception {&lt;br/&gt;
     String json =&lt;br/&gt;
@@ -151,6 +209,11 @@ public void testEnum() throws Exception &lt;/p&gt;
{
           new GenericData.EnumSymbol(schema, &quot;B&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test fixed.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFixed() throws Exception {&lt;br/&gt;
     String json = &quot;&lt;/p&gt;
{\&quot;type\&quot;: \&quot;fixed\&quot;, \&quot;name\&quot;:\&quot;Test\&quot;, \&quot;size\&quot;: 1}
&lt;p&gt;&quot;;&lt;br/&gt;
@@ -160,6 +223,11 @@ public void testFixed() throws Exception {&lt;br/&gt;
           new GenericData.Fixed(schema, new byte[]&lt;/p&gt;
{(byte)&apos;b&apos;}
&lt;p&gt;));&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test union.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testUnion() throws Exception {&lt;br/&gt;
     check(&quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;\&amp;quot;string\&amp;quot;, \&amp;quot;long\&amp;quot;&amp;#93;&lt;/span&gt;&quot;, new Utf8(&quot;a&quot;), new Utf8(&quot;b&quot;), false);&lt;br/&gt;
@@ -167,6 +235,11 @@ public void testUnion() throws Exception &lt;/p&gt;
{
     check(&quot;[\&quot;string\&quot;, \&quot;long\&quot;]&quot;, new Utf8(&quot;a&quot;), new Long(1), false);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test specific record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSpecificRecord() throws Exception {&lt;br/&gt;
     TestRecord s1 = new TestRecord();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestDataFileSpecific.java b/lang/java/ipc/src/test/java/org/apache/avro/TestDataFileSpecific.java&lt;br/&gt;
index 19374b416..d56421618 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestDataFileSpecific.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestDataFileSpecific.java&lt;br/&gt;
@@ -31,12 +31,20 @@&lt;/p&gt;

&lt;p&gt; import org.apache.avro.Foo;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test data file specific.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestDataFileSpecific {&lt;/p&gt;

&lt;p&gt;   private static final File DIR =&lt;br/&gt;
     new File(System.getProperty(&quot;test.dir&quot;,&quot;/tmp&quot;));&lt;br/&gt;
   private static final File FILE = new File(DIR, &quot;specific.avro&quot;);&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test specific datum reader default ctor.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   /* Test when using SpecificDatumReader&amp;lt;T&amp;gt;() constructor to read from a file&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;with a different schema that both reader &amp;amp; writer schemas are found.*/&lt;br/&gt;
   @Test&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestNamespaceReflect.java b/lang/java/ipc/src/test/java/org/apache/avro/TestNamespaceReflect.java&lt;br/&gt;
index 596c892b2..5e6b8474e 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/test/java/org/apache/avro/TestNamespaceReflect.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestNamespaceReflect.java&lt;br/&gt;
@@ -26,6 +26,9 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import java.net.InetSocketAddress;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test namespace reflect.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestNamespaceReflect extends TestNamespaceSpecific {&lt;/p&gt;

&lt;p&gt;   @Before @Override&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestNamespaceSpecific.java b/lang/java/ipc/src/test/java/org/apache/avro/TestNamespaceSpecific.java&lt;br/&gt;
index 09785c151..9861ffa3b 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestNamespaceSpecific.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestNamespaceSpecific.java&lt;br/&gt;
@@ -35,8 +35,14 @@&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.net.InetSocketAddress;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test namespace specific.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestNamespaceSpecific {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Test.&lt;br/&gt;
+   */&lt;br/&gt;
   public static class TestImpl implements TestNamespace {&lt;br/&gt;
     public TestRecord echo(TestRecord record) &lt;/p&gt;
{ return record; }
&lt;p&gt;     public Void error() throws AvroRemoteException {&lt;br/&gt;
@@ -44,10 +50,24 @@ public Void error() throws AvroRemoteException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The constant server.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static SocketServer server;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant client.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Transceiver client;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant proxy.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static TestNamespace proxy;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test start server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void testStartServer() throws Exception {&lt;br/&gt;
     if (server != null) return;&lt;br/&gt;
@@ -58,6 +78,11 @@ public void testStartServer() throws Exception &lt;/p&gt;
{
     proxy = SpecificRequestor.getClient(TestNamespace.class, client);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test echo.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEcho() throws IOException {&lt;br/&gt;
     TestRecord record = new TestRecord();&lt;br/&gt;
@@ -67,6 +92,11 @@ public void testEcho() throws IOException &lt;/p&gt;
{
     assertEquals(record.hashCode(), echoed.hashCode());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testError() throws IOException {&lt;br/&gt;
     TestError error = null;&lt;br/&gt;
@@ -79,6 +109,11 @@ public void testError() throws IOException {
     assertEquals(&quot;an error&quot;, error.getMessage$());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test stop server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void testStopServer() throws IOException {&lt;br/&gt;
     client.close();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolDatagram.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolDatagram.java&lt;br/&gt;
index 8a3289b74..46529d3be 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolDatagram.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolDatagram.java&lt;br/&gt;
@@ -28,6 +28,9 @@&lt;br/&gt;
 import org.apache.avro.ipc.specific.SpecificResponder;&lt;br/&gt;
 import org.apache.avro.test.Simple;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol datagram.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolDatagram extends TestProtocolSpecific {&lt;br/&gt;
   @Override&lt;br/&gt;
   public Server createServer(Responder testResponder) throws Exception {&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGeneric.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGeneric.java&lt;br/&gt;
index 66ecdb858..5eefc1f06 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGeneric.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGeneric.java&lt;br/&gt;
@@ -44,11 +44,20 @@&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Random;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol generic.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolGeneric {&lt;br/&gt;
   private static final Logger LOG&lt;br/&gt;
     = LoggerFactory.getLogger(TestProtocolGeneric.class);&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant FILE.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static final File FILE = new File(&quot;../../../share/test/schemas/simple.avpr&quot;);&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant PROTOCOL.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static final Protocol PROTOCOL;&lt;br/&gt;
   static {&lt;br/&gt;
     try {&lt;br/&gt;
@@ -60,7 +69,13 @@&lt;br/&gt;
 &lt;br/&gt;
   private static boolean throwUndeclaredError;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Test responder.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static class TestResponder extends GenericResponder {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Test responder.&lt;br/&gt;
+     */&lt;br/&gt;
     public TestResponder() { super(PROTOCOL); }&lt;br/&gt;
     public Object respond(Message message, Object request)&lt;br/&gt;
       throws AvroRemoteException {
@@ -96,10 +111,24 @@ public Object respond(Message message, Object request)
 
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant server.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static SocketServer server;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant client.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Transceiver client;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant requestor.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static GenericRequestor requestor;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test start server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void testStartServer() throws Exception {&lt;br/&gt;
     if (server != null) return;&lt;br/&gt;
@@ -109,6 +138,11 @@ public void testStartServer() throws Exception {
     requestor = new GenericRequestor(PROTOCOL, client);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test hello.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testHello() throws IOException {&lt;br/&gt;
     GenericRecord params =&lt;br/&gt;
@@ -118,6 +152,11 @@ public void testHello() throws IOException {
     assertEquals(new Utf8(&quot;goodbye&quot;), response);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test echo.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEcho() throws IOException {&lt;br/&gt;
     GenericRecord record =&lt;br/&gt;
@@ -135,6 +174,11 @@ public void testEcho() throws IOException {
     assertEquals(record, echoed);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test echo bytes.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEchoBytes() throws IOException {&lt;br/&gt;
     Random random = new Random();&lt;br/&gt;
@@ -149,6 +193,11 @@ public void testEchoBytes() throws IOException {
     assertEquals(data, echoed);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testError() throws IOException {&lt;br/&gt;
     GenericRecord params =&lt;br/&gt;
@@ -163,6 +212,11 @@ public void testError() throws IOException {
     assertEquals(&quot;an error&quot;, ((GenericRecord)error.getValue()).get(&quot;message&quot;).toString());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test undeclared error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testUndeclaredError() throws IOException {&lt;br/&gt;
     this.throwUndeclaredError = true;&lt;br/&gt;
@@ -180,6 +234,11 @@ public void testUndeclaredError() throws IOException {
     assertTrue(error.toString().contains(&quot;foo&quot;));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test handshake.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   /** Construct and use a different protocol whose &quot;hello&quot; method has an extra&lt;br/&gt;
       argument to check that schema is sent to parse request. */&lt;br/&gt;
@@ -211,6 +270,11 @@ public void testHandshake() throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test response change.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   /** Construct and use a different protocol whose &quot;echo&quot; response has an extra&lt;br/&gt;
       field to check that correct schema is used to parse response. */&lt;br/&gt;
@@ -255,6 +319,11 @@ public void testResponseChange() throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test stop server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void testStopServer() throws IOException {&lt;br/&gt;
     client.close();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGenericMeta.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGenericMeta.java&lt;br/&gt;
index 1c077369e..14522e699 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGenericMeta.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolGenericMeta.java&lt;br/&gt;
@@ -25,6 +25,9 @@&lt;br/&gt;
 import org.apache.avro.ipc.generic.GenericRequestor;&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol generic meta.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolGenericMeta extends TestProtocolGeneric {&lt;br/&gt;
 &lt;br/&gt;
   @Before @Override&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolHttp.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolHttp.java&lt;br/&gt;
index d73f22daf..ab714473d 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolHttp.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolHttp.java&lt;br/&gt;
@@ -35,6 +35,9 @@&lt;br/&gt;
 import java.net.SocketTimeoutException;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol http.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolHttp extends TestProtocolSpecific {&lt;br/&gt;
 &lt;br/&gt;
   @Override&lt;br/&gt;
@@ -51,6 +54,11 @@ protected int getExpectedHandshakeCount() {
     return REPEATING;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test timeout.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Throwable the throwable&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=SocketTimeoutException.class)&lt;br/&gt;
     public void testTimeout() throws Throwable {&lt;br/&gt;
     ServerSocket s = new ServerSocket(0);&lt;br/&gt;
@@ -67,7 +75,9 @@ public void testTimeout() throws Throwable {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
-  /** Test that Responder ignores one-way with stateless transport. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test that Responder ignores one-way with stateless transport.  @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testStatelessOneway() throws Exception {&lt;br/&gt;
     // a version of the Simple protocol that doesn&apos;t declare &quot;ack&quot; one-way&lt;br/&gt;
     Protocol protocol = new Protocol(&quot;Simple&quot;, &quot;org.apache.avro.test&quot;);&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolHttps.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolHttps.java&lt;br/&gt;
index 67182e144..a92021a1e 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolHttps.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolHttps.java&lt;br/&gt;
@@ -29,6 +29,9 @@&lt;br/&gt;
 &lt;br/&gt;
 import java.net.URL;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol https.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolHttps extends TestProtocolSpecific {&lt;br/&gt;
 &lt;br/&gt;
   @Override&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolParsing.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolParsing.java&lt;br/&gt;
index 240c956de..651abbcd2 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolParsing.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolParsing.java&lt;br/&gt;
@@ -28,12 +28,26 @@&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.avro.Protocol.Message;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol parsing.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolParsing {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Gets simple protocol.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the simple protocol&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static Protocol getSimpleProtocol() throws IOException {
     File file = new File(&quot;../../../share/test/schemas/simple.avpr&quot;);
     return Protocol.parse(file);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test parsing.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testParsing() throws IOException {&lt;br/&gt;
     Protocol protocol = getSimpleProtocol();&lt;br/&gt;
@@ -51,6 +65,11 @@ private static Message parseMessage(String message) throws Exception {&lt;br/&gt;
                           + &quot;}}&quot;).getMessages().values().iterator().next();&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * One way.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void oneWay() throws Exception {&lt;br/&gt;
     Message m;&lt;br/&gt;
@@ -67,6 +86,11 @@ public void oneWay() throws Exception {
     assertTrue(m.isOneWay());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * One way response.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=SchemaParseException.class)&lt;br/&gt;
   public void oneWayResponse() throws Exception {&lt;br/&gt;
     // prohibit one-way messages with a non-null response type&lt;br/&gt;
@@ -76,6 +100,11 @@ public void oneWayResponse() throws Exception {
                  +&quot;\&quot;one-way\&quot;: true}&quot;);&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * One way error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=SchemaParseException.class)&lt;br/&gt;
   public void oneWayError() throws Exception {&lt;br/&gt;
     // prohibit one-way messages with errors&lt;br/&gt;
@@ -85,6 +114,11 @@ public void oneWayError() throws Exception {
                  +&quot;\&quot;one-way\&quot;: true}&quot;);&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test message field aliases.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMessageFieldAliases() throws IOException{&lt;br/&gt;
     Protocol protocol = getSimpleProtocol();&lt;br/&gt;
@@ -95,6 +129,11 @@ public void testMessageFieldAliases() throws IOException{
     assertTrue(field.aliases().contains(&quot;salute&quot;));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test message custom properties.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMessageCustomProperties() throws IOException{&lt;br/&gt;
     Protocol protocol = getSimpleProtocol();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolReflect.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolReflect.java&lt;br/&gt;
index 29ab535d2..7e0feca5d 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolReflect.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolReflect.java&lt;br/&gt;
@@ -37,8 +37,14 @@&lt;br/&gt;
 import java.util.Random;&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol reflect.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolReflect {&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Test record.&lt;br/&gt;
+   */&lt;br/&gt;
   public static class TestRecord {&lt;br/&gt;
     private String name;&lt;br/&gt;
     public int hashCode() { return this.name.hashCode(); }&lt;br/&gt;
@@ -47,16 +53,56 @@ public boolean equals(Object that) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The interface Simple.&lt;br/&gt;
+   */&lt;br/&gt;
   public interface Simple {
+    /**
+     * Hello string.
+     *
+     * @param greeting the greeting
+     * @return the string
+     */
     String hello(String greeting);
+
+    /**
+     * Echo test record.
+     *
+     * @param record the record
+     * @return the test record
+     */
     TestRecord echo(TestRecord record);
+
+    /**
+     * Add int.
+     *
+     * @param arg1 the arg 1
+     * @param arg2 the arg 2
+     * @return the int
+     */
     int add(int arg1, int arg2);
+
+    /**
+     * Echo bytes byte [ ].
+     *
+     * @param data the data
+     * @return the byte [ ]
+     */
     byte[] echoBytes(byte[] data);
+
+    /**
+     * Error.
+     *
+     * @throws SimpleException the simple exception
+     */
     void error() throws SimpleException;
   }&lt;br/&gt;
 &lt;br/&gt;
   private static boolean throwUndeclaredError;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Test.&lt;br/&gt;
+   */&lt;br/&gt;
   public static class TestImpl implements Simple {&lt;br/&gt;
     public String hello(String greeting) { return &quot;goodbye&quot;; }&lt;br/&gt;
     public int add(int arg1, int arg2) { return arg1 + arg2; }&lt;br/&gt;
@@ -68,10 +114,24 @@ public void error() throws SimpleException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant server.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Server server;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant client.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Transceiver client;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant proxy.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Simple proxy;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test start server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void testStartServer() throws Exception {&lt;br/&gt;
     if (server != null) return;&lt;br/&gt;
@@ -82,6 +142,11 @@ public void testStartServer() throws Exception {
     proxy = ReflectRequestor.getClient(Simple.class, client);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test class loader.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testClassLoader() throws Exception {&lt;br/&gt;
     ClassLoader loader = new ClassLoader() {};&lt;br/&gt;
 &lt;br/&gt;
@@ -95,12 +160,22 @@ public void testStartServer() throws Exception {
     assertEquals(requestor.getReflectData().getClassLoader(), loader);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test hello.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testHello() throws IOException {
     String response = proxy.hello(&quot;bob&quot;);
     assertEquals(&quot;goodbye&quot;, response);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test echo.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEcho() throws IOException {&lt;br/&gt;
     TestRecord record = new TestRecord();&lt;br/&gt;
@@ -109,12 +184,22 @@ public void testEcho() throws IOException {     assertEquals(record, echoed);   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test add.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testAdd() throws IOException {
     int result = proxy.add(1, 2);
     assertEquals(3, result);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test echo bytes.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEchoBytes() throws IOException {&lt;br/&gt;
     Random random = new Random();&lt;br/&gt;
@@ -125,6 +210,11 @@ public void testEchoBytes() throws IOException {
     assertArrayEquals(data, echoed);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testError() throws IOException {&lt;br/&gt;
     SimpleException error = null;&lt;br/&gt;
@@ -137,6 +227,11 @@ public void testError() throws IOException {
     assertEquals(&quot;foo&quot;, error.getMessage());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test undeclared error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testUndeclaredError() throws Exception {&lt;br/&gt;
     this.throwUndeclaredError = true;&lt;br/&gt;
@@ -152,6 +247,11 @@ public void testUndeclaredError() throws Exception {
     assertTrue(error.toString().contains(&quot;foo&quot;));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test stop server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void testStopServer() throws IOException {&lt;br/&gt;
     client.close();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolReflectMeta.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolReflectMeta.java&lt;br/&gt;
index dfd34b4c4..8d9b5e80d 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolReflectMeta.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolReflectMeta.java&lt;br/&gt;
@@ -25,6 +25,9 @@&lt;br/&gt;
 &lt;br/&gt;
 import java.net.InetSocketAddress;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol reflect meta.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolReflectMeta extends TestProtocolReflect {&lt;br/&gt;
 &lt;br/&gt;
   @Before @Override&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolSpecific.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolSpecific.java&lt;br/&gt;
index 77340fc3b..5a098e28f 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolSpecific.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolSpecific.java&lt;br/&gt;
@@ -57,16 +57,31 @@&lt;br/&gt;
 import java.util.HashSet;&lt;br/&gt;
 &lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test protocol specific.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolSpecific {&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant REPEATING.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static final int REPEATING = -1;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant SERVER_PORTS_DIR.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static final File SERVER_PORTS_DIR&lt;br/&gt;
   = new File(System.getProperty(&quot;test.dir&quot;, &quot;/tmp&quot;)+&quot;/server-ports/&quot;);&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant ackCount.&lt;br/&gt;
+   */&lt;br/&gt;
   public static int ackCount;&lt;br/&gt;
 &lt;br/&gt;
   private static boolean throwUndeclaredError;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Test.&lt;br/&gt;
+   */&lt;br/&gt;
   public static class TestImpl implements Simple {&lt;br/&gt;
     public String hello(String greeting) { return &quot;goodbye&quot;; }&lt;br/&gt;
     public int add(int arg1, int arg2) { return arg1 + arg2; }&lt;br/&gt;
@@ -79,14 +94,34 @@ public Void error() throws AvroRemoteException {&lt;br/&gt;
     public void ack() { ackCount++; }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant server.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Server server;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant client.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Transceiver client;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant proxy.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Simple proxy;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant responder.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static SpecificResponder responder;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant monitor.&lt;br/&gt;
+   */&lt;br/&gt;
   protected static HandshakeMonitor monitor;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test start server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void testStartServer() throws Exception {&lt;br/&gt;
     if (server != null) return;&lt;br/&gt;
@@ -103,17 +138,40 @@ public void testStartServer() throws Exception {
     responder.addRPCPlugin(monitor);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Add rpc plugins.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param requestor the requestor&lt;br/&gt;
+   */&lt;br/&gt;
   public void addRpcPlugins(Requestor requestor){}&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create server server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param testResponder the test responder&lt;br/&gt;
+   * @return the server&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public Server createServer(Responder testResponder) throws Exception{
     return server = new SocketServer(testResponder,
                               new InetSocketAddress(0));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Create transceiver transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the transceiver&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public Transceiver createTransceiver() throws Exception{
     return new SocketTransceiver(new InetSocketAddress(server.getPort()));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test class loader.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testClassLoader() throws Exception {&lt;br/&gt;
     ClassLoader loader = new ClassLoader() {};&lt;br/&gt;
 &lt;br/&gt;
@@ -127,22 +185,42 @@ public Transceiver createTransceiver() throws Exception{
     assertEquals(requestor.getSpecificData().getClassLoader(), loader);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test get remote.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testGetRemote() throws IOException {
     assertEquals(Simple.PROTOCOL, SpecificRequestor.getRemote(proxy));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test hello.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testHello() throws IOException {
     String response = proxy.hello(&quot;bob&quot;);
     assertEquals(&quot;goodbye&quot;, response);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test hash code.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testHashCode() throws IOException {
     TestError error = new TestError();
     error.hashCode();
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test echo.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEcho() throws IOException {&lt;br/&gt;
     TestRecord record = new TestRecord();&lt;br/&gt;
@@ -154,12 +232,22 @@ public void testEcho() throws IOException {     assertEquals(record.hashCode(), echoed.hashCode());   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test add.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testAdd() throws IOException &lt;/p&gt;
{
     int result = proxy.add(1, 2);
     assertEquals(3, result);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test echo bytes.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEchoBytes() throws IOException {&lt;br/&gt;
     Random random = new Random();&lt;br/&gt;
@@ -171,6 +259,11 @@ public void testEchoBytes() throws IOException &lt;/p&gt;
{
     assertEquals(data, echoed);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test empty echo bytes.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEmptyEchoBytes() throws IOException {&lt;br/&gt;
     ByteBuffer data = ByteBuffer.allocate(0);&lt;br/&gt;
@@ -179,6 +272,11 @@ public void testEmptyEchoBytes() throws IOException {     assertEquals(data, echoed);   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testError() throws IOException {&lt;br/&gt;
     TestError error = null;&lt;br/&gt;
@@ -191,6 +289,11 @@ public void testError() throws IOException &lt;/p&gt;
{
     assertEquals(&quot;an error&quot;, error.getMessage$());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test undeclared error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testUndeclaredError() throws Exception {&lt;br/&gt;
     this.throwUndeclaredError = true;&lt;br/&gt;
@@ -207,6 +310,11 @@ public void testUndeclaredError() throws Exception {&lt;br/&gt;
   }&lt;/p&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Test one way.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testOneWay() throws IOException {&lt;br/&gt;
     ackCount = 0;&lt;br/&gt;
@@ -217,6 +325,11 @@ public void testOneWay() throws IOException &lt;/p&gt;
{
     assertEquals(2, ackCount);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test repeated access.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRepeatedAccess() throws Exception {&lt;br/&gt;
     for (int x = 0; x &amp;lt; 1000; x++) {&lt;br/&gt;
@@ -224,6 +337,11 @@ public void testRepeatedAccess() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test connection refused one way.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected = Exception.class)&lt;br/&gt;
   public void testConnectionRefusedOneWay() throws IOException {&lt;br/&gt;
     Transceiver client = new HttpTransceiver(new URL(&quot;http://localhost:4444&quot;));&lt;br/&gt;
@@ -233,6 +351,11 @@ public void testConnectionRefusedOneWay() throws IOException &lt;/p&gt;
{
     proxy.ack();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test param variation.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   /** Construct and use a protocol whose &quot;hello&quot; method has an extra&lt;br/&gt;
       argument to check that schema is sent to parse request. */&lt;br/&gt;
@@ -264,11 +387,21 @@ public void testParamVariation() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test handshake count.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void testHandshakeCount() throws IOException &lt;/p&gt;
{
     monitor.assertHandshake();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test stop server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void testStopServer() throws IOException {&lt;br/&gt;
     client.close();&lt;br/&gt;
@@ -276,6 +409,9 @@ public static void testStopServer() throws IOException &lt;/p&gt;
{
     server = null;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Handshake monitor.&lt;br/&gt;
+   */&lt;br/&gt;
   public class HandshakeMonitor extends RPCPlugin{&lt;/p&gt;

&lt;p&gt;     private int handshakes;&lt;br/&gt;
@@ -298,6 +434,9 @@ public void serverConnecting(RPCContext context) {&lt;br/&gt;
       }&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Assert handshake.&lt;br/&gt;
+     */&lt;br/&gt;
     public void assertHandshake(){&lt;br/&gt;
       int expected = getExpectedHandshakeCount();&lt;br/&gt;
       if(expected != REPEATING){&lt;br/&gt;
@@ -306,13 +445,26 @@ public void assertHandshake(){&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets expected handshake count.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the expected handshake count&lt;br/&gt;
+   */&lt;br/&gt;
   protected int getExpectedHandshakeCount() &lt;/p&gt;
{
    return 3;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Interop test.&lt;br/&gt;
+   */&lt;br/&gt;
   public static class InteropTest {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Test client.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws Exception the exception&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
     public void testClient() throws Exception {&lt;br/&gt;
       for (File f : SERVER_PORTS_DIR.listFiles()) {&lt;br/&gt;
         LineNumberReader reader = new LineNumberReader(new FileReader(f));&lt;br/&gt;
@@ -334,6 +486,9 @@ public void testClient() throws Exception {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Starts the RPC server.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param args the input arguments&lt;br/&gt;
+     * @throws Exception the exception&lt;br/&gt;
      */&lt;br/&gt;
     public static void main(String[] args) throws Exception {&lt;br/&gt;
       SocketServer server = new SocketServer(&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolSpecificMeta.java b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolSpecificMeta.java&lt;br/&gt;
index c051b6ec1..0194c5efe 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolSpecificMeta.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestProtocolSpecificMeta.java&lt;br/&gt;
@@ -27,6 +27,9 @@&lt;br/&gt;
 import org.apache.avro.ipc.Transceiver;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test protocol specific meta.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestProtocolSpecificMeta extends TestProtocolSpecific {&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/TestSchema.java b/lang/java/ipc/src/test/java/org/apache/avro/TestSchema.java&lt;br/&gt;
index 31d194323..092efb1ca 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/TestSchema.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/TestSchema.java&lt;br/&gt;
@@ -51,17 +51,29 @@&lt;br/&gt;
 import org.apache.avro.util.Utf8;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test schema.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSchema {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The constant LISP_SCHEMA.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final String LISP_SCHEMA = &quot;{\&quot;type\&quot;: \&quot;record\&quot;, \&quot;name\&quot;: \&quot;Lisp\&quot;, \&quot;fields\&quot;: [&quot;&lt;br/&gt;
             +&quot;{\&quot;name\&quot;:\&quot;value\&quot;, \&quot;type\&quot;:[\&quot;null\&quot;, \&quot;string\&quot;,&quot;&lt;br/&gt;
             +&quot;{\&quot;type\&quot;: \&quot;record\&quot;, \&quot;name\&quot;: \&quot;Cons\&quot;, \&quot;fields\&quot;: [&quot;&lt;br/&gt;
             +&quot;&lt;/p&gt;
{\&quot;name\&quot;:\&quot;car\&quot;, \&quot;type\&quot;:\&quot;Lisp\&quot;}
&lt;p&gt;,&quot;&lt;br/&gt;
             +&quot;&lt;/p&gt;
{\&quot;name\&quot;:\&quot;cdr\&quot;, \&quot;type\&quot;:\&quot;Lisp\&quot;}
&lt;p&gt;]}]}]}&quot;;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The constant BASIC_ENUM_SCHEMA.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final String BASIC_ENUM_SCHEMA = &quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;enum\&quot;, \&quot;name\&quot;:\&quot;Test\&quot;,&quot;
             +&quot;\&quot;symbols\&quot;: [\&quot;A\&quot;, \&quot;B\&quot;]}
&lt;p&gt;&quot;;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The constant SCHEMA_WITH_DOC_TAGS.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final String SCHEMA_WITH_DOC_TAGS = &quot;{\n&quot;&lt;br/&gt;
       + &quot;  \&quot;type\&quot;: \&quot;record\&quot;,\n&quot;&lt;br/&gt;
       + &quot;  \&quot;name\&quot;: \&quot;outer_record\&quot;,\n&quot;&lt;br/&gt;
@@ -83,6 +95,11 @@&lt;br/&gt;
   private static final int COUNT =&lt;br/&gt;
     Integer.parseInt(System.getProperty(&quot;test.count&quot;, &quot;30&quot;));&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test null.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNull() throws Exception {&lt;br/&gt;
     assertEquals(Schema.create(Type.NULL), Schema.parse(&quot;\&quot;null\&quot;&quot;));&lt;br/&gt;
@@ -90,6 +107,11 @@ public void testNull() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;null\&quot;&quot;, &quot;null&quot;, null);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test boolean.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBoolean() throws Exception {&lt;br/&gt;
     assertEquals(Schema.create(Type.BOOLEAN), Schema.parse(&quot;\&quot;boolean\&quot;&quot;));&lt;br/&gt;
@@ -98,6 +120,11 @@ public void testBoolean() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;boolean\&quot;&quot;, &quot;true&quot;, Boolean.TRUE);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test string.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testString() throws Exception {&lt;br/&gt;
     assertEquals(Schema.create(Type.STRING), Schema.parse(&quot;\&quot;string\&quot;&quot;));&lt;br/&gt;
@@ -106,6 +133,11 @@ public void testString() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;string\&quot;&quot;, &quot;\&quot;foo\&quot;&quot;, new Utf8(&quot;foo&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test bytes.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBytes() throws Exception {&lt;br/&gt;
     assertEquals(Schema.create(Type.BYTES), Schema.parse(&quot;\&quot;bytes\&quot;&quot;));&lt;br/&gt;
@@ -115,6 +147,11 @@ public void testBytes() throws Exception {&lt;br/&gt;
           ByteBuffer.wrap(new byte[]&lt;/p&gt;
{0,65,66,67,-1}
&lt;p&gt;));&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test int.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testInt() throws Exception {&lt;br/&gt;
     assertEquals(Schema.create(Type.INT), Schema.parse(&quot;\&quot;int\&quot;&quot;));&lt;br/&gt;
@@ -122,6 +159,11 @@ public void testInt() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;int\&quot;&quot;, &quot;9&quot;, new Integer(9));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test long.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testLong() throws Exception {&lt;br/&gt;
     assertEquals(Schema.create(Type.LONG), Schema.parse(&quot;\&quot;long\&quot;&quot;));&lt;br/&gt;
@@ -129,6 +171,11 @@ public void testLong() throws Exception &lt;/p&gt;
{
     check(&quot;\&quot;long\&quot;&quot;, &quot;11&quot;, new Long(11));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test float.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFloat() throws Exception {&lt;br/&gt;
     assertEquals(Schema.create(Type.FLOAT), Schema.parse(&quot;\&quot;float\&quot;&quot;));&lt;br/&gt;
@@ -140,6 +187,11 @@ public void testFloat() throws Exception &lt;/p&gt;
{
     checkDefault(&quot;\&quot;float\&quot;&quot;, &quot;\&quot;-Infinity\&quot;&quot;, Float.NEGATIVE_INFINITY);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test double.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testDouble() throws Exception {&lt;br/&gt;
     assertEquals(Schema.create(Type.DOUBLE), Schema.parse(&quot;\&quot;double\&quot;&quot;));&lt;br/&gt;
@@ -151,6 +203,11 @@ public void testDouble() throws Exception &lt;/p&gt;
{
     checkDefault(&quot;\&quot;double\&quot;&quot;, &quot;\&quot;-Infinity\&quot;&quot;, Double.NEGATIVE_INFINITY);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test array.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testArray() throws Exception {&lt;br/&gt;
     String json = &quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;array\&quot;, \&quot;items\&quot;: \&quot;long\&quot;}
&lt;p&gt;&quot;;&lt;br/&gt;
@@ -164,6 +221,11 @@ public void testArray() throws Exception {&lt;br/&gt;
     checkParseError(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;array\&quot;}
&lt;p&gt;&quot;);      // items required&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test map.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMap() throws Exception {&lt;br/&gt;
     HashMap&amp;lt;Utf8,Long&amp;gt; map = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -172,6 +234,11 @@ public void testMap() throws Exception {&lt;br/&gt;
     checkParseError(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;map\&quot;}
&lt;p&gt;&quot;);        // values required&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test union map.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testUnionMap() throws Exception {&lt;br/&gt;
     String unionMapSchema = &quot;{\&quot;name\&quot;:\&quot;foo\&quot;, \&quot;type\&quot;:\&quot;record\&quot;,&quot; +&lt;br/&gt;
@@ -184,6 +251,11 @@ public void testUnionMap() throws Exception &lt;/p&gt;
{
     check(unionMapSchema, true);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRecord() throws Exception {&lt;br/&gt;
     String recordJson = &quot;{\&quot;type\&quot;:\&quot;record\&quot;, \&quot;name\&quot;:\&quot;Test\&quot;, \&quot;fields\&quot;:&quot;&lt;br/&gt;
@@ -220,12 +292,20 @@ public void testRecord() throws Exception {&lt;br/&gt;
                     +&quot;&lt;/p&gt;
{\&quot;name\&quot;:\&quot;f.g\&quot;,\&quot;type\&quot;:\&quot;int\&quot;}
&lt;p&gt;]}&quot;);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test invalid name tolerance.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testInvalidNameTolerance() {&lt;br/&gt;
     Schema.parse(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;record\&quot;,\&quot;name\&quot;:\&quot;1X\&quot;,\&quot;fields\&quot;:[]}
&lt;p&gt;&quot;, false);&lt;br/&gt;
     Schema.parse(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;record\&quot;,\&quot;name\&quot;:\&quot;X-\&quot;,\&quot;fields\&quot;:[]}
&lt;p&gt;&quot;, false);&lt;br/&gt;
     Schema.parse(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;record\&quot;,\&quot;name\&quot;:\&quot;X$\&quot;,\&quot;fields\&quot;:[]}
&lt;p&gt;&quot;, false);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test map in record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMapInRecord() throws Exception {&lt;br/&gt;
     String json = &quot;{\&quot;type\&quot;:\&quot;record\&quot;, \&quot;name\&quot;:\&quot;Test\&quot;, \&quot;fields\&quot;:&quot;&lt;br/&gt;
@@ -240,6 +320,11 @@ public void testMapInRecord() throws Exception {&lt;br/&gt;
   }&lt;/p&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Test enum.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEnum() throws Exception {&lt;br/&gt;
     check(BASIC_ENUM_SCHEMA, &quot;\&quot;B\&quot;&quot;,&lt;br/&gt;
@@ -255,6 +340,11 @@ public void testEnum() throws Exception {&lt;br/&gt;
     checkParseError(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;enum\&quot;,\&quot;name\&quot;:\&quot;X\&quot;,\&quot;symbols\&quot;:[\&quot;X.Y\&quot;]}
&lt;p&gt;&quot;);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test fixed.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFixed() throws Exception {&lt;br/&gt;
     String json = &quot;&lt;/p&gt;
{\&quot;type\&quot;: \&quot;fixed\&quot;, \&quot;name\&quot;:\&quot;Test\&quot;, \&quot;size\&quot;: 1}
&lt;p&gt;&quot;;&lt;br/&gt;
@@ -264,6 +354,11 @@ public void testFixed() throws Exception {&lt;br/&gt;
     checkParseError(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;fixed\&quot;}
&lt;p&gt;&quot;);        // size required&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test recursive.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRecursive() throws Exception {&lt;br/&gt;
     check(&quot;{\&quot;type\&quot;: \&quot;record\&quot;, \&quot;name\&quot;: \&quot;Node\&quot;, \&quot;fields\&quot;: [&quot;&lt;br/&gt;
@@ -273,6 +368,11 @@ public void testRecursive() throws Exception &lt;/p&gt;
{
           false);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test recursive equals.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRecursiveEquals() throws Exception {&lt;br/&gt;
     String jsonSchema = &quot;{\&quot;type\&quot;:\&quot;record\&quot;, \&quot;name\&quot;:\&quot;List\&quot;, \&quot;fields\&quot;: [&quot;&lt;br/&gt;
@@ -283,6 +383,11 @@ public void testRecursiveEquals() throws Exception &lt;/p&gt;
{
     s1.hashCode();                                // test no stackoverflow
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test schema explosion.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   /** Test that equals() and hashCode() don&apos;t require exponential time on&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;certain pathological schemas. */&lt;br/&gt;
@@ -310,11 +415,21 @@ public void testSchemaExplosion() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Test lisp.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testLisp() throws Exception &lt;/p&gt;
{
     check(LISP_SCHEMA, false);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test union.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testUnion() throws Exception {&lt;br/&gt;
     check(&quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;\&amp;quot;string\&amp;quot;, \&amp;quot;long\&amp;quot;&amp;#93;&lt;/span&gt;&quot;, false);&lt;br/&gt;
@@ -360,6 +475,11 @@ public void testUnion() throws Exception {&lt;br/&gt;
               &quot;&lt;/p&gt;
{\&quot;Baz\&quot;:\&quot;X\&quot;}
&lt;p&gt;&quot;);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test complex unions.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testComplexUnions() throws Exception {&lt;br/&gt;
     // one of each unnamed type and two of named types&lt;br/&gt;
@@ -426,6 +546,11 @@ public void testComplexUnions() throws Exception {&lt;br/&gt;
     checkUnionError(new Schema[] &lt;/p&gt;
{union}
&lt;p&gt;);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test complex prop.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testComplexProp() throws Exception {&lt;br/&gt;
     String json = &quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;null\&quot;, \&quot;foo\&quot;: [0]}
&lt;p&gt;&quot;;&lt;br/&gt;
@@ -433,12 +558,22 @@ public void testComplexProp() throws Exception &lt;/p&gt;
{
     assertEquals(null, s.getProp(&quot;foo&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test prop ordering.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testPropOrdering() throws Exception {&lt;br/&gt;
     String json = &quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;int\&quot;,\&quot;z\&quot;:\&quot;c\&quot;,\&quot;yy\&quot;:\&quot;b\&quot;,\&quot;x\&quot;:\&quot;a\&quot;}
&lt;p&gt;&quot;;&lt;br/&gt;
     Schema s = Schema.parse(json);&lt;br/&gt;
     assertEquals(json, s.toString());&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test parse input stream.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testParseInputStream() throws IOException {&lt;br/&gt;
     Schema s = Schema.parse(&lt;br/&gt;
@@ -446,6 +581,11 @@ public void testParseInputStream() throws IOException &lt;/p&gt;
{
     assertEquals(Schema.parse(&quot;\&quot;boolean\&quot;&quot;), s);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test namespace scope.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNamespaceScope() throws Exception {&lt;br/&gt;
     String z = &quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;record\&quot;,\&quot;name\&quot;:\&quot;Z\&quot;,\&quot;fields\&quot;:[]}
&lt;p&gt;&quot;;&lt;br/&gt;
@@ -461,6 +601,11 @@ public void testNamespaceScope() throws Exception &lt;/p&gt;
{
     assertEquals(&quot;q.Z&quot;, ys.getField(&quot;f&quot;).schema().getFullName());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test namespace nesting.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNamespaceNesting() throws Exception {&lt;br/&gt;
     String y = &quot;{\&quot;type\&quot;:\&quot;record\&quot;,\&quot;name\&quot;:\&quot;y.Y\&quot;,\&quot;fields\&quot;:[&quot;&lt;br/&gt;
@@ -472,6 +617,11 @@ public void testNamespaceNesting() throws Exception &lt;/p&gt;
{
     assertEquals(xs, Schema.parse(xs.toString()));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test nested null namespace.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNestedNullNamespace() throws Exception {&lt;br/&gt;
     Schema inner =&lt;br/&gt;
@@ -481,6 +631,9 @@ public void testNestedNullNamespace() throws Exception &lt;/p&gt;
{
     assertEquals(outer, Schema.parse(outer.toString()));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test nested null namespace referencing.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNestedNullNamespaceReferencing() {&lt;br/&gt;
     Schema inner =&lt;br/&gt;
@@ -491,6 +644,9 @@ public void testNestedNullNamespaceReferencing() {     assertEquals(outer, Schema.parse(outer.toString()));   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test nested null namespace referencing with union.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNestedNullNamespaceReferencingWithUnion() {&lt;br/&gt;
     Schema inner =&lt;br/&gt;
@@ -502,6 +658,11 @@ public void testNestedNullNamespaceReferencingWithUnion() &lt;/p&gt;
{
     assertEquals(outer, Schema.parse(outer.toString()));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test nested non null namespace 1.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNestedNonNullNamespace1() throws Exception {&lt;br/&gt;
     Schema inner1 = Schema.createEnum(&quot;InnerEnum&quot;, null, &quot;space&quot;, Arrays.asList(&quot;x&quot;));&lt;br/&gt;
@@ -513,6 +674,11 @@ public void testNestedNonNullNamespace1() throws Exception &lt;/p&gt;
{
     assertEquals(nullOuter, Schema.parse(nullOuter.toString()));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test nested non null namespace 2.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNestedNonNullNamespace2() throws Exception {&lt;br/&gt;
     Schema inner1 = Schema.createFixed(&quot;InnerFixed&quot;, null, &quot;space&quot;, 1);&lt;br/&gt;
@@ -524,6 +690,11 @@ public void testNestedNonNullNamespace2() throws Exception {     assertEquals(nullOuter, Schema.parse(nullOuter.toString()));   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test null namespace alias.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNullNamespaceAlias() throws Exception {&lt;br/&gt;
     Schema s =&lt;br/&gt;
@@ -535,6 +706,11 @@ public void testNullNamespaceAlias() throws Exception &lt;/p&gt;
{
     assertEquals(&quot;x.Y&quot;, u.getFullName());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test null pointer.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNullPointer() throws Exception {&lt;br/&gt;
     String recordJson = &quot;{\&quot;type\&quot;:\&quot;record\&quot;, \&quot;name\&quot;:\&quot;Test\&quot;, \&quot;fields\&quot;:&quot;&lt;br/&gt;
@@ -591,6 +767,9 @@ public void testDocs() &lt;/p&gt;
{
     assertEquals(&quot;Inner Union&quot;, schema.getField(&quot;inner_union&quot;).doc());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test field docs.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFieldDocs() {&lt;br/&gt;
     String schemaStr = &quot;{\&quot;name\&quot;: \&quot;Rec\&quot;,\&quot;type\&quot;: \&quot;record\&quot;,\&quot;fields\&quot; : [&quot;+&lt;br/&gt;
@@ -605,6 +784,11 @@ public void testFieldDocs() &lt;/p&gt;
{
     assertEquals(&quot;test&quot;, schema.getField(&quot;f&quot;).doc());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test aliases.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testAliases() throws Exception {&lt;br/&gt;
     String t1 = &quot;{\&quot;type\&quot;:\&quot;record\&quot;,\&quot;name\&quot;:\&quot;a.b\&quot;,\&quot;fields\&quot;:[&quot;&lt;br/&gt;
@@ -709,6 +893,15 @@ private static void checkProp(Schema s0) throws Exception &lt;/p&gt;
{
     assertFalse(s0.equals(s2));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Check binary.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param datum  the datum&lt;br/&gt;
+   * @param writer the writer&lt;br/&gt;
+   * @param reader the reader&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void checkBinary(Schema schema, Object datum,&lt;br/&gt;
                                  DatumWriter&amp;lt;Object&amp;gt; writer,&lt;br/&gt;
                                  DatumReader&amp;lt;Object&amp;gt; reader)&lt;br/&gt;
@@ -716,6 +909,17 @@ public static void checkBinary(Schema schema, Object datum,&lt;br/&gt;
     checkBinary(schema, datum, writer, reader, null);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Check binary object.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param datum  the datum&lt;br/&gt;
+   * @param writer the writer&lt;br/&gt;
+   * @param reader the reader&lt;br/&gt;
+   * @param reuse  the reuse&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static Object checkBinary(Schema schema, Object datum,&lt;br/&gt;
                                  DatumWriter&amp;lt;Object&amp;gt; writer,&lt;br/&gt;
                                  DatumReader&amp;lt;Object&amp;gt; reader,&lt;br/&gt;
@@ -738,6 +942,15 @@ public static Object checkBinary(Schema schema, Object datum,&lt;br/&gt;
     return decoded;&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Check direct binary.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param datum  the datum&lt;br/&gt;
+   * @param writer the writer&lt;br/&gt;
+   * @param reader the reader&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void checkDirectBinary(Schema schema, Object datum,&lt;br/&gt;
       DatumWriter&amp;lt;Object&amp;gt; writer, DatumReader&amp;lt;Object&amp;gt; reader)&lt;br/&gt;
       throws IOException &lt;/p&gt;
{
@@ -756,6 +969,15 @@ public static void checkDirectBinary(Schema schema, Object datum,
     assertEquals(&quot;Decoded data does not match.&quot;, datum, decoded);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Check blocking binary.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param datum  the datum&lt;br/&gt;
+   * @param writer the writer&lt;br/&gt;
+   * @param reader the reader&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void checkBlockingBinary(Schema schema, Object datum,&lt;br/&gt;
       DatumWriter&amp;lt;Object&amp;gt; writer, DatumReader&amp;lt;Object&amp;gt; reader)&lt;br/&gt;
       throws IOException &lt;/p&gt;
{
@@ -817,6 +1039,12 @@ private static void checkJson(Schema schema, Object datum,
     assertEquals(&quot;Decoded data does not match.&quot;, datum, decoded);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Check binary json.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param json the json&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void checkBinaryJson(String json) throws Exception &lt;/p&gt;
{
     Object node = Json.parseJson(json);
     ByteArrayOutputStream out = new ByteArrayOutputStream();
@@ -867,6 +1095,11 @@ private static void checkValidateDefaults(String schemaJson, String defaultJson)
     }
&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test no default field.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=AvroTypeException.class)&lt;br/&gt;
   public void testNoDefaultField() throws Exception {&lt;br/&gt;
     Schema expected =&lt;br/&gt;
@@ -877,6 +1110,11 @@ public void testNoDefaultField() throws Exception &lt;/p&gt;
{
         new ByteArrayInputStream(new byte[0]), null));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test enum mismatch.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEnumMismatch() throws Exception {&lt;br/&gt;
     Schema actual = Schema.parse&lt;br/&gt;
@@ -903,11 +1141,17 @@ public void testEnumMismatch() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test record with primitive name.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=AvroTypeException.class)&lt;br/&gt;
   public void testRecordWithPrimitiveName() {&lt;br/&gt;
     Schema.parse(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;record\&quot;, \&quot;name\&quot;:\&quot;string\&quot;, \&quot;fields\&quot;: []}
&lt;p&gt;&quot;);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test enum with primitive name.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=AvroTypeException.class)&lt;br/&gt;
   public void testEnumWithPrimitiveName() {&lt;br/&gt;
     Schema.parse(&quot;&lt;/p&gt;
{\&quot;type\&quot;:\&quot;enum\&quot;, \&quot;name\&quot;:\&quot;null\&quot;, \&quot;symbols\&quot;: [\&quot;A\&quot;]}
&lt;p&gt;&quot;);&lt;br/&gt;
@@ -918,6 +1162,9 @@ private static Schema enumSchema() &lt;/p&gt;
{
         + &quot;\&quot;symbols\&quot;: [\&quot;a\&quot;, \&quot;b\&quot;]}
&lt;p&gt;&quot;);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test immutability 1.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=AvroRuntimeException.class)&lt;br/&gt;
   public void testImmutability1() {&lt;br/&gt;
     Schema s = enumSchema();&lt;br/&gt;
@@ -925,6 +1172,9 @@ public void testImmutability1() &lt;/p&gt;
{
     s.addProp(&quot;p1&quot;, &quot;2&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test immutability 2.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=AvroRuntimeException.class)&lt;br/&gt;
   public void testImmutability2() {&lt;br/&gt;
     Schema s = enumSchema();&lt;br/&gt;
@@ -936,50 +1186,77 @@ public void testImmutability2() &lt;/p&gt;
{
         &quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
&lt;p&gt;)).lock();&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test locked array list 1.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList1() &lt;/p&gt;
{
     lockedArrayList().add(&quot;p&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test locked array list 2.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList2() &lt;/p&gt;
{
     lockedArrayList().remove(&quot;a&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test locked array list 3.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList3() {&lt;br/&gt;
     lockedArrayList().addAll(Arrays.asList(new String[] &lt;/p&gt;
{ &quot;p&quot; }));&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test locked array list 4.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList4() {&lt;br/&gt;
     lockedArrayList().addAll(0,&lt;br/&gt;
         Arrays.asList(new String[] { &quot;p&quot; }
&lt;p&gt;));&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test locked array list 5.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList5() {&lt;br/&gt;
     lockedArrayList().&lt;br/&gt;
       removeAll(Arrays.asList(new String[] &lt;/p&gt;
{ &quot;a&quot; }));&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test locked array list 6.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList6() {&lt;br/&gt;
     lockedArrayList().&lt;br/&gt;
       retainAll(Arrays.asList(new String[] { &quot;a&quot; }
&lt;p&gt;));&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test locked array list 7.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList7() &lt;/p&gt;
{
     lockedArrayList().clear();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test locked array list 8.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList8() &lt;/p&gt;
{
     lockedArrayList().iterator().remove();
   }


&lt;p&gt;+  /**&lt;br/&gt;
+   * Test locked array list 9.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList9() {&lt;br/&gt;
     Iterator&amp;lt;String&amp;gt; it = lockedArrayList().iterator();&lt;br/&gt;
@@ -987,11 +1264,17 @@ public void testLockedArrayList9() &lt;/p&gt;
{
     it.remove();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test locked array list 10.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testLockedArrayList10() &lt;/p&gt;
{
     lockedArrayList().remove(1);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test names get with inherited namespace.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNames_GetWithInheritedNamespace() {&lt;br/&gt;
     Schema schema = Schema.create(Type.STRING);&lt;br/&gt;
@@ -1002,6 +1285,9 @@ public void testNames_GetWithInheritedNamespace() &lt;/p&gt;
{
     assertEquals(schema, names.get(&quot;Name&quot;));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test names get with null namespace.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNames_GetWithNullNamespace() {&lt;br/&gt;
     Schema schema = Schema.create(Type.STRING);&lt;br/&gt;
@@ -1012,6 +1298,9 @@ public void testNames_GetWithNullNamespace() {     assertEquals(schema, names.get(&quot;Name&quot;));   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test names get not found.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNames_GetNotFound() {&lt;br/&gt;
     Schema.Names names = new Schema.Names(&quot;space&quot;);&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/compiler/specific/TestSpecificCompiler.java b/lang/java/ipc/src/test/java/org/apache/avro/compiler/specific/TestSpecificCompiler.java&lt;br/&gt;
index cb39b5a75..781b47aaf 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/compiler/specific/TestSpecificCompiler.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/compiler/specific/TestSpecificCompiler.java&lt;br/&gt;
@@ -53,7 +53,13 @@&lt;br/&gt;
 import org.apache.avro.compiler.specific.SpecificCompiler.OutputFile;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test specific compiler.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSpecificCompiler {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Protocol.&lt;br/&gt;
+   */&lt;br/&gt;
   static final String PROTOCOL = &quot;&quot; +&lt;br/&gt;
         &quot;&lt;/p&gt;
{ \&quot;protocol\&quot;: \&quot;default\&quot;,\n&quot; +
         &quot;  \&quot;types\&quot;:\n&quot; +
@@ -72,11 +78,17 @@
         &quot;   }
&lt;p&gt;\n&quot; +&lt;br/&gt;
         &quot;}\n&quot;;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test esc.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEsc() &lt;/p&gt;
{
     assertEquals(&quot;\\\&quot;&quot;, SpecificCompiler.javaEscape(&quot;\&quot;&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test make path.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMakePath() {&lt;br/&gt;
     SpecificCompiler compiler = new SpecificCompiler();&lt;br/&gt;
@@ -84,11 +96,19 @@ public void testMakePath() &lt;/p&gt;
{
     assertEquals(&quot;baz.java&quot;, compiler.makePath(&quot;baz&quot;, &quot;&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test primitive schema generates nothing.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testPrimitiveSchemaGeneratesNothing() &lt;/p&gt;
{
     assertEquals(0, new SpecificCompiler(Schema.parse(&quot;\&quot;double\&quot;&quot;)).compile().size());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test simple enum schema.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSimpleEnumSchema() throws IOException {&lt;br/&gt;
     Collection&amp;lt;OutputFile&amp;gt; outputs = new SpecificCompiler(Schema.parse(TestSchema.BASIC_ENUM_SCHEMA)).compile();&lt;br/&gt;
@@ -99,12 +119,20 @@ public void testSimpleEnumSchema() throws IOException &lt;/p&gt;
{
     assertCompilesWithJavaCompiler(outputs);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test mangle if reserved.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMangleIfReserved() &lt;/p&gt;
{
     assertEquals(&quot;foo&quot;, SpecificCompiler.mangle(&quot;foo&quot;));
     assertEquals(&quot;goto$&quot;, SpecificCompiler.mangle(&quot;goto&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test mangling for protocols.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testManglingForProtocols() throws IOException {&lt;br/&gt;
     String protocolDef = PROTOCOL;&lt;br/&gt;
@@ -135,6 +163,11 @@ public void testManglingForProtocols() throws IOException {&lt;br/&gt;
       &quot;                &lt;/p&gt;
{\&quot;name\&quot;: \&quot;short\&quot;, \&quot;type\&quot;: \&quot;volatile\&quot; }
&lt;p&gt; ] }&quot;;&lt;/p&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Test mangling for records.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testManglingForRecords() throws IOException {&lt;br/&gt;
     Collection&amp;lt;OutputFile&amp;gt; c =&lt;br/&gt;
@@ -149,6 +182,11 @@ public void testManglingForRecords() throws IOException &lt;/p&gt;
{
     assertCompilesWithJavaCompiler(c);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test mangling for enums.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testManglingForEnums() throws IOException {&lt;br/&gt;
     String enumSchema = &quot;&quot; +&lt;br/&gt;
@@ -164,6 +202,11 @@ public void testManglingForEnums() throws IOException {     assertCompilesWithJavaCompiler(c);   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test schema split.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSchemaSplit() throws IOException {&lt;br/&gt;
     SpecificCompiler compiler = new SpecificCompiler(Schema.parse(SCHEMA));&lt;br/&gt;
@@ -172,6 +215,11 @@ public void testSchemaSplit() throws IOException &lt;/p&gt;
{
     assertCompilesWithJavaCompiler(files);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test protocol split.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testProtocolSplit() throws IOException {&lt;br/&gt;
     SpecificCompiler compiler = new SpecificCompiler(Protocol.parse(PROTOCOL));&lt;br/&gt;
@@ -180,6 +228,9 @@ public void testProtocolSplit() throws IOException {     assertCompilesWithJavaCompiler(files);   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test schema with docs.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSchemaWithDocs() {&lt;br/&gt;
     Collection&amp;lt;OutputFile&amp;gt; outputs = new SpecificCompiler(&lt;br/&gt;
@@ -208,6 +259,11 @@ public void testSchemaWithDocs() &lt;/p&gt;
{
     assertEquals(3, count);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test protocol with docs.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testProtocolWithDocs() throws IOException {&lt;br/&gt;
     Protocol protocol = TestProtocolParsing.getSimpleProtocol();&lt;br/&gt;
@@ -224,6 +280,12 @@ public void testProtocolWithDocs() throws IOException &lt;/p&gt;
{
     assertEquals(&quot;Missed generated protocol!&quot;, 1, count);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test need compile.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException          the io exception&lt;br/&gt;
+   * @throws InterruptedException the interrupted exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNeedCompile() throws IOException, InterruptedException &lt;/p&gt;
{
     String schema = &quot;&quot; +
@@ -272,6 +334,9 @@ private Schema createRecord(String name,
     return record;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Generate get method.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void generateGetMethod() {&lt;br/&gt;
     Field height = new Field(&quot;height&quot;, Schema.create(Type.INT), null, null);&lt;br/&gt;
@@ -368,6 +433,9 @@ public void generateGetMethod() &lt;/p&gt;
{
         createRecord(&quot;test&quot;, false, schema, Schema$), Schema$));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Generate set method.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void generateSetMethod() {&lt;br/&gt;
     Field height = new Field(&quot;height&quot;, Schema.create(Type.INT), null, null);&lt;br/&gt;
@@ -464,6 +532,9 @@ public void generateSetMethod() {         createRecord(&quot;test&quot;, false, schema, Schema$), Schema$));   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Generate has method.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void generateHasMethod() {&lt;br/&gt;
     Field height = new Field(&quot;height&quot;, Schema.create(Type.INT), null, null);&lt;br/&gt;
@@ -560,6 +631,9 @@ public void generateHasMethod() &lt;/p&gt;
{
         createRecord(&quot;test&quot;, false, schema, Schema$), Schema$));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Generate clear method.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void generateClearMethod() {&lt;br/&gt;
     Field height = new Field(&quot;height&quot;, Schema.create(Type.INT), null, null);&lt;br/&gt;
@@ -656,6 +730,11 @@ public void generateClearMethod() {         createRecord(&quot;test&quot;, false, schema, Schema$), Schema$));   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test annotations.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testAnnotations() throws Exception {&lt;br/&gt;
     // an interface generated for protocol&lt;br/&gt;
     assertNotNull(Simple.class.getAnnotation(TestAnnotation.class));&lt;br/&gt;
@@ -674,6 +753,11 @@ public void generateClearMethod() &lt;/p&gt;
{
                   .getAnnotation(TestAnnotation.class));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test aliases.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testAliases() throws IOException {&lt;br/&gt;
     Schema s = Schema.parse&lt;br/&gt;
@@ -693,6 +777,10 @@ public void testAliases() throws IOException {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Checks that a schema passes through the SpecificCompiler, and,&lt;/li&gt;
	&lt;li&gt;optionally, uses the system&apos;s Java compiler to check&lt;/li&gt;
	&lt;li&gt;that the generated code is valid.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema          the schema&lt;br/&gt;
+   * @param useJavaCompiler the use java compiler&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   public static void&lt;br/&gt;
       assertCompiles(Schema schema, boolean useJavaCompiler)&lt;br/&gt;
@@ -708,6 +796,10 @@ public void testAliases() throws IOException {&lt;/li&gt;
	&lt;li&gt;Checks that a protocol passes through the SpecificCompiler,&lt;/li&gt;
	&lt;li&gt;and, optionally, uses the system&apos;s Java compiler to check&lt;/li&gt;
	&lt;li&gt;that the generated code is valid.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param protocol        the protocol&lt;br/&gt;
+   * @param useJavaCompiler the use java compiler&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   public static void assertCompiles(Protocol protocol, boolean useJavaCompiler)&lt;br/&gt;
   throws IOException 
{
@@ -718,7 +810,11 @@ public static void assertCompiles(Protocol protocol, boolean useJavaCompiler)
     }
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Uses the system&apos;s java compiler to actually compile the generated code. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Uses the system&apos;s java compiler to actually compile the generated code.  @param outputs the outputs&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   static void assertCompilesWithJavaCompiler(Collection&amp;lt;OutputFile&amp;gt; outputs)&lt;br/&gt;
   throws IOException {&lt;br/&gt;
     if (outputs.isEmpty()) {&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/generic/TestDeepCopy.java b/lang/java/ipc/src/test/java/org/apache/avro/generic/TestDeepCopy.java&lt;br/&gt;
index faf5207a8..781e29084 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/test/java/org/apache/avro/generic/TestDeepCopy.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/generic/TestDeepCopy.java&lt;br/&gt;
@@ -37,8 +37,13 @@&lt;br/&gt;
 import org.apache.avro.specific.SpecificData;&lt;br/&gt;
 import org.junit.Test;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** Unit test for performing a deep copy of an object with a schema */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Unit test for performing a deep copy of an object with a schema&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestDeepCopy {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test deep copy.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testDeepCopy() {&lt;br/&gt;
     // Set all non-default fields in an Interop instance:&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/io/Perf.java b/lang/java/ipc/src/test/java/org/apache/avro/io/Perf.java&lt;br/&gt;
index 29f5ca4c6..3ea5fdbb2 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/io/Perf.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/io/Perf.java&lt;br/&gt;
@@ -59,17 +59,41 @@&lt;br/&gt;
    */&lt;br/&gt;
   private static final long SEED = 19781210;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * New random random.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the random&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Random newRandom() &lt;/p&gt;
{
     return new Random(SEED);
   }

&lt;p&gt;   private static class TestDescriptor {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Test.&lt;br/&gt;
+     */&lt;br/&gt;
     Class&amp;lt;? extends Test&amp;gt; test;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Param.&lt;br/&gt;
+     */&lt;br/&gt;
     String param;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Test descriptor.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param test  the test&lt;br/&gt;
+     * @param param the param&lt;br/&gt;
+     */&lt;br/&gt;
     TestDescriptor(Class&amp;lt;? extends Test&amp;gt; test, String param) &lt;/p&gt;
{
       this.test = test;
       this.param = param;
     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Add.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param typeList the type list&lt;br/&gt;
+     */&lt;br/&gt;
     void add(List&amp;lt;TestDescriptor&amp;gt; typeList) {&lt;br/&gt;
       ALL_TESTS.put(param, this);&lt;br/&gt;
       typeList.add(this);&lt;br/&gt;
@@ -155,6 +179,12 @@ private static void usage() &lt;/p&gt;
{
     System.out.print(details.toString());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The entry point of application.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param args the input arguments&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void main(String[] args) throws Exception {&lt;br/&gt;
     List&amp;lt;Test&amp;gt; tests = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
     boolean writeTests = true;&lt;br/&gt;
@@ -273,14 +303,42 @@ private static final void printResult(long s, Test t, String name) {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Name of the test.&lt;br/&gt;
      */&lt;br/&gt;
     public final String name;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Count.&lt;br/&gt;
+     */&lt;br/&gt;
     public final int count;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Cycles.&lt;br/&gt;
+     */&lt;br/&gt;
     public final int cycles;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Encoded size.&lt;br/&gt;
+     */&lt;br/&gt;
     public long encodedSize = 0;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Is read test.&lt;br/&gt;
+     */&lt;br/&gt;
     protected boolean isReadTest = true;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Is write test.&lt;br/&gt;
+     */&lt;br/&gt;
     protected boolean isWriteTest = true;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Decoder factory.&lt;br/&gt;
+     */&lt;br/&gt;
     static DecoderFactory decoder_factory = new DecoderFactory();&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Encoder factory.&lt;br/&gt;
+     */&lt;br/&gt;
     static EncoderFactory encoder_factory = new EncoderFactory();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name   the name&lt;br/&gt;
+     * @param cycles the cycles&lt;br/&gt;
+     * @param count  the count&lt;br/&gt;
+     */&lt;br/&gt;
     public Test(String name, int cycles, int count) {&lt;br/&gt;
       this.name = name;&lt;br/&gt;
       this.cycles = cycles;&lt;br/&gt;
@@ -289,26 +347,46 @@ public Test(String name, int cycles, int count) {&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Reads data from a Decoder and returns the time taken in nanoseconds.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the long&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
      */&lt;br/&gt;
     abstract long readTest() throws IOException;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Writes data to an Encoder and returns the time taken in nanoseconds.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the long&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
      */&lt;br/&gt;
     abstract long writeTest() throws IOException;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    /**&lt;br/&gt;
+     * Is write test boolean.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the boolean&lt;br/&gt;
+     */&lt;br/&gt;
     final boolean isWriteTest() &lt;/p&gt;
{
       return isWriteTest;
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * Is read test boolean.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the boolean&lt;br/&gt;
+     */&lt;br/&gt;
     final boolean isReadTest() &lt;/p&gt;
{
       return isReadTest;
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** initializes data for read and write tests **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * initializes data for read and write tests  @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     abstract void init() throws IOException;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** clears generated data arrays and other large objects created during initialization **/&lt;br/&gt;
+    /**&lt;br/&gt;
+     * clears generated data arrays and other large objects created during initialization&lt;br/&gt;
+     */&lt;br/&gt;
     abstract void reset();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Override&lt;br/&gt;
@@ -323,11 +401,34 @@ public String toString() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;higher level constructs, just manual serialization.&lt;br/&gt;
    */&lt;br/&gt;
   private static abstract class BasicTest extends Test {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Schema.&lt;br/&gt;
+     */&lt;br/&gt;
     protected final Schema schema;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Data.&lt;br/&gt;
+     */&lt;br/&gt;
     protected byte[] data;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Basic test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name the name&lt;br/&gt;
+     * @param json the json&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     BasicTest(String name, String json) throws IOException 
{
       this(name, json, 1);
     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Basic test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name   the name&lt;br/&gt;
+     * @param json   the json&lt;br/&gt;
+     * @param factor the factor&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     BasicTest(String name, String json, int factor) throws IOException {&lt;br/&gt;
       super(name, CYCLES, COUNT/factor);&lt;br/&gt;
       this.schema = new Schema.Parser().parse(json);&lt;br/&gt;
@@ -350,6 +451,12 @@ public final long writeTest() throws IOException &lt;/p&gt;
{
       return (System.nanoTime() - t);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    /**&lt;br/&gt;
+     * Gets decoder.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the decoder&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     protected Decoder getDecoder() throws IOException &lt;/p&gt;
{
       return newDecoder();
     }
&lt;p&gt;@@ -358,10 +465,22 @@ private Encoder getEncoder() throws IOException &lt;/p&gt;
{
       return newEncoder(getOutputStream());
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * New decoder decoder.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the decoder&lt;br/&gt;
+     */&lt;br/&gt;
     protected Decoder newDecoder() &lt;/p&gt;
{
       return decoder_factory.binaryDecoder(data, null);
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * New encoder encoder.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param out the out&lt;br/&gt;
+     * @return the encoder&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     protected Encoder newEncoder(ByteArrayOutputStream out) throws IOException {&lt;br/&gt;
       Encoder e = encoder_factory.binaryEncoder(out, null);&lt;br/&gt;
 //    Encoder e = encoder_factory.directBinaryEncoder(out, null);&lt;br/&gt;
@@ -386,13 +505,42 @@ void init() throws IOException &lt;/p&gt;
{
       //System.out.println(this.getClass().getSimpleName() + &quot; encodedSize=&quot; + encodedSize);
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * Gen source data.&lt;br/&gt;
+     */&lt;br/&gt;
     abstract void genSourceData();&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Read internal.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param d the d&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     abstract void readInternal(Decoder d) throws IOException;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Write internal.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param e the e&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     abstract void writeInternal(Encoder e) throws IOException;&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Int test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class IntTest extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     protected int[] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Int test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public IntTest() throws IOException {&lt;br/&gt;
       this(&quot;Int&quot;, &quot;&lt;/p&gt;
{ \&quot;type\&quot;: \&quot;int\&quot;}
&lt;p&gt; &quot;);&lt;br/&gt;
     }&lt;br/&gt;
@@ -440,8 +588,16 @@ void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// This is the same data as ReadInt, but using readLong.&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Small long test.&lt;br/&gt;
+   */&lt;br/&gt;
+// This is the same data as ReadInt, but using readLong.&lt;br/&gt;
   static class SmallLongTest extends IntTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Small long test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public SmallLongTest() throws IOException 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {       super(&amp;quot;SmallLong&amp;quot;, &amp;quot;{ \&quot;type\&quot;: \&quot;long\&quot;} &amp;quot;);     }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;@@ -467,9 +623,18 @@ void writeInternal(Encoder e) throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// this tests reading Longs that are sometimes very large&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Long test.&lt;br/&gt;
+   */&lt;br/&gt;
+// this tests reading Longs that are sometimes very large&lt;br/&gt;
   static class LongTest extends BasicTest {&lt;br/&gt;
     private long[] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Long test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public LongTest() throws IOException 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {       super(&amp;quot;Long&amp;quot;, &amp;quot;{ \&quot;type\&quot;: \&quot;long\&quot;} &amp;quot;);     }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;@@ -517,11 +682,31 @@ void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Float test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class FloatTest extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     float[] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Float test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public FloatTest() throws IOException {&lt;br/&gt;
       this(&quot;Float&quot;, &quot;&lt;/p&gt;
{ \&quot;type\&quot;: \&quot;float\&quot;}
&lt;p&gt; &quot;);&lt;br/&gt;
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Float test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name   the name&lt;br/&gt;
+     * @param schema the schema&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public FloatTest(String name, String schema) throws IOException &lt;/p&gt;
{
       super(name, schema);
     }
&lt;p&gt;@@ -562,8 +747,20 @@ void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Double test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class DoubleTest extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     double[] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Double test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public DoubleTest() throws IOException {&lt;br/&gt;
       super(&quot;Double&quot;, &quot;&lt;/p&gt;
{ \&quot;type\&quot;: \&quot;double\&quot;}
&lt;p&gt; &quot;);&lt;br/&gt;
     }&lt;br/&gt;
@@ -604,8 +801,20 @@ void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Bool test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class BoolTest extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     boolean[] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Bool test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public BoolTest() throws IOException {&lt;br/&gt;
       super(&quot;Boolean&quot;, &quot;&lt;/p&gt;
{ \&quot;type\&quot;: \&quot;boolean\&quot;}
&lt;p&gt; &quot;);&lt;br/&gt;
     }&lt;br/&gt;
@@ -646,8 +855,20 @@ void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Bytes test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class BytesTest extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     byte[][] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Bytes test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public BytesTest() throws IOException {&lt;br/&gt;
       super(&quot;Bytes&quot;, &quot;&lt;/p&gt;
{ \&quot;type\&quot;: \&quot;bytes\&quot;}
&lt;p&gt; &quot;, 5);&lt;br/&gt;
     }&lt;br/&gt;
@@ -699,8 +920,20 @@ private static String randomString(Random r) &lt;/p&gt;
{
     return new String(data);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type String test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class StringTest extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     String[] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new String test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public StringTest() throws IOException {&lt;br/&gt;
       super(&quot;String&quot;, &quot;&lt;/p&gt;
{ \&quot;type\&quot;: \&quot;string\&quot;}
&lt;p&gt; &quot;, 5);&lt;br/&gt;
     }&lt;br/&gt;
@@ -741,7 +974,15 @@ void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Array test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ArrayTest extends FloatTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Array test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public ArrayTest() throws IOException {&lt;br/&gt;
       super(&quot;Array&quot;,&lt;br/&gt;
           &quot;{ \&quot;type\&quot;: \&quot;array\&quot;, \&quot;items\&quot;: &quot; +&lt;br/&gt;
@@ -792,7 +1033,15 @@ void writeInternal(Encoder e) throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Map test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class MapTest extends FloatTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Map test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public MapTest() throws IOException {&lt;br/&gt;
       super(&quot;Map&quot;, &quot;{ \&quot;type\&quot;: \&quot;map\&quot;, \&quot;values\&quot;: &quot; +&lt;br/&gt;
           &quot;  { \&quot;type\&quot;: \&quot;record\&quot;, \&quot;name\&quot;:\&quot;Vals\&quot;, \&quot;fields\&quot;: [&quot; +&lt;br/&gt;
@@ -859,15 +1108,43 @@ void writeInternal(Encoder e) throws IOException &lt;/p&gt;
{
     + &quot;] }
&lt;p&gt;&quot;;&lt;/p&gt;

&lt;p&gt;   private static class Rec {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 1.&lt;br/&gt;
+     */&lt;br/&gt;
     double f1;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 2.&lt;br/&gt;
+     */&lt;br/&gt;
     double f2;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 3.&lt;br/&gt;
+     */&lt;br/&gt;
     double f3;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 4.&lt;br/&gt;
+     */&lt;br/&gt;
     int f4;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 5.&lt;br/&gt;
+     */&lt;br/&gt;
     int f5;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 6.&lt;br/&gt;
+     */&lt;br/&gt;
     int f6;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Rec.&lt;br/&gt;
+     */&lt;br/&gt;
     Rec() {&lt;/p&gt;

&lt;p&gt;     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Rec.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param r the r&lt;br/&gt;
+     */&lt;br/&gt;
     Rec(Random r) {&lt;br/&gt;
       f1 = r.nextDouble();&lt;br/&gt;
       f2 = r.nextDouble();&lt;br/&gt;
@@ -878,11 +1155,30 @@ void writeInternal(Encoder e) throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Record test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class RecordTest extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     Rec[] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Record test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public RecordTest() throws IOException &lt;/p&gt;
{
       this(&quot;Record&quot;);
     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Record test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name the name&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public RecordTest(String name) throws IOException &lt;/p&gt;
{
       super(name, RECORD_SCHEMA, 6);
     }
&lt;p&gt;@@ -924,7 +1220,15 @@ void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Validating record.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ValidatingRecord extends RecordTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Validating record.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ValidatingRecord() throws IOException &lt;/p&gt;
{
       super(&quot;ValidatingRecord&quot;);
     }
&lt;p&gt;@@ -938,7 +1242,15 @@ protected Encoder newEncoder(ByteArrayOutputStream out) throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Resolving record.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ResolvingRecord extends RecordTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Resolving record.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public ResolvingRecord() throws IOException {&lt;br/&gt;
       super(&quot;ResolvingRecord&quot;);&lt;br/&gt;
       isWriteTest = false;&lt;br/&gt;
@@ -989,6 +1301,12 @@ protected Decoder getDecoder() throws IOException {&lt;br/&gt;
    */&lt;br/&gt;
   static class RecordWithDefault extends RecordTest {&lt;br/&gt;
     private final Schema readerSchema;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Record with default.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public RecordWithDefault() throws IOException {&lt;br/&gt;
       super(&quot;RecordWithDefault&quot;);&lt;br/&gt;
       readerSchema = new Schema.Parser().parse(RECORD_SCHEMA_WITH_DEFAULT);&lt;br/&gt;
@@ -1031,6 +1349,12 @@ protected void readInternal(Decoder d) throws IOException {&lt;br/&gt;
    */&lt;br/&gt;
   static class RecordWithOutOfOrder extends RecordTest {&lt;br/&gt;
     private final Schema readerSchema;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Record with out of order.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public RecordWithOutOfOrder() throws IOException {&lt;br/&gt;
       super(&quot;RecordWithOutOfOrder&quot;);&lt;br/&gt;
       readerSchema = new Schema.Parser().parse(RECORD_SCHEMA_WITH_OUT_OF_ORDER);&lt;br/&gt;
@@ -1069,6 +1393,12 @@ protected void readInternal(Decoder d) throws IOException {&lt;br/&gt;
    */&lt;br/&gt;
   static class RecordWithPromotion extends RecordTest {&lt;br/&gt;
     private final Schema readerSchema;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Record with promotion.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public RecordWithPromotion() throws IOException {&lt;br/&gt;
       super(&quot;RecordWithPromotion&quot;);&lt;br/&gt;
       readerSchema = new Schema.Parser().parse(RECORD_SCHEMA_WITH_PROMOTION);&lt;br/&gt;
@@ -1102,22 +1432,64 @@ protected void readInternal(Decoder d) throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Generic test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericTest extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     GenericRecord[] sourceData = null;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Reader.&lt;br/&gt;
+     */&lt;br/&gt;
     protected final GenericDatumReader&amp;lt;Object&amp;gt; reader;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public GenericTest() throws IOException &lt;/p&gt;
{
       this(&quot;Generic&quot;);
     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name the name&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     protected GenericTest(String name) throws IOException &lt;/p&gt;
{
       this(name, RECORD_SCHEMA);
     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name         the name&lt;br/&gt;
+     * @param writerSchema the writer schema&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     protected GenericTest(String name, String writerSchema) throws IOException &lt;/p&gt;
{
       super(name, writerSchema, 12);
       reader = newReader();
     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Gets reader.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the reader&lt;br/&gt;
+     */&lt;br/&gt;
     protected GenericDatumReader&amp;lt;Object&amp;gt; getReader() &lt;/p&gt;
{
       return reader;
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * New reader generic datum reader.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the generic datum reader&lt;br/&gt;
+     */&lt;br/&gt;
     protected GenericDatumReader&amp;lt;Object&amp;gt; newReader() {
       return new GenericDatumReader&amp;lt;&amp;gt;(schema);
     }&lt;br/&gt;
@@ -1164,7 +1536,15 @@ void reset() {&lt;br/&gt;
     + &quot;{ \&quot;name\&quot;: \&quot;f3\&quot;, \&quot;type\&quot;: \&quot;string\&quot; }\n&quot;&lt;br/&gt;
     + &quot;] }&quot;;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic strings.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericStrings extends GenericTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic strings.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public GenericStrings() throws IOException {
       super(&quot;GenericStrings&quot;, GENERIC_STRINGS);
     }&lt;br/&gt;
@@ -1182,7 +1562,15 @@ void genSourceData() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic nested.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericNested extends GenericTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic nested.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public GenericNested() throws IOException {
       super(&quot;GenericNested_&quot;, NESTED_RECORD_SCHEMA);
     }&lt;br/&gt;
@@ -1191,6 +1579,14 @@ void genSourceData() {
       sourceData = generateGenericNested(schema, count);
     }&lt;br/&gt;
   }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Generate generic nested generic record [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema the schema&lt;br/&gt;
+   * @param count  the count&lt;br/&gt;
+   * @return the generic record [ ]&lt;br/&gt;
+   */&lt;br/&gt;
   static GenericRecord[] generateGenericNested(Schema schema, int count) {&lt;br/&gt;
     Random r = newRandom();&lt;br/&gt;
     GenericRecord[] sourceData = new GenericRecord&lt;span class=&quot;error&quot;&gt;&amp;#91;count&amp;#93;&lt;/span&gt;;&lt;br/&gt;
@@ -1215,10 +1611,22 @@ void genSourceData() {
     return sourceData;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic nested fake.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericNestedFake extends BasicTest {&lt;br/&gt;
-    //reads and writes generic data, but not using&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
+//reads and writes generic data, but not using&lt;br/&gt;
     //GenericDatumReader or GenericDatumWriter&lt;br/&gt;
     GenericRecord[] sourceData = null;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic nested fake.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public GenericNestedFake() throws IOException {
       super(&quot;GenericNestedFake_&quot;, NESTED_RECORD_SCHEMA, 12);
     }&lt;br/&gt;
@@ -1271,6 +1679,12 @@ void reset() {&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
   private static abstract class GenericResolving extends GenericTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic resolving.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name the name&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     protected GenericResolving(String name)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
       super(name);&lt;br/&gt;
@@ -1280,10 +1694,24 @@ protected GenericResolving(String name)&lt;br/&gt;
     protected GenericDatumReader&amp;lt;Object&amp;gt; newReader() {
       return new GenericDatumReader&amp;lt;&amp;gt;(schema, getReaderSchema());
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Gets reader schema.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the reader schema&lt;br/&gt;
+     */&lt;br/&gt;
     protected abstract Schema getReaderSchema();&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic with default.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericWithDefault extends GenericResolving {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic with default.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     GenericWithDefault() throws IOException {
       super(&quot;GenericWithDefault_&quot;);
     }&lt;br/&gt;
@@ -1293,7 +1721,15 @@ protected Schema getReaderSchema() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic with out of order.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericWithOutOfOrder extends GenericResolving {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic with out of order.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     GenericWithOutOfOrder() throws IOException {
       super(&quot;GenericWithOutOfOrder_&quot;);
     }&lt;br/&gt;
@@ -1303,7 +1739,15 @@ protected Schema getReaderSchema() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic with promotion.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericWithPromotion extends GenericResolving {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic with promotion.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     GenericWithPromotion() throws IOException {
       super(&quot;GenericWithPromotion_&quot;);
     }&lt;br/&gt;
@@ -1313,7 +1757,15 @@ protected Schema getReaderSchema() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic one time decoder use.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericOneTimeDecoderUse extends GenericTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic one time decoder use.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public GenericOneTimeDecoderUse() throws IOException {&lt;br/&gt;
       super(&quot;GenericOneTimeDecoderUse_&quot;);&lt;br/&gt;
       isWriteTest = false;&lt;br/&gt;
@@ -1324,7 +1776,15 @@ protected Decoder getDecoder() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic one time reader use.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericOneTimeReaderUse extends GenericTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic one time reader use.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public GenericOneTimeReaderUse() throws IOException {&lt;br/&gt;
       super(&quot;GenericOneTimeReaderUse_&quot;);&lt;br/&gt;
       isWriteTest = false;&lt;br/&gt;
@@ -1335,7 +1795,15 @@ public GenericOneTimeReaderUse() throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Generic one time use.&lt;br/&gt;
+   */&lt;br/&gt;
   static class GenericOneTimeUse extends GenericTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Generic one time use.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public GenericOneTimeUse() throws IOException {&lt;br/&gt;
       super(&quot;GenericOneTimeUse_&quot;);&lt;br/&gt;
       isWriteTest = false;&lt;br/&gt;
@@ -1350,25 +1818,67 @@ protected Decoder getDecoder() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Specific test.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; the type parameter&lt;br/&gt;
+   */&lt;br/&gt;
   static abstract class SpecificTest&amp;lt;T extends SpecificRecordBase&amp;gt; extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Reader.&lt;br/&gt;
+     */&lt;br/&gt;
     protected final SpecificDatumReader&amp;lt;T&amp;gt; reader;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Writer.&lt;br/&gt;
+     */&lt;br/&gt;
     protected final SpecificDatumWriter&amp;lt;T&amp;gt; writer;&lt;br/&gt;
     private Object[] sourceData;&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Specific test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name         the name&lt;br/&gt;
+     * @param writerSchema the writer schema&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     protected SpecificTest(String name, String writerSchema) throws IOException {
       super(name, writerSchema, 48);
       reader = newReader();
       writer = newWriter();
     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Gets reader.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the reader&lt;br/&gt;
+     */&lt;br/&gt;
     protected SpecificDatumReader&amp;lt;T&amp;gt; getReader() {       return reader;     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Gets writer.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the writer&lt;br/&gt;
+     */&lt;br/&gt;
     protected SpecificDatumWriter&amp;lt;T&amp;gt; getWriter() &lt;/p&gt;
{
       return writer;
     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * New reader specific datum reader.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the specific datum reader&lt;br/&gt;
+     */&lt;br/&gt;
     protected SpecificDatumReader&amp;lt;T&amp;gt; newReader() &lt;/p&gt;
{
       return new SpecificDatumReader&amp;lt;&amp;gt;(schema);
     }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * New writer specific datum writer.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @return the specific datum writer&lt;br/&gt;
+     */&lt;br/&gt;
     protected SpecificDatumWriter&amp;lt;T&amp;gt; newWriter() &lt;/p&gt;
{
       return new SpecificDatumWriter&amp;lt;&amp;gt;(schema);
     }
&lt;p&gt;@@ -1381,6 +1891,12 @@ void genSourceData() {&lt;br/&gt;
       }&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Gen single record t.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param r the r&lt;br/&gt;
+     * @return the t&lt;br/&gt;
+     */&lt;br/&gt;
     protected abstract T genSingleRecord(Random r);&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
@@ -1404,8 +1920,16 @@ void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Foo bar specific record test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class FooBarSpecificRecordTest extends&lt;br/&gt;
       SpecificTest&amp;lt;FooBarSpecificRecord&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Foo bar specific record test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public FooBarSpecificRecordTest() throws IOException &lt;/p&gt;
{
       super(&quot;FooBarSpecificRecordTest&quot;, FooBarSpecificRecord.SCHEMA$.toString());
     }
&lt;p&gt;@@ -1430,12 +1954,37 @@ protected FooBarSpecificRecord genSingleRecord(Random r) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect test.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param &amp;lt;T&amp;gt; the type parameter&lt;br/&gt;
+   */&lt;br/&gt;
   static abstract class ReflectTest&amp;lt;T&amp;gt; extends BasicTest {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Source data.&lt;br/&gt;
+     */&lt;br/&gt;
     T[] sourceData = null;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Reader.&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectDatumReader&amp;lt;T&amp;gt; reader;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Writer.&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectDatumWriter&amp;lt;T&amp;gt; writer;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Clazz.&lt;br/&gt;
+     */&lt;br/&gt;
     Class&amp;lt;T&amp;gt; clazz;&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Reflect test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param name   the name&lt;br/&gt;
+     * @param sample the sample&lt;br/&gt;
+     * @param factor the factor&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
     ReflectTest(String name, T sample, int factor) throws IOException {&lt;br/&gt;
       super(name, ReflectData.get().getSchema(sample.getClass()).toString(), factor);&lt;br/&gt;
@@ -1454,6 +2003,12 @@ protected final void genSourceData() {&lt;br/&gt;
       }&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Create datum t.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param r the r&lt;br/&gt;
+     * @return the t&lt;br/&gt;
+     */&lt;br/&gt;
     protected abstract T createDatum(Random r);&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
@@ -1477,7 +2032,15 @@ protected final void reset() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect record test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectRecordTest extends ReflectTest&amp;lt;Rec&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect record test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectRecordTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectRecord&quot;, new Rec(), 12);
     }
&lt;p&gt;@@ -1488,7 +2051,15 @@ protected Rec createDatum(Random r) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect float test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectFloatTest extends ReflectTest&amp;lt;float[]&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect float test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectFloatTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectFloat&quot;, new float[0], COUNT);
     }
&lt;p&gt;@@ -1499,7 +2070,15 @@ protected Rec createDatum(Random r) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect double test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectDoubleTest extends ReflectTest&amp;lt;double[]&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect double test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectDoubleTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectDouble&quot;, new double[0], COUNT);
     }
&lt;p&gt;@@ -1510,7 +2089,15 @@ protected Rec createDatum(Random r) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect float array test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectFloatArrayTest extends ReflectTest&amp;lt;float[]&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect float array test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectFloatArrayTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectFloatArray&quot;, new float[0], 10);
     }
&lt;p&gt;@@ -1521,7 +2108,15 @@ protected Rec createDatum(Random r) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect double array test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectDoubleArrayTest extends ReflectTest&amp;lt;double[]&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect double array test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectDoubleArrayTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectDoubleArray&quot;, new double[0], 20);
     }
&lt;p&gt;@@ -1532,7 +2127,15 @@ protected Rec createDatum(Random r) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect int array test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectIntArrayTest extends ReflectTest&amp;lt;int[]&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect int array test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectIntArrayTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectIntArray&quot;, new int[0], 12);
     }
&lt;p&gt;@@ -1543,7 +2146,15 @@ protected Rec createDatum(Random r) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect long array test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectLongArrayTest extends ReflectTest&amp;lt;long[]&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect long array test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectLongArrayTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectLongArray&quot;, new long[0], 24);
     }
&lt;p&gt;@@ -1555,8 +2166,16 @@ protected Rec createDatum(Random r) {&lt;br/&gt;
   }&lt;/p&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect nested object array test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectNestedObjectArrayTest extends&lt;br/&gt;
       ReflectTest&amp;lt;ReflectNestedObjectArrayTest.Foo&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect nested object array test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     ReflectNestedObjectArrayTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectNestedObjectArray&quot;, new Foo(new Random()), 50);
     }
&lt;p&gt;@@ -1566,12 +2185,26 @@ protected Foo createDatum(Random r) &lt;/p&gt;
{
       return new Foo(r);
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * The type Foo.&lt;br/&gt;
+     */&lt;br/&gt;
     static public class Foo {&lt;br/&gt;
+      /**&lt;br/&gt;
+       * The Bar.&lt;br/&gt;
+       */&lt;br/&gt;
       Vals[] bar;&lt;/p&gt;

&lt;p&gt;+      /**&lt;br/&gt;
+       * Instantiates a new Foo.&lt;br/&gt;
+       */&lt;br/&gt;
       Foo() {&lt;br/&gt;
       }&lt;/p&gt;

&lt;p&gt;+      /**&lt;br/&gt;
+       * Instantiates a new Foo.&lt;br/&gt;
+       *&lt;br/&gt;
+       * @param r the r&lt;br/&gt;
+       */&lt;br/&gt;
       Foo(Random r) {&lt;br/&gt;
         bar = new Vals&lt;span class=&quot;error&quot;&gt;&amp;#91;smallArraySize(r)&amp;#93;&lt;/span&gt;;&lt;br/&gt;
         for (int i = 0; i &amp;lt; bar.length; i++) {&lt;br/&gt;
@@ -1580,15 +2213,38 @@ protected Foo createDatum(Random r) {&lt;br/&gt;
       }&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * The type Vals.&lt;br/&gt;
+     */&lt;br/&gt;
     static class Vals {&lt;br/&gt;
+      /**&lt;br/&gt;
+       * The F 1.&lt;br/&gt;
+       */&lt;br/&gt;
       float f1;&lt;br/&gt;
+      /**&lt;br/&gt;
+       * The F 2.&lt;br/&gt;
+       */&lt;br/&gt;
       float f2;&lt;br/&gt;
+      /**&lt;br/&gt;
+       * The F 3.&lt;br/&gt;
+       */&lt;br/&gt;
       float f3;&lt;br/&gt;
+      /**&lt;br/&gt;
+       * The F 4.&lt;br/&gt;
+       */&lt;br/&gt;
       float f4;&lt;/p&gt;

&lt;p&gt;+      /**&lt;br/&gt;
+       * Instantiates a new Vals.&lt;br/&gt;
+       */&lt;br/&gt;
       Vals(){&lt;br/&gt;
       }&lt;/p&gt;

&lt;p&gt;+      /**&lt;br/&gt;
+       * Instantiates a new Vals.&lt;br/&gt;
+       *&lt;br/&gt;
+       * @param r the r&lt;br/&gt;
+       */&lt;br/&gt;
       Vals(Random r) {&lt;br/&gt;
         this.f1 = r.nextFloat();&lt;br/&gt;
         this.f2 = r.nextFloat();&lt;br/&gt;
@@ -1599,12 +2255,27 @@ protected Foo createDatum(Random r) {&lt;/p&gt;

&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Float foo.&lt;br/&gt;
+   */&lt;br/&gt;
   static public class FloatFoo {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Float bar.&lt;br/&gt;
+     */&lt;br/&gt;
     float[] floatBar;&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Float foo.&lt;br/&gt;
+     */&lt;br/&gt;
     FloatFoo() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Float foo.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param r     the r&lt;br/&gt;
+     * @param large the large&lt;br/&gt;
+     */&lt;br/&gt;
     FloatFoo(Random r, boolean large) &lt;/p&gt;
{
       floatBar = populateFloatArray(r, large);
     }
&lt;p&gt;@@ -1620,11 +2291,25 @@ private static int largeArraySize(Random r) &lt;/p&gt;
{
     return r.nextInt(97) + 16;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Populate float array float [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param r     the r&lt;br/&gt;
+   * @param large the large&lt;br/&gt;
+   * @return the float [ ]&lt;br/&gt;
+   */&lt;br/&gt;
   static float[] populateFloatArray(Random r, boolean large) &lt;/p&gt;
{
     int size = large ? largeArraySize(r) : smallArraySize(r);
     return populateFloatArray(r, size);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Populate float array float [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param r    the r&lt;br/&gt;
+   * @param size the size&lt;br/&gt;
+   * @return the float [ ]&lt;br/&gt;
+   */&lt;br/&gt;
   static float[] populateFloatArray(Random r, int size) {&lt;br/&gt;
     float[] result = new float&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt;;&lt;br/&gt;
     for (int i = 0; i &amp;lt; result.length; i++) {&lt;br/&gt;
@@ -1633,10 +2318,23 @@ private static int largeArraySize(Random r) &lt;/p&gt;
{
     return result;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Populate double array double [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param r the r&lt;br/&gt;
+   * @return the double [ ]&lt;br/&gt;
+   */&lt;br/&gt;
   static double[] populateDoubleArray(Random r) {
     return populateDoubleArray(r, smallArraySize(r));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Populate double array double [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param r    the r&lt;br/&gt;
+   * @param size the size&lt;br/&gt;
+   * @return the double [ ]&lt;br/&gt;
+   */&lt;br/&gt;
   static double[] populateDoubleArray(Random r, int size) {&lt;br/&gt;
     double[] result = new double&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt;;&lt;br/&gt;
     for (int i = 0; i &amp;lt; result.length; i++) {&lt;br/&gt;
@@ -1645,6 +2343,12 @@ private static int largeArraySize(Random r) {     return result;   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Populate int array int [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param r the r&lt;br/&gt;
+   * @return the int [ ]&lt;br/&gt;
+   */&lt;br/&gt;
   static int[] populateIntArray(Random r) {&lt;br/&gt;
     int size = smallArraySize(r);&lt;br/&gt;
     int[] result = new int&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt;;&lt;br/&gt;
@@ -1654,6 +2358,12 @@ private static int largeArraySize(Random r) &lt;/p&gt;
{
     return result;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Populate long array long [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param r the r&lt;br/&gt;
+   * @return the long [ ]&lt;br/&gt;
+   */&lt;br/&gt;
   static long[] populateLongArray(Random r) {&lt;br/&gt;
     int size = smallArraySize(r);&lt;br/&gt;
     long[] result = new long&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt;;&lt;br/&gt;
@@ -1663,7 +2373,15 @@ private static int largeArraySize(Random r) {     return result;   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect nested float array test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectNestedFloatArrayTest extends ReflectTest&amp;lt;FloatFoo&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect nested float array test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public ReflectNestedFloatArrayTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectNestedFloatArray&quot;, new FloatFoo(new Random(), false), 10);
     }
&lt;p&gt;@@ -1674,7 +2392,15 @@ protected FloatFoo createDatum(Random r) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect nested large float array test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectNestedLargeFloatArrayTest extends ReflectTest&amp;lt;FloatFoo&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect nested large float array test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public ReflectNestedLargeFloatArrayTest() throws IOException {&lt;br/&gt;
       super(&quot;ReflectNestedLargeFloatArray&quot;, new FloatFoo(new Random(), true),&lt;br/&gt;
           60);&lt;br/&gt;
@@ -1687,7 +2413,15 @@ protected FloatFoo createDatum(Random r) {&lt;/p&gt;

&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect nested large float array blocked test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectNestedLargeFloatArrayBlockedTest extends ReflectTest&amp;lt;FloatFoo&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect nested large float array blocked test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public ReflectNestedLargeFloatArrayBlockedTest() throws IOException {&lt;br/&gt;
       super(&quot;ReflectNestedLargeFloatArrayBlocked&quot;, new FloatFoo(new Random(), true),&lt;br/&gt;
           60);&lt;br/&gt;
@@ -1707,22 +2441,66 @@ protected Encoder newEncoder(ByteArrayOutputStream out) throws IOException {&lt;/p&gt;

&lt;p&gt;   @SuppressWarnings(&quot;unused&quot;)&lt;br/&gt;
   private static class Rec1 {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The D 1.&lt;br/&gt;
+     */&lt;br/&gt;
     double d1;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The D 11.&lt;br/&gt;
+     */&lt;br/&gt;
     double d11;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 2.&lt;br/&gt;
+     */&lt;br/&gt;
     float f2;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 22.&lt;br/&gt;
+     */&lt;br/&gt;
     float f22;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 3.&lt;br/&gt;
+     */&lt;br/&gt;
     int f3;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 33.&lt;br/&gt;
+     */&lt;br/&gt;
     int f33;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 4.&lt;br/&gt;
+     */&lt;br/&gt;
     long f4;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 44.&lt;br/&gt;
+     */&lt;br/&gt;
     long f44;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 5.&lt;br/&gt;
+     */&lt;br/&gt;
     byte f5;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 55.&lt;br/&gt;
+     */&lt;br/&gt;
     byte f55;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 6.&lt;br/&gt;
+     */&lt;br/&gt;
     short f6;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The F 66.&lt;br/&gt;
+     */&lt;br/&gt;
     short f66;&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Rec 1.&lt;br/&gt;
+     */&lt;br/&gt;
     Rec1() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Rec 1.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param r the r&lt;br/&gt;
+     */&lt;br/&gt;
     Rec1(Random r) {&lt;br/&gt;
       d1 = r.nextDouble();&lt;br/&gt;
       d11 = r.nextDouble();&lt;br/&gt;
@@ -1739,7 +2517,15 @@ protected Encoder newEncoder(ByteArrayOutputStream out) throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Reflect big record test.&lt;br/&gt;
+   */&lt;br/&gt;
   static class ReflectBigRecordTest extends ReflectTest&amp;lt;Rec1&amp;gt; {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Reflect big record test.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @throws IOException the io exception&lt;br/&gt;
+     */&lt;br/&gt;
     public ReflectBigRecordTest() throws IOException &lt;/p&gt;
{
       super(&quot;ReflectBigRecord&quot;, new Rec1(new Random()), 20);
     }
&lt;p&gt;diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/NettyTransceiverWhenFailsToConnect.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/NettyTransceiverWhenFailsToConnect.java&lt;br/&gt;
index 67763534a..9ac95f633 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/NettyTransceiverWhenFailsToConnect.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/NettyTransceiverWhenFailsToConnect.java&lt;br/&gt;
@@ -35,7 +35,12 @@&lt;br/&gt;
  */&lt;br/&gt;
 public class NettyTransceiverWhenFailsToConnect {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test(expected = IOException.class)&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test netty transceiver releases netty channel on failing to connect.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
+  @Test(expected = IOException.class)&lt;br/&gt;
     public void testNettyTransceiverReleasesNettyChannelOnFailingToConnect() throws Exception 
{
         ServerSocket serverSocket = null;
         LastChannelRememberingChannelFactory socketChannelFactory = null;
@@ -68,9 +73,15 @@ public void testNettyTransceiverReleasesNettyChannelOnFailingToConnect() throws
         }
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;class LastChannelRememberingChannelFactory extends NioClientSocketChannelFactory implements ChannelFactory {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Last channel remembering channel factory.&lt;br/&gt;
+   */&lt;br/&gt;
+  class LastChannelRememberingChannelFactory extends NioClientSocketChannelFactory implements ChannelFactory {&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;volatile SocketChannel lastChannel;&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Last channel.&lt;br/&gt;
+     */&lt;br/&gt;
+    volatile SocketChannel lastChannel;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         @Override&lt;br/&gt;
         public SocketChannel newChannel(ChannelPipeline pipeline) {&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestLocalTransceiver.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestLocalTransceiver.java&lt;br/&gt;
index 3158f88a8..188a67520 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestLocalTransceiver.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestLocalTransceiver.java&lt;br/&gt;
@@ -31,14 +31,28 @@&lt;br/&gt;
 import org.apache.avro.util.Utf8;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test local transceiver.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestLocalTransceiver {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The Protocol.&lt;br/&gt;
+   */&lt;br/&gt;
   Protocol protocol = Protocol.parse(&quot;&quot; + &quot;{\&quot;protocol\&quot;: \&quot;Minimal\&quot;, &quot;&lt;br/&gt;
       + &quot;\&quot;messages\&quot;: { \&quot;m\&quot;: {&quot;&lt;br/&gt;
       + &quot;   \&quot;request\&quot;: [&lt;/p&gt;
{\&quot;name\&quot;: \&quot;x\&quot;, \&quot;type\&quot;: \&quot;string\&quot;}
&lt;p&gt;], &quot;&lt;br/&gt;
       + &quot;   \&quot;response\&quot;: \&quot;string\&quot;} } }&quot;);&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Test responder.&lt;br/&gt;
+   */&lt;br/&gt;
   static class TestResponder extends GenericResponder {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Test responder.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param local the local&lt;br/&gt;
+     */&lt;br/&gt;
     public TestResponder(Protocol local) &lt;/p&gt;
{
       super(local);
     }&lt;br/&gt;
@@ -52,6 +66,11 @@ public Object respond(Message message, Object request)&lt;br/&gt;
 &lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test single rpc.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSingleRpc() throws IOException {&lt;br/&gt;
     Transceiver t = new LocalTransceiver(new TestResponder(protocol));&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServer.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServer.java&lt;br/&gt;
index a89274447..cf9fe3887 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServer.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServer.java&lt;br/&gt;
@@ -38,13 +38,22 @@&lt;br/&gt;
 import org.junit.BeforeClass;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test netty server.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestNettyServer {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Connect timeout millis.&lt;br/&gt;
+   */&lt;br/&gt;
   static final long CONNECT_TIMEOUT_MILLIS = 2000; // 2 sec&lt;br/&gt;
   private static Server server;&lt;br/&gt;
   private static Transceiver transceiver;&lt;br/&gt;
   private static Mail proxy;&lt;br/&gt;
   private static MailImpl mailService;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Mail.&lt;br/&gt;
+   */&lt;br/&gt;
   public static class MailImpl implements Mail {&lt;br/&gt;
 &lt;br/&gt;
     private CountDownLatch allMessages = new CountDownLatch(5);&lt;br/&gt;
@@ -68,11 +77,19 @@ private void assertAllMessagesReceived() {
       assertEquals(0, allMessages.getCount());
     }&lt;br/&gt;
 &lt;br/&gt;
+    /**&lt;br/&gt;
+     * Reset.&lt;br/&gt;
+     */&lt;br/&gt;
     public void reset() {
       allMessages = new CountDownLatch(5);
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize connections.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @BeforeClass&lt;br/&gt;
   public static void initializeConnections()throws Exception {&lt;br/&gt;
     // start server&lt;br/&gt;
@@ -89,21 +106,44 @@ public static void initializeConnections()throws Exception {
     proxy = SpecificRequestor.getClient(Mail.class, transceiver);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize server server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   * @return the server&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Server initializeServer(Responder responder) {
     return new NettyServer(responder, new InetSocketAddress(0));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize transceiver transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param serverPort the server port&lt;br/&gt;
+   * @return the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Transceiver initializeTransceiver(int serverPort) throws IOException {
     return new NettyTransceiver(new InetSocketAddress(
         serverPort), CONNECT_TIMEOUT_MILLIS);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Tear down connections.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void tearDownConnections() throws Exception{
     transceiver.close();
     server.close();
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test request response.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRequestResponse() throws Exception {&lt;br/&gt;
       for(int x = 0; x &amp;lt; 5; x++) {&lt;br/&gt;
@@ -117,6 +157,11 @@ private void verifyResponse(String result) {
         result);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test oneway.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testOneway() throws Exception {&lt;br/&gt;
     for (int x = 0; x &amp;lt; 5; x++) {&lt;br/&gt;
@@ -126,6 +171,11 @@ public void testOneway() throws Exception {
     mailService.assertAllMessagesReceived();
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test mixture of requests.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMixtureOfRequests() throws Exception {&lt;br/&gt;
     mailService.reset();&lt;br/&gt;
@@ -139,6 +189,11 @@ public void testMixtureOfRequests() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test connections count.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testConnectionsCount() throws Exception {&lt;br/&gt;
     Transceiver transceiver2 = new NettyTransceiver(new InetSocketAddress(&lt;br/&gt;
@@ -169,7 +224,12 @@ private Message createMessage() {
     return msg;
   }&lt;br/&gt;
 &lt;br/&gt;
-  // send a malformed request (HTTP) to the NettyServer port&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test bad request.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
+// send a malformed request (HTTP) to the NettyServer port&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBadRequest() throws IOException {&lt;br/&gt;
     int port = server.getPort();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerConcurrentExecution.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerConcurrentExecution.java&lt;br/&gt;
index fcae16f71..6a35101e8 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerConcurrentExecution.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerConcurrentExecution.java&lt;br/&gt;
@@ -40,28 +40,33 @@&lt;br/&gt;
  * Verifies that RPCs executed by different client threads using the same&lt;br/&gt;
  * NettyTransceiver will execute concurrently.  The test follows these steps:&lt;br/&gt;
  * 1. Execute the {@link #org.apache.avro.test.Simple.add(int, int)} RPC to&lt;br/&gt;
- *    complete the Avro IPC handshake.&lt;br/&gt;
+ * complete the Avro IPC handshake.&lt;br/&gt;
  * 2a. In a background thread, wait for the waitLatch.&lt;br/&gt;
  * 3a. In the main thread, invoke&lt;br/&gt;
- *    {@link #org.apache.avro.test.Simple.hello(String)} with the argument&lt;br/&gt;
- *    &quot;wait&quot;.  This causes the ClientImpl running on the server to count down&lt;br/&gt;
- *    the wait latch, which will unblock the background thread and allow it to&lt;br/&gt;
- *    proceed.  After counting down the latch, this call blocks, waiting for&lt;br/&gt;
- *    {@link #org.apache.avro.test.Simple.ack()} to be invoked.&lt;br/&gt;
+ * {@link #org.apache.avro.test.Simple.hello(String)} with the argument&lt;br/&gt;
+ * &quot;wait&quot;.  This causes the ClientImpl running on the server to count down&lt;br/&gt;
+ * the wait latch, which will unblock the background thread and allow it to&lt;br/&gt;
+ * proceed.  After counting down the latch, this call blocks, waiting for&lt;br/&gt;
+ * {@link #org.apache.avro.test.Simple.ack()} to be invoked.&lt;br/&gt;
  * 2b. The background thread wakes up because the waitLatch has been counted&lt;br/&gt;
- *     down.  Now we know that some thread is executing inside hello(String).&lt;br/&gt;
- *     Next, execute {@link #org.apache.avro.test.Simple.ack()} in the&lt;br/&gt;
- *     background thread, which will allow the thread executing hello(String)&lt;br/&gt;
- *     to return.&lt;br/&gt;
+ * down.  Now we know that some thread is executing inside hello(String).&lt;br/&gt;
+ * Next, execute {@link #org.apache.avro.test.Simple.ack()} in the&lt;br/&gt;
+ * background thread, which will allow the thread executing hello(String)&lt;br/&gt;
+ * to return.&lt;br/&gt;
  * 3b. The thread executing hello(String) on the server unblocks (since ack()&lt;br/&gt;
- *     has been called), allowing hello(String) to return.&lt;br/&gt;
+ * has been called), allowing hello(String) to return.&lt;br/&gt;
  * 4. If control returns to the main thread, we know that two RPCs&lt;br/&gt;
- *    (hello(String) and ack()) were executing concurrently.&lt;br/&gt;
+ * (hello(String) and ack()) were executing concurrently.&lt;br/&gt;
  */&lt;br/&gt;
 public class TestNettyServerConcurrentExecution {&lt;br/&gt;
   private Server server;&lt;br/&gt;
   private Transceiver transceiver;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Clean up after.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @After&lt;br/&gt;
   public void cleanUpAfter() throws Exception {&lt;br/&gt;
     try {&lt;br/&gt;
@@ -80,6 +85,11 @@ public void cleanUpAfter() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(timeout=30000)&lt;br/&gt;
   public void test() throws Exception {&lt;br/&gt;
     final CountDownLatch waitLatch = new CountDownLatch(1);&lt;br/&gt;
@@ -144,6 +154,7 @@ public void run() {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a SimpleImpl that uses the given CountDownLatch.&lt;br/&gt;
+     *&lt;br/&gt;
      * @param waitLatch the CountDownLatch to use in {@link #hello(String)}.&lt;br/&gt;
      */&lt;br/&gt;
     public SimpleImpl(final CountDownLatch waitLatch) {&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithCallbacks.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithCallbacks.java&lt;br/&gt;
index 30b1fb962..9a703b0ee 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithCallbacks.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithCallbacks.java&lt;br/&gt;
@@ -57,6 +57,11 @@&lt;br/&gt;
     new AtomicReference&amp;lt;&amp;gt;(new CountDownLatch(1));&lt;br/&gt;
   private static Simple simpleService = new SimpleImpl(ackFlag);&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize connections.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @BeforeClass&lt;br/&gt;
   public static void initializeConnections() throws Exception {&lt;br/&gt;
     // start server&lt;br/&gt;
@@ -72,6 +77,11 @@ public static void initializeConnections() throws Exception {
     simpleClient = SpecificRequestor.getClient(Simple.Callback.class, transceiver);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Tear down connections.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void tearDownConnections() throws Exception {&lt;br/&gt;
     if (transceiver != null) {&lt;br/&gt;
@@ -82,6 +92,11 @@ public static void tearDownConnections() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Greeting.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void greeting() throws Exception {&lt;br/&gt;
     // Test synchronous RPC:&lt;br/&gt;
@@ -109,6 +124,11 @@ public void handleError(Throwable error) {
     Assert.assertNull(future2.getError());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Echo.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void echo() throws Exception {&lt;br/&gt;
     TestRecord record = TestRecord.newBuilder().setHash(&lt;br/&gt;
@@ -142,6 +162,11 @@ public void handleError(Throwable error) {     Assert.assertNull(future2.getError());   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Add.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void add() throws Exception {&lt;br/&gt;
     // Test synchronous RPC:&lt;br/&gt;
@@ -169,6 +194,11 @@ public void handleError(Throwable error) {
     Assert.assertNull(future2.getError());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Echo bytes.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void echoBytes() throws Exception {&lt;br/&gt;
     ByteBuffer byteBuffer = ByteBuffer.wrap(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 });&lt;br/&gt;
@@ -198,6 +228,13 @@ public void handleError(Throwable error) {     Assert.assertNull(future2.getError());   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Error.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException          the io exception&lt;br/&gt;
+   * @throws InterruptedException the interrupted exception&lt;br/&gt;
+   * @throws TimeoutException     the timeout exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test()&lt;br/&gt;
   public void error() throws IOException, InterruptedException, TimeoutException {&lt;br/&gt;
     // Test synchronous RPC:&lt;br/&gt;
@@ -245,6 +282,11 @@ public void handleError(Throwable error) {
     Assert.assertTrue(errorRef.get() instanceof TestError);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Ack.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void ack() throws Exception {&lt;br/&gt;
     simpleClient.ack();&lt;br/&gt;
@@ -257,6 +299,11 @@ public void ack() throws Exception {
     Assert.assertFalse(&quot;Expected ack flag to be cleared&quot;, ackFlag.get());
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test send after channel close.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSendAfterChannelClose() throws Exception {&lt;br/&gt;
     // Start up a second server so that closing the server doesn&apos;t&lt;br/&gt;
@@ -324,6 +371,11 @@ public void testSendAfterChannelClose() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Cancel pending requests on transceiver close.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void cancelPendingRequestsOnTransceiverClose() throws Exception {&lt;br/&gt;
     // Start up a second server so that closing the server doesn&apos;t&lt;br/&gt;
@@ -371,6 +423,11 @@ public void cancelPendingRequestsOnTransceiverClose() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Cancel pending requests after channel close by server shutdown.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Throwable the throwable&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(timeout = 20000)&lt;br/&gt;
   public void cancelPendingRequestsAfterChannelCloseByServerShutdown() throws Throwable {&lt;br/&gt;
     // The purpose of this test is to verify that a client doesn&apos;t stay&lt;br/&gt;
@@ -451,6 +508,11 @@ public void run() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Client reconnect after server restart.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void clientReconnectAfterServerRestart() throws Exception {&lt;br/&gt;
     // Start up a second server so that closing the server doesn&apos;t&lt;br/&gt;
@@ -492,6 +554,11 @@ public void clientReconnectAfterServerRestart() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Performance test.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Ignore&lt;br/&gt;
   @Test&lt;br/&gt;
   public void performanceTest() throws Exception {&lt;br/&gt;
@@ -539,6 +606,7 @@ public void run() {&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Creates a SimpleImpl.&lt;br/&gt;
+     *&lt;br/&gt;
      * @param ackFlag the AtomicBoolean to toggle when ack() is called.&lt;br/&gt;
      */&lt;br/&gt;
     public SimpleImpl(final AtomicBoolean ackFlag) {&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithCompression.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithCompression.java&lt;br/&gt;
index ab8de9900..5fc6ef647 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithCompression.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithCompression.java&lt;br/&gt;
@@ -31,9 +31,18 @@&lt;br/&gt;
 import org.jboss.netty.handler.codec.compression.ZlibDecoder;&lt;br/&gt;
 import org.jboss.netty.handler.codec.compression.ZlibEncoder;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test netty server with compression.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestNettyServerWithCompression extends TestNettyServer{&lt;br/&gt;
 &lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize server server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   * @return the server&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Server initializeServer(Responder responder) {&lt;br/&gt;
     ChannelFactory channelFactory = new NioServerSocketChannelFactory(&lt;br/&gt;
         Executors.newCachedThreadPool(),&lt;br/&gt;
@@ -44,6 +53,13 @@ protected static Server initializeServer(Responder responder) {
         null);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize transceiver transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param serverPort the server port&lt;br/&gt;
+   * @return the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Transceiver initializeTransceiver(int serverPort) throws IOException {&lt;br/&gt;
     return  new NettyTransceiver(new InetSocketAddress(serverPort),&lt;br/&gt;
         new CompressionChannelFactory(),&lt;br/&gt;
@@ -55,6 +71,9 @@ protected static Transceiver initializeTransceiver(int serverPort) throws IOExce&lt;br/&gt;
    * Factory of Compression-enabled client channels&lt;br/&gt;
    */&lt;br/&gt;
   private static class CompressionChannelFactory extends NioClientSocketChannelFactory {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Compression channel factory.&lt;br/&gt;
+     */&lt;br/&gt;
     public CompressionChannelFactory() {
       super(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());
     }&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithSSL.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithSSL.java&lt;br/&gt;
index dfc82716e..288858ada 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithSSL.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyServerWithSSL.java&lt;br/&gt;
@@ -39,10 +39,25 @@&lt;br/&gt;
 import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;&lt;br/&gt;
 import org.jboss.netty.handler.ssl.SslHandler;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test netty server with ssl.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestNettyServerWithSSL extends TestNettyServer{&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant TEST_CERTIFICATE.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final String TEST_CERTIFICATE = &quot;servercert.p12&quot;;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The constant TEST_CERTIFICATE_PASSWORD.&lt;br/&gt;
+   */&lt;br/&gt;
   public static final String TEST_CERTIFICATE_PASSWORD = &quot;s3cret&quot;;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize server server.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param responder the responder&lt;br/&gt;
+   * @return the server&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Server initializeServer(Responder responder) {&lt;br/&gt;
     ChannelFactory channelFactory = new NioServerSocketChannelFactory(&lt;br/&gt;
         Executors.newCachedThreadPool(),&lt;br/&gt;
@@ -53,6 +68,13 @@ protected static Server initializeServer(Responder responder) {         null);   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize transceiver transceiver.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param serverPort the server port&lt;br/&gt;
+   * @return the transceiver&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   protected static Transceiver initializeTransceiver(int serverPort) throws IOException {&lt;br/&gt;
     return  new NettyTransceiver(new InetSocketAddress(serverPort),&lt;br/&gt;
         new SSLChannelFactory(),&lt;br/&gt;
@@ -64,6 +86,9 @@ protected static Transceiver initializeTransceiver(int serverPort) throws IOExce&lt;br/&gt;
    * Factory of SSL-enabled client channels&lt;br/&gt;
    */&lt;br/&gt;
   private static class SSLChannelFactory extends NioClientSocketChannelFactory {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Ssl channel factory.&lt;br/&gt;
+     */&lt;br/&gt;
     public SSLChannelFactory() {
       super(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());
     }&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyTransceiverWhenServerStops.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyTransceiverWhenServerStops.java&lt;br/&gt;
index d79ce45a4..9e9e777b0 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyTransceiverWhenServerStops.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestNettyTransceiverWhenServerStops.java&lt;br/&gt;
@@ -30,7 +30,15 @@&lt;br/&gt;
 &lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test netty transceiver when server stops.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestNettyTransceiverWhenServerStops {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test netty transceiver when server stops.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
 //  @Test                                           // disable flakey test!&lt;br/&gt;
     public void testNettyTransceiverWhenServerStops() throws Exception {&lt;br/&gt;
     Mail mailService = new TestNettyServer.MailImpl();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestRpcPluginOrdering.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestRpcPluginOrdering.java&lt;br/&gt;
index 77cfe6bbd..b72962955 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestRpcPluginOrdering.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestRpcPluginOrdering.java&lt;br/&gt;
@@ -32,10 +32,16 @@&lt;br/&gt;
 import org.apache.avro.test.Message;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test rpc plugin ordering.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestRpcPluginOrdering {&lt;br/&gt;
 &lt;br/&gt;
   private static AtomicInteger orderCounter = new AtomicInteger();&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The type Order plugin.&lt;br/&gt;
+   */&lt;br/&gt;
   public class OrderPlugin extends RPCPlugin{&lt;br/&gt;
 &lt;br/&gt;
     public void clientStartConnect(RPCContext context) {&lt;br/&gt;
@@ -67,6 +73,11 @@ public void serverSendResponse(RPCContext context) {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test rpc plugin ordering.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRpcPluginOrdering() throws Exception {&lt;br/&gt;
     OrderPlugin plugin = new OrderPlugin();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestSaslAnonymous.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestSaslAnonymous.java&lt;br/&gt;
index 2034e058f..fb28d3855 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestSaslAnonymous.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestSaslAnonymous.java&lt;br/&gt;
@@ -33,6 +33,9 @@&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test sasl anonymous.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSaslAnonymous extends TestProtocolGeneric {&lt;br/&gt;
 &lt;br/&gt;
   private static final Logger LOG =&lt;br/&gt;
@@ -50,11 +53,25 @@ public void testStartServer() throws Exception {&lt;br/&gt;
   @Override public void testHandshake() throws IOException {}&lt;br/&gt;
   @Override public void testResponseChange() throws IOException {}&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The interface Proto interface.&lt;br/&gt;
+   */&lt;br/&gt;
   public interface ProtoInterface {
+    /**
+     * Test byte [ ].
+     *
+     * @param b the b
+     * @return the byte [ ]
+     */
     byte[] test(byte[] b);
   }&lt;br/&gt;
 &lt;br/&gt;
-  // test big enough to fill socket output buffer&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test 64 k request.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
+// test big enough to fill socket output buffer&lt;br/&gt;
   @Test&lt;br/&gt;
   public void test64kRequest() throws Exception {&lt;br/&gt;
     SaslSocketServer s = new SaslSocketServer&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestSaslDigestMd5.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestSaslDigestMd5.java&lt;br/&gt;
index 2c211c9ab..296d470d4 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestSaslDigestMd5.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/TestSaslDigestMd5.java&lt;br/&gt;
@@ -47,6 +47,9 @@&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test sasl digest md 5.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSaslDigestMd5 extends TestProtocolGeneric {&lt;br/&gt;
 &lt;br/&gt;
   private static final Logger LOG =&lt;br/&gt;
@@ -106,6 +109,11 @@ public void testStartServer() throws Exception {
     requestor = new GenericRequestor(PROTOCOL, client);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test anonymous client.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=SaslException.class)&lt;br/&gt;
   public void testAnonymousClient() throws Exception {
     Server s = new SaslSocketServer
@@ -145,6 +153,11 @@ public void handle(Callback[] callbacks)
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test wrong password.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=SaslException.class)&lt;br/&gt;
   public void testWrongPassword() throws Exception {&lt;br/&gt;
     Server s = new SaslSocketServer&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/specific/TestSpecificRequestor.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/specific/TestSpecificRequestor.java&lt;br/&gt;
index 2cf23e5cd..06ddf0a30 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/specific/TestSpecificRequestor.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/specific/TestSpecificRequestor.java&lt;br/&gt;
@@ -28,13 +28,30 @@&lt;br/&gt;
 import org.junit.BeforeClass;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test specific requestor.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSpecificRequestor {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The interface Sample specific protocol.&lt;br/&gt;
+   */&lt;br/&gt;
   public interface SampleSpecificProtocol {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The constant PROTOCOL.&lt;br/&gt;
+     */&lt;br/&gt;
     public static final Protocol PROTOCOL = Protocol.parse(&quot;{\&quot;protocol\&quot;:\&quot;SampleSpecificProtocol\&quot;,\&quot;namespace\&quot;:\&quot;org.apache.avro.ipc.specific\&quot;,\&quot;types\&quot;:[],\&quot;messages\&quot;:{}}&quot;);&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Proxy.&lt;br/&gt;
+   */&lt;br/&gt;
   static Object proxy;&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Initialize proxy.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @BeforeClass&lt;br/&gt;
   public static void initializeProxy() throws Exception {&lt;br/&gt;
     HttpTransceiver client = new HttpTransceiver(new URL(&quot;http://localhost&quot;));&lt;br/&gt;
@@ -42,6 +59,11 @@ public static void initializeProxy() throws Exception {
     proxy = SpecificRequestor.getClient(SampleSpecificProtocol.class, requestor);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test hash code.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testHashCode() throws IOException {&lt;br/&gt;
     try {&lt;br/&gt;
@@ -51,6 +73,11 @@ public void testHashCode() throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test equals.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testEquals() throws IOException {&lt;br/&gt;
     try {&lt;br/&gt;
@@ -60,6 +87,11 @@ public void testEquals() throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test to string.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testToString() throws IOException {&lt;br/&gt;
     try {&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/FakeTicks.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/FakeTicks.java&lt;br/&gt;
index 68358b724..cd346fb67 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/FakeTicks.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/FakeTicks.java&lt;br/&gt;
@@ -19,8 +19,13 @@&lt;br/&gt;
 &lt;br/&gt;
 import org.apache.avro.ipc.stats.Stopwatch.Ticks;&lt;br/&gt;
 &lt;br/&gt;
-/** Implements Ticks with manual time-winding. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Implements Ticks with manual time-winding.&lt;br/&gt;
+ */&lt;br/&gt;
 class FakeTicks implements Ticks {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Time.&lt;br/&gt;
+   */&lt;br/&gt;
   long time = 0;&lt;br/&gt;
 &lt;br/&gt;
   @Override&lt;br/&gt;
@@ -28,6 +33,11 @@ public long ticks() {
     return time;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Pass time.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param nanos the nanos&lt;br/&gt;
+   */&lt;br/&gt;
   public void passTime(long nanos) {
     time += nanos;
   }&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/StatsPluginOverhead.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/StatsPluginOverhead.java&lt;br/&gt;
index e0c9a67ee..2b9812a4e 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/StatsPluginOverhead.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/StatsPluginOverhead.java&lt;br/&gt;
@@ -32,7 +32,7 @@&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
  * Naively measures overhead of using the stats plugin.&lt;br/&gt;
- *&lt;br/&gt;
+ * &amp;lt;p&amp;gt;&lt;br/&gt;
  * The API used is the generic one.&lt;br/&gt;
  * The protocol is the &quot;null&quot; protocol: null is sent&lt;br/&gt;
  * and returned.&lt;br/&gt;
@@ -47,6 +47,11 @@&lt;br/&gt;
       + &quot;   \&quot;response\&quot;: \&quot;null\&quot;} } }&quot;);&lt;br/&gt;
 &lt;br/&gt;
   private static class IdentityResponder extends GenericResponder {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Identity responder.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param local the local&lt;br/&gt;
+     */&lt;br/&gt;
     public IdentityResponder(Protocol local) {       super(local);     }
&lt;p&gt;@@ -58,6 +63,12 @@ public Object respond(Message message, Object request)&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The entry point of application.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param args the input arguments&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void main(String[] args) throws Exception {&lt;br/&gt;
     double with = sendRpcs(true)/1000000000.0;&lt;br/&gt;
     double without = sendRpcs(false)/1000000000.0;&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestHistogram.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestHistogram.java&lt;br/&gt;
index d22d3aade..e2d056336 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestHistogram.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestHistogram.java&lt;br/&gt;
@@ -31,8 +31,14 @@&lt;br/&gt;
 import org.apache.avro.ipc.stats.Histogram.Segmenter;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test histogram.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestHistogram {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test basic operation.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBasicOperation() {&lt;br/&gt;
     Segmenter&amp;lt;String, Integer&amp;gt; s = new Histogram.TreeMapSegmenter&amp;lt;&amp;gt;(&lt;br/&gt;
@@ -95,6 +101,9 @@ public void testBasicOperation() {&lt;/p&gt;

&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test bad value.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=Histogram.SegmenterException.class)&lt;br/&gt;
   public void testBadValue() {&lt;br/&gt;
     Segmenter&amp;lt;String, Long&amp;gt; s = new Histogram.TreeMapSegmenter&amp;lt;&amp;gt;(&lt;br/&gt;
@@ -104,7 +113,9 @@ public void testBadValue() &lt;/p&gt;
{
     h.add(-1L);
   }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Only has one bucket */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Only has one bucket&lt;br/&gt;
+   */&lt;br/&gt;
   static class SingleBucketSegmenter implements Segmenter&amp;lt;String, Float &amp;gt;{&lt;br/&gt;
     @Override&lt;br/&gt;
     public Iterator&amp;lt;String&amp;gt; getBuckets() {&lt;br/&gt;
@@ -127,6 +138,9 @@ public void testBadValue() {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test float histogram.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFloatHistogram() {&lt;br/&gt;
     FloatHistogram&amp;lt;String&amp;gt; h = new FloatHistogram&amp;lt;&amp;gt;(new SingleBucketSegmenter());&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestStatsPluginAndServlet.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestStatsPluginAndServlet.java&lt;br/&gt;
index 258552090..c2c8a4d6c 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestStatsPluginAndServlet.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestStatsPluginAndServlet.java&lt;br/&gt;
@@ -43,11 +43,20 @@&lt;br/&gt;
 import org.apache.avro.ipc.generic.GenericResponder;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test stats plugin and servlet.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestStatsPluginAndServlet {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Protocol.&lt;br/&gt;
+   */&lt;br/&gt;
   Protocol protocol = Protocol.parse(&quot;&quot; + &quot;{\&quot;protocol\&quot;: \&quot;Minimal\&quot;, &quot;&lt;br/&gt;
       + &quot;\&quot;messages\&quot;: { \&quot;m\&quot;: {&quot;&lt;br/&gt;
       + &quot;   \&quot;request\&quot;: [&lt;/p&gt;
{\&quot;name\&quot;: \&quot;x\&quot;, \&quot;type\&quot;: \&quot;int\&quot;}
&lt;p&gt;], &quot;&lt;br/&gt;
       + &quot;   \&quot;response\&quot;: \&quot;int\&quot;} } }&quot;);&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Message.&lt;br/&gt;
+   */&lt;br/&gt;
   Message message = protocol.getMessages().get(&quot;m&quot;);&lt;/p&gt;

&lt;p&gt;   private static final long MS = 1000*1000L;&lt;br/&gt;
@@ -71,8 +80,15 @@ private String generateServletResponse(StatsPlugin statsPlugin)&lt;br/&gt;
     return o;&lt;br/&gt;
   }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Expects 0 and returns 1. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Expects 0 and returns 1.&lt;br/&gt;
+   */&lt;br/&gt;
   static class TestResponder extends GenericResponder {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Test responder.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param local the local&lt;br/&gt;
+     */&lt;br/&gt;
     public TestResponder(Protocol local) 
{
       super(local);
     }&lt;br/&gt;
@@ -94,6 +110,11 @@ private void makeRequest(Transceiver t) throws IOException {
     assertEquals(1, r.request(&quot;m&quot;, params));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test full server path.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFullServerPath() throws IOException {&lt;br/&gt;
     Responder r = new TestResponder(protocol);&lt;br/&gt;
@@ -109,6 +130,11 @@ public void testFullServerPath() throws IOException {
     assertTrue(o.contains(&quot;10 calls&quot;));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test multiple rp cs.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMultipleRPCs() throws IOException {&lt;br/&gt;
     FakeTicks t = new FakeTicks();&lt;br/&gt;
@@ -130,6 +156,11 @@ public void testMultipleRPCs() throws IOException {
     assertTrue(r.contains(&quot;Average: 500.0ms&quot;));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test payload size.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testPayloadSize() throws IOException {&lt;br/&gt;
     Responder r = new TestResponder(protocol);&lt;br/&gt;
@@ -151,6 +182,11 @@ private RPCContext makeContext() {&lt;br/&gt;
 &lt;br/&gt;
   /** Sleeps as requested. */&lt;br/&gt;
   private static class SleepyResponder extends GenericResponder {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Sleepy responder.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param local the local&lt;br/&gt;
+     */&lt;br/&gt;
     public SleepyResponder(Protocol local) {       super(local);     }
&lt;p&gt;@@ -174,8 +210,9 @@ public Object respond(Message message, Object request)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;pre&amp;gt;&lt;/li&gt;
	&lt;li&gt;java &lt;del&gt;jar build/avro-tools&lt;/del&gt;*.jar rpcsend &apos;{&quot;protocol&quot;:&quot;sleepy&quot;,&quot;namespace&quot;:null,&quot;types&quot;:[],&quot;messages&quot;:{&quot;sleep&quot;:
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {&amp;quot;request&amp;quot;}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;}}&apos; sleep localhost 7002 &apos;&lt;/p&gt;
{&quot;millis&quot;: 20000}
&lt;p&gt;&apos;&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;/pre&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @param args&lt;/li&gt;
	&lt;li&gt;* @throws Exception&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param args the input arguments&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
    */&lt;br/&gt;
   public static void main(String[] args) throws Exception {&lt;br/&gt;
     if (args.length == 0) {&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestStopwatch.java b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestStopwatch.java&lt;br/&gt;
index 2f05e3e68..8516fe1ce 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestStopwatch.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/ipc/stats/TestStopwatch.java&lt;br/&gt;
@@ -23,7 +23,13 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test stopwatch.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestStopwatch {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test normal.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testNormal() {&lt;br/&gt;
     FakeTicks f = new FakeTicks();&lt;br/&gt;
@@ -38,6 +44,9 @@ public void testNormal() &lt;/p&gt;
{
     assertEquals(60, s.elapsedNanos());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test not started 1.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testNotStarted1() {&lt;br/&gt;
     FakeTicks f = new FakeTicks();&lt;br/&gt;
@@ -45,6 +54,9 @@ public void testNotStarted1() &lt;/p&gt;
{
     s.elapsedNanos();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test not started 2.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testNotStarted2() {&lt;br/&gt;
     FakeTicks f = new FakeTicks();&lt;br/&gt;
@@ -52,6 +64,9 @@ public void testNotStarted2() &lt;/p&gt;
{
     s.stop();
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test twice started.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testTwiceStarted() {&lt;br/&gt;
     FakeTicks f = new FakeTicks();&lt;br/&gt;
@@ -60,6 +75,9 @@ public void testTwiceStarted() {
     s.start();
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test twice stopped.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=IllegalStateException.class)&lt;br/&gt;
   public void testTwiceStopped() {&lt;br/&gt;
     FakeTicks f = new FakeTicks();&lt;br/&gt;
@@ -69,6 +87,9 @@ public void testTwiceStopped() {     s.stop();   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test system stopwatch.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSystemStopwatch() {&lt;br/&gt;
     Stopwatch s = new Stopwatch(Stopwatch.SYSTEM_TICKS);&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/message/TestCustomSchemaStore.java b/lang/java/ipc/src/test/java/org/apache/avro/message/TestCustomSchemaStore.java&lt;br/&gt;
index ba960442a..75859a5a0 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/message/TestCustomSchemaStore.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/message/TestCustomSchemaStore.java&lt;br/&gt;
@@ -31,10 +31,23 @@&lt;/p&gt;

&lt;p&gt; import static org.junit.Assert.assertEquals;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test custom schema store.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestCustomSchemaStore {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The type Custom schema store.&lt;br/&gt;
+   */&lt;br/&gt;
   static class CustomSchemaStore implements SchemaStore {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The Cache.&lt;br/&gt;
+     */&lt;br/&gt;
     Cache cache;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Instantiates a new Custom schema store.&lt;br/&gt;
+     */&lt;br/&gt;
     CustomSchemaStore() {&lt;br/&gt;
       cache = new Cache();&lt;br/&gt;
       cache.addSchema(NestedEvolve1.getClassSchema());&lt;br/&gt;
@@ -49,6 +62,11 @@ public Schema findByFingerprint(long fingerprint) {&lt;/p&gt;

&lt;p&gt;   private BinaryMessageDecoder&amp;lt;NestedEvolve1&amp;gt; decoder = NestedEvolve1.createDecoder(new CustomSchemaStore());&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test compatible read with schema from schema store.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testCompatibleReadWithSchemaFromSchemaStore() throws Exception {&lt;br/&gt;
     // Create and encode a NestedEvolve2 record.&lt;br/&gt;
@@ -65,6 +83,11 @@ public void testCompatibleReadWithSchemaFromSchemaStore() throws Exception &lt;/p&gt;
{
     assertEquals(nestedEvolve1.getNested().getValue(), Long.valueOf(1));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test incompatible read with schema from schema store.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected = MissingSchemaException.class)&lt;br/&gt;
   public void testIncompatibleReadWithSchemaFromSchemaStore() throws Exception {&lt;br/&gt;
     // Create and encode a NestedEvolve3 record.&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificBuilderTree.java b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificBuilderTree.java&lt;br/&gt;
index 53ed75426..ea9a504b1 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificBuilderTree.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificBuilderTree.java&lt;br/&gt;
@@ -29,6 +29,9 @@&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test specific builder tree.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSpecificBuilderTree {&lt;/p&gt;

&lt;p&gt;   private Request.Builder createPartialBuilder() &lt;/p&gt;
{
@@ -70,6 +73,9 @@
     return requestBuilder;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Fail on incomplete tree.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected = AvroMissingFieldException.class)&lt;br/&gt;
   public void failOnIncompleteTree() {&lt;br/&gt;
     try {&lt;br/&gt;
@@ -82,6 +88,9 @@ public void failOnIncompleteTree() &lt;/p&gt;
{
     fail(&quot;Should NEVER get here&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Copy builder.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void copyBuilder() {&lt;br/&gt;
     Request.Builder requestBuilder1 = createPartialBuilder();&lt;br/&gt;
@@ -125,6 +134,9 @@ public void copyBuilder() &lt;/p&gt;
{
     assertEquals(&quot;Bar&quot;,             request2.getHttpRequest().getURI().getParameters().get(0).getValue());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Create builder from instance.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void createBuilderFromInstance(){&lt;br/&gt;
     Request.Builder requestBuilder1 = createPartialBuilder();&lt;br/&gt;
@@ -190,6 +202,9 @@ public void createBuilderFromInstance()&lt;/p&gt;
{
     return requestBuilder;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Last one wins setter.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void lastOneWins_Setter() {&lt;br/&gt;
     Request.Builder requestBuilder = createLastOneTestsBuilder();&lt;br/&gt;
@@ -226,6 +241,9 @@ public void lastOneWins_Setter() &lt;/p&gt;
{
     assertEquals(&quot;/login.php&quot;,      request.getHttpRequest().getURI().getPath());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Last one wins builder.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void lastOneWins_Builder() {&lt;br/&gt;
     Request.Builder requestBuilder = createLastOneTestsBuilder();&lt;br/&gt;
@@ -263,6 +281,9 @@ public void lastOneWins_Builder() &lt;/p&gt;
{
     assertEquals(&quot;/index.html&quot;,     request.getHttpRequest().getURI().getPath());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Copy builder with nullables.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void copyBuilderWithNullables() {&lt;br/&gt;
     RecordWithNullables.Builder builder = RecordWithNullables.newBuilder();&lt;br/&gt;
@@ -288,6 +309,9 @@ public void copyBuilderWithNullables() &lt;/p&gt;
{
     builderCopy.getNullableRecordBuilder();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Copy builder with nullables and set to null.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void copyBuilderWithNullablesAndSetToNull() {&lt;br/&gt;
     // Create builder with all values default to null, yet unset.&lt;br/&gt;
@@ -340,6 +364,9 @@ public void copyBuilderWithNullablesAndSetToNull() &lt;/p&gt;
{
     assertTrue(builder.hasNullableArray ());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets builder for record with null record.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void getBuilderForRecordWithNullRecord() {&lt;br/&gt;
     // Create a record with all nullable fields set to the default value : null&lt;br/&gt;
@@ -352,12 +379,18 @@ public void getBuilderForRecordWithNullRecord() &lt;/p&gt;
{
     builder.getNullableRecordBuilder();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets builder for null record.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void getBuilderForNullRecord() &lt;/p&gt;
{
     // In the past this caused an NPE
     RecordWithNullables.newBuilder((RecordWithNullables)null);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Gets builder for null builder.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void getBuilderForNullBuilder() {&lt;br/&gt;
     // In the past this caused an NPE&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificData.java b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificData.java&lt;br/&gt;
index de0da4ed1..1ea00c675 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificData.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificData.java&lt;br/&gt;
@@ -47,8 +47,14 @@&lt;/p&gt;

&lt;p&gt; import org.apache.avro.generic.GenericRecord;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test specific data.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSpecificData {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test hash code.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   /** Make sure that even with nulls, hashCode() doesn&apos;t throw NPE. */&lt;br/&gt;
   public void testHashCode() {&lt;br/&gt;
@@ -56,6 +62,9 @@ public void testHashCode() &lt;/p&gt;
{
     SpecificData.get().hashCode(null, TestRecord.SCHEMA$);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test to string.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   /** Make sure that even with nulls, toString() doesn&apos;t throw NPE. */&lt;br/&gt;
   public void testToString() {&lt;br/&gt;
@@ -63,14 +72,27 @@ public void testToString() {&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;   private static class X &lt;/p&gt;
{
+    /**
+     * The Map.
+     */
     public Map&amp;lt;String,String&amp;gt; map;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test get map schema.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testGetMapSchema() throws Exception &lt;/p&gt;
{
     SpecificData.get().getSchema(X.class.getField(&quot;map&quot;).getGenericType());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test specific within generic.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   /** Test nesting of specific data within generic. */&lt;br/&gt;
   public void testSpecificWithinGeneric() throws Exception {&lt;br/&gt;
@@ -102,6 +124,9 @@ public void testSpecificWithinGeneric() throws Exception &lt;/p&gt;
{
         new SpecificDatumReader&amp;lt;&amp;gt;());
 }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test convert generic to specific.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testConvertGenericToSpecific() {&lt;br/&gt;
     GenericRecord generic = new GenericData.Record(TestRecord.SCHEMA$);&lt;br/&gt;
     generic.put(&quot;name&quot;, &quot;foo&quot;);&lt;br/&gt;
@@ -112,12 +137,22 @@ public void testSpecificWithinGeneric() throws Exception &lt;/p&gt;
{
       (TestRecord)SpecificData.get().deepCopy(TestRecord.SCHEMA$, generic);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test get class schema.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testGetClassSchema() throws Exception &lt;/p&gt;
{
     Assert.assertEquals(TestRecord.getClassSchema(), TestRecord.SCHEMA$);
     Assert.assertEquals(MD5.getClassSchema(), MD5.SCHEMA$);
     Assert.assertEquals(Kind.getClassSchema(), Kind.SCHEMA$);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test specific record to string.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSpecificRecordToString() throws IOException {&lt;br/&gt;
     FooBarSpecificRecord foo = FooBarSpecificRecord.newBuilder()&lt;br/&gt;
@@ -137,6 +172,11 @@ public void testSpecificRecordToString() throws IOException &lt;/p&gt;
{
     mapper.readTree(parser);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test externalizeable.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testExternalizeable() throws Exception {&lt;br/&gt;
     TestRecord before = new TestRecord();&lt;br/&gt;
     before.setName(&quot;foo&quot;);&lt;br/&gt;
@@ -155,6 +195,11 @@ public void testSpecificRecordToString() throws IOException {&lt;/p&gt;

&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test reserved enum symbol.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test public void testReservedEnumSymbol() throws Exception {&lt;br/&gt;
     Assert.assertEquals(Reserved.default$,&lt;br/&gt;
                         SpecificData.get().createEnum(&quot;default&quot;,&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificDatumReader.java b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificDatumReader.java&lt;br/&gt;
index f1a7420c6..0226447c4 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificDatumReader.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificDatumReader.java&lt;br/&gt;
@@ -37,8 +37,18 @@&lt;/p&gt;

&lt;p&gt; import test.StringablesRecord;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test specific datum reader.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSpecificDatumReader {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Serialize record byte [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param fooBarSpecificRecord the foo bar specific record&lt;br/&gt;
+   * @return the byte [ ]&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static byte[] serializeRecord(FooBarSpecificRecord fooBarSpecificRecord) throws IOException &lt;/p&gt;
{
     SpecificDatumWriter&amp;lt;FooBarSpecificRecord&amp;gt; datumWriter =
         new SpecificDatumWriter&amp;lt;&amp;gt;(FooBarSpecificRecord.SCHEMA$);
@@ -49,6 +59,13 @@
     return byteArrayOutputStream.toByteArray();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Serialize record byte [ ].&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param stringablesRecord the stringables record&lt;br/&gt;
+   * @return the byte [ ]&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static byte[] serializeRecord(StringablesRecord stringablesRecord) throws IOException &lt;/p&gt;
{
     SpecificDatumWriter&amp;lt;StringablesRecord&amp;gt; datumWriter =
         new SpecificDatumWriter&amp;lt;&amp;gt;(StringablesRecord.SCHEMA$);
@@ -59,6 +76,11 @@
     return byteArrayOutputStream.toByteArray();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test read.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRead() throws IOException {&lt;br/&gt;
     Builder newBuilder = FooBarSpecificRecord.newBuilder();&lt;br/&gt;
@@ -78,6 +100,11 @@ public void testRead() throws IOException &lt;/p&gt;
{
     assertEquals(specificRecord, deserialized);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test stringables.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testStringables() throws IOException {&lt;br/&gt;
     StringablesRecord.Builder newBuilder = StringablesRecord.newBuilder();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificDatumWriter.java b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificDatumWriter.java&lt;br/&gt;
index a94a66692..f37d1646f 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificDatumWriter.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificDatumWriter.java&lt;br/&gt;
@@ -29,7 +29,15 @@&lt;br/&gt;
 import org.apache.avro.test.TestRecordWithUnion;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test specific datum writer.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestSpecificDatumWriter {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test resolve union.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testResolveUnion() throws IOException {&lt;br/&gt;
     final SpecificDatumWriter&amp;lt;TestRecordWithUnion&amp;gt; writer = new SpecificDatumWriter&amp;lt;&amp;gt;();&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificErrorBuilder.java b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificErrorBuilder.java&lt;br/&gt;
index 372b6d414..65f7eaae8 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificErrorBuilder.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificErrorBuilder.java&lt;br/&gt;
@@ -25,6 +25,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Unit test for the SpecificErrorBuilderBase class.&lt;br/&gt;
  */&lt;br/&gt;
 public class TestSpecificErrorBuilder {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test specific error builder.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSpecificErrorBuilder() {&lt;br/&gt;
     TestError.Builder testErrorBuilder = TestError.newBuilder().&lt;br/&gt;
@@ -67,6 +70,9 @@ public void testSpecificErrorBuilder() 
{
     Assert.assertNull(testErrorBuilder.getMessage$());
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Attempt to set non nullable field to null.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=org.apache.avro.AvroRuntimeException.class)&lt;br/&gt;
   public void attemptToSetNonNullableFieldToNull() {&lt;br/&gt;
     TestError.newBuilder().setMessage$(null);&lt;br/&gt;
diff --git a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificRecordBuilder.java b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificRecordBuilder.java&lt;br/&gt;
index 4fa6fe0b7..c6dd7b6c6 100644&lt;br/&gt;
&amp;#8212; a/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificRecordBuilder.java&lt;br/&gt;
+++ b/lang/java/ipc/src/test/java/org/apache/avro/specific/TestSpecificRecordBuilder.java&lt;br/&gt;
@@ -40,6 +40,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Unit test for the SpecificRecordBuilder class.&lt;br/&gt;
  */&lt;br/&gt;
 public class TestSpecificRecordBuilder {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test specific builder.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSpecificBuilder() {&lt;br/&gt;
     // Create a new builder, and leave some fields with default values empty:&lt;br/&gt;
@@ -92,6 +95,9 @@ public void testSpecificBuilder() 
{
     Assert.assertTrue(person2.getFriends().isEmpty());
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Test unions.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testUnions() {&lt;br/&gt;
     long datetime = 1234L;&lt;br/&gt;
@@ -116,6 +122,9 @@ public void testUnions() {&lt;/p&gt;

&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test interop.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testInterop() {&lt;br/&gt;
     Interop interop = Interop.newBuilder()&lt;br/&gt;
@@ -154,16 +163,25 @@ public void testInterop() &lt;/p&gt;
{
     Assert.assertEquals(interop, copy);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Attempt to set non nullable field to null.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=org.apache.avro.AvroRuntimeException.class)&lt;br/&gt;
   public void attemptToSetNonNullableFieldToNull() &lt;/p&gt;
{
     Person.newBuilder().setName(null);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Build without setting required fields 1.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected=org.apache.avro.AvroRuntimeException.class)&lt;br/&gt;
   public void buildWithoutSettingRequiredFields1() &lt;/p&gt;
{
     Person.newBuilder().build();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Build without setting required fields 2.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void buildWithoutSettingRequiredFields2() {&lt;br/&gt;
     // Omit required non-primitive field&lt;br/&gt;
@@ -176,6 +194,9 @@ public void buildWithoutSettingRequiredFields2() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Build without setting required fields 3.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void buildWithoutSettingRequiredFields3() {&lt;br/&gt;
     // Omit required primitive field&lt;br/&gt;
@@ -188,6 +209,9 @@ public void buildWithoutSettingRequiredFields3() {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test builder performance.&lt;br/&gt;
+   */&lt;br/&gt;
   @Ignore&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBuilderPerformance() {&lt;br/&gt;
@@ -206,6 +230,9 @@ public void testBuilderPerformance() &lt;/p&gt;
{
         &quot;ms/record&quot;);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test builder performance with default values.&lt;br/&gt;
+   */&lt;br/&gt;
   @Ignore&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBuilderPerformanceWithDefaultValues() {&lt;br/&gt;
@@ -221,6 +248,9 @@ public void testBuilderPerformanceWithDefaultValues() {         &quot;ms/record&quot;);   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test manual build performance.&lt;br/&gt;
+   */&lt;br/&gt;
   @Ignore&lt;br/&gt;
   @Test&lt;br/&gt;
   @SuppressWarnings(&quot;deprecation&quot;)&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/BinaryFragmentToJsonTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/BinaryFragmentToJsonTool.java&lt;br/&gt;
index f056252a1..5ca3d281a 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/BinaryFragmentToJsonTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/BinaryFragmentToJsonTool.java&lt;br/&gt;
@@ -35,7 +35,9 @@&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumReader;&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumWriter;&lt;/p&gt;

&lt;p&gt;-/** Converts an input file from Avro binary into JSON. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Converts an input file from Avro binary into JSON.&lt;br/&gt;
+ */&lt;br/&gt;
 public class BinaryFragmentToJsonTool implements Tool {&lt;br/&gt;
   @Override&lt;br/&gt;
   public int run(InputStream stdin, PrintStream out, PrintStream err,&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/CatTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/CatTool.java&lt;br/&gt;
index 642b56371..67c1d4c3e 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/CatTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/CatTool.java&lt;br/&gt;
@@ -38,7 +38,9 @@&lt;br/&gt;
 import org.apache.hadoop.fs.FSDataInputStream;&lt;br/&gt;
 import org.apache.hadoop.fs.Path;&lt;/p&gt;

&lt;p&gt;-/** Tool to extract samples from an Avro data file. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tool to extract samples from an Avro data file.&lt;br/&gt;
+ */&lt;br/&gt;
 public class CatTool implements Tool {&lt;/p&gt;

&lt;p&gt;   private long totalCopied;&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/CreateRandomFileTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/CreateRandomFileTool.java&lt;br/&gt;
index a42846d40..5eb7c89bd 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/CreateRandomFileTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/CreateRandomFileTool.java&lt;br/&gt;
@@ -30,7 +30,9 @@&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumWriter;&lt;br/&gt;
 import org.apache.trevni.avro.RandomData;&lt;/p&gt;

&lt;p&gt;-/** Creates a file filled with randomly-generated instances of a schema. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Creates a file filled with randomly-generated instances of a schema.&lt;br/&gt;
+ */&lt;br/&gt;
 public class CreateRandomFileTool implements Tool {&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileGetMetaTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileGetMetaTool.java&lt;br/&gt;
index aff3ffd3f..f0dda4717 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileGetMetaTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileGetMetaTool.java&lt;br/&gt;
@@ -29,7 +29,9 @@&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumReader;&lt;br/&gt;
 import org.apache.avro.mapred.FsInput;&lt;/p&gt;

&lt;p&gt;-/** Reads a data file to get its metadata. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Reads a data file to get its metadata.&lt;br/&gt;
+ */&lt;br/&gt;
 public class DataFileGetMetaTool implements Tool &lt;/p&gt;
{
 
   @Override
@@ -82,7 +84,13 @@ public int run(InputStream stdin, PrintStream out, PrintStream err,
     return 0;
   }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// escape TAB, NL and CR in keys, so that output can be reliably parsed&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Escape key string.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param key the key&lt;br/&gt;
+   * @return the string&lt;br/&gt;
+   */&lt;br/&gt;
+// escape TAB, NL and CR in keys, so that output can be reliably parsed&lt;br/&gt;
   static String escapeKey(String key) {&lt;br/&gt;
     key = key.replace(&quot;\\&quot;,&quot;\\\\&quot;);               // escape backslashes first&lt;br/&gt;
     key = key.replace(&quot;\t&quot;,&quot;&lt;br class=&quot;atl-forced-newline&quot; /&gt;t&quot;);                // TAB&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileGetSchemaTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileGetSchemaTool.java&lt;br/&gt;
index d88ebe97a..abe011d54 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileGetSchemaTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileGetSchemaTool.java&lt;br/&gt;
@@ -24,7 +24,9 @@&lt;br/&gt;
 import org.apache.avro.file.DataFileReader;&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumReader;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** Reads a data file to get its schema. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Reads a data file to get its schema.&lt;br/&gt;
+ */&lt;br/&gt;
 public class DataFileGetSchemaTool implements Tool {&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileReadTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileReadTool.java&lt;br/&gt;
index 145099d8e..20f1701eb 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileReadTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileReadTool.java&lt;br/&gt;
@@ -34,7 +34,9 @@&lt;br/&gt;
 import org.apache.avro.io.EncoderFactory;&lt;br/&gt;
 import org.apache.avro.io.JsonEncoder;&lt;/p&gt;

&lt;p&gt;-/** Reads a data file and dumps to JSON */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Reads a data file and dumps to JSON&lt;br/&gt;
+ */&lt;br/&gt;
 public class DataFileReadTool implements Tool {&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileRepairTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileRepairTool.java&lt;br/&gt;
index d3afbc954..b81b23ac3 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileRepairTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileRepairTool.java&lt;br/&gt;
@@ -33,7 +33,9 @@&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumReader;&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumWriter;&lt;/p&gt;

&lt;p&gt;-/** Recovers data from a corrupt Avro Data file */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Recovers data from a corrupt Avro Data file&lt;br/&gt;
+ */&lt;br/&gt;
 public class DataFileRepairTool implements Tool {&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileWriteTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileWriteTool.java&lt;br/&gt;
index 2d2224634..2b0ae9594 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileWriteTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/DataFileWriteTool.java&lt;br/&gt;
@@ -36,7 +36,9 @@&lt;br/&gt;
 import org.apache.avro.io.Decoder;&lt;br/&gt;
 import org.apache.avro.io.DecoderFactory;&lt;/p&gt;

&lt;p&gt;-/** Reads new-line delimited JSON records and writers an Avro data file. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Reads new-line delimited JSON records and writers an Avro data file.&lt;br/&gt;
+ */&lt;br/&gt;
 public class DataFileWriteTool implements Tool {&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/FromTextTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/FromTextTool.java&lt;br/&gt;
index b40ab2d87..379d9853a 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/FromTextTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/FromTextTool.java&lt;br/&gt;
@@ -33,10 +33,12 @@&lt;br/&gt;
 import org.apache.avro.file.DataFileWriter;&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumWriter;&lt;/p&gt;

&lt;p&gt;-/** Reads a text file into an Avro data file.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+/**&lt;br/&gt;
+ * Reads a text file into an Avro data file.&lt;br/&gt;
+ * &amp;lt;p&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Can accept a file name, and HDFS file URI, or stdin. Can write to a file&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* name, an HDFS URI, or stdout.*/&lt;br/&gt;
+ * name, an HDFS URI, or stdout.&lt;br/&gt;
+ */&lt;br/&gt;
 public class FromTextTool implements Tool {&lt;br/&gt;
   private static final String TEXT_FILE_SCHEMA =&lt;br/&gt;
     &quot;\&quot;bytes\&quot;&quot;;&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/JsonToBinaryFragmentTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/JsonToBinaryFragmentTool.java&lt;br/&gt;
index da10e0adb..d36223403 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/tools/src/main/java/org/apache/avro/tool/JsonToBinaryFragmentTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/JsonToBinaryFragmentTool.java&lt;br/&gt;
@@ -34,7 +34,9 @@&lt;br/&gt;
 import org.apache.avro.io.DecoderFactory;&lt;br/&gt;
 import org.apache.avro.io.JsonDecoder;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** Tool to convert JSON data into the binary form. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tool to convert JSON data into the binary form.&lt;br/&gt;
+ */&lt;br/&gt;
 public class JsonToBinaryFragmentTool implements Tool {&lt;br/&gt;
   @Override&lt;br/&gt;
   public int run(InputStream stdin, PrintStream out, PrintStream err,&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/Main.java b/lang/java/tools/src/main/java/org/apache/avro/tool/Main.java&lt;br/&gt;
index 962abe431..ab85783b4 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/Main.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/Main.java&lt;br/&gt;
@@ -25,15 +25,23 @@&lt;/p&gt;

&lt;p&gt; import java.io.InputStream;&lt;/p&gt;

&lt;p&gt;-/** Command-line driver.*/&lt;br/&gt;
+/**&lt;br/&gt;
+ * Command-line driver.&lt;br/&gt;
+ */&lt;br/&gt;
 public class Main {&lt;br/&gt;
   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Available tools, initialized in constructor.&lt;br/&gt;
    */&lt;br/&gt;
   final Map&amp;lt;String, Tool&amp;gt; tools;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * The Max len.&lt;br/&gt;
+   */&lt;br/&gt;
   int maxLen = 0;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Main.&lt;br/&gt;
+   */&lt;br/&gt;
   Main() {&lt;br/&gt;
     tools = new TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;
     for (Tool tool : new Tool[] &lt;/p&gt;
{
@@ -72,6 +80,12 @@
     }
&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * The entry point of application.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param args the input arguments&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public static void main(String[] args) throws Exception {&lt;br/&gt;
     int rc = new Main().run(args);&lt;br/&gt;
     System.exit(rc);&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/RecodecTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/RecodecTool.java&lt;br/&gt;
index 4ac72e746..23e5d8a5d 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/RecodecTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/RecodecTool.java&lt;br/&gt;
@@ -35,7 +35,9 @@&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumWriter;&lt;br/&gt;
 import org.apache.avro.generic.GenericRecord;&lt;/p&gt;

&lt;p&gt;-/** Tool to alter the codec of an Avro data file. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tool to alter the codec of an Avro data file.&lt;br/&gt;
+ */&lt;br/&gt;
 public class RecodecTool implements Tool {&lt;br/&gt;
   @Override&lt;br/&gt;
   public int run(InputStream in, PrintStream out, PrintStream err,&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/RpcReceiveTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/RpcReceiveTool.java&lt;br/&gt;
index 2dd36e547..aaa5bc54f 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/RpcReceiveTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/RpcReceiveTool.java&lt;br/&gt;
@@ -49,6 +49,9 @@&lt;br/&gt;
   /** Used to communicate between server thread (responder) and run() */&lt;br/&gt;
   private CountDownLatch latch;&lt;br/&gt;
   private Message expectedMessage;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Server.&lt;br/&gt;
+   */&lt;br/&gt;
   Server server;&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
@@ -63,6 +66,11 @@ public String getShortDescription() {&lt;/p&gt;

&lt;p&gt;   private class SinkResponder extends GenericResponder {&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * Instantiates a new Sink responder.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param local the local&lt;br/&gt;
+     */&lt;br/&gt;
     public SinkResponder(Protocol local) &lt;/p&gt;
{
       super(local);
     }
&lt;p&gt;@@ -114,6 +122,16 @@ public int run(InputStream in, PrintStream out, PrintStream err,&lt;br/&gt;
     return run2(err);&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Run 1 int.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param in   the in&lt;br/&gt;
+   * @param out  the out&lt;br/&gt;
+   * @param err  the err&lt;br/&gt;
+   * @param args the args&lt;br/&gt;
+   * @return the int&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   int run1(InputStream in, PrintStream out, PrintStream err,&lt;br/&gt;
       List&amp;lt;String&amp;gt; args) throws Exception &lt;/p&gt;
{
     OptionParser p = new OptionParser();
@@ -164,6 +182,13 @@ int run1(InputStream in, PrintStream out, PrintStream err,
     return 0;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Run 2 int.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param err the err&lt;br/&gt;
+   * @return the int&lt;br/&gt;
+   * @throws InterruptedException the interrupted exception&lt;br/&gt;
+   */&lt;br/&gt;
   int run2(PrintStream err) throws InterruptedException {&lt;br/&gt;
     latch.await();&lt;br/&gt;
     err.println(&quot;Closing server.&quot;);&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/SpecificCompilerTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/SpecificCompilerTool.java&lt;br/&gt;
index fc7df846d..37449f05c 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/SpecificCompilerTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/SpecificCompilerTool.java&lt;br/&gt;
@@ -36,7 +36,6 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A Tool for compiling avro protocols or schemas to Java classes using the Avro&lt;/li&gt;
	&lt;li&gt;SpecificCompiler.&lt;br/&gt;
  */&lt;br/&gt;
-&lt;br/&gt;
 public class SpecificCompilerTool implements Tool {&lt;br/&gt;
   @Override&lt;br/&gt;
   public int run(InputStream in, PrintStream out, PrintStream err,&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/TetherTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/TetherTool.java&lt;br/&gt;
index d44f054f5..8197a0834 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/tools/src/main/java/org/apache/avro/tool/TetherTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/TetherTool.java&lt;br/&gt;
@@ -40,8 +40,14 @@&lt;br/&gt;
 import org.apache.commons.cli.HelpFormatter;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;+/**&lt;br/&gt;
+ * The type Tether tool.&lt;br/&gt;
+ */&lt;br/&gt;
 @SuppressWarnings(&quot;deprecation&quot;)&lt;br/&gt;
 public class TetherTool implements Tool {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Job.&lt;br/&gt;
+   */&lt;br/&gt;
   public TetherJob job;&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/ToTextTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/ToTextTool.java&lt;br/&gt;
index 132dd7a84..48d8591ca 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/ToTextTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/ToTextTool.java&lt;br/&gt;
@@ -31,7 +31,9 @@&lt;br/&gt;
 import org.apache.avro.file.DataFileStream;&lt;br/&gt;
 import org.apache.avro.generic.GenericDatumReader;&lt;/p&gt;

&lt;p&gt;-/** Reads an avro data file into a plain text file. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Reads an avro data file into a plain text file.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ToTextTool implements Tool {&lt;br/&gt;
   private static final String TEXT_FILE_SCHEMA =&lt;br/&gt;
         &quot;\&quot;bytes\&quot;&quot;;&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/ToTrevniTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/ToTrevniTool.java&lt;br/&gt;
index 6f68645b4..09e9df478 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/ToTrevniTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/ToTrevniTool.java&lt;br/&gt;
@@ -33,7 +33,9 @@&lt;br/&gt;
 import joptsimple.OptionSpec;&lt;/p&gt;


&lt;p&gt;-/** Reads an Avro data file and writes a Trevni file. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Reads an Avro data file and writes a Trevni file.&lt;br/&gt;
+ */&lt;br/&gt;
 public class ToTrevniTool implements Tool &lt;/p&gt;
{
 
   @Override
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/Tool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/Tool.java
index cdbc11d51..2399b6cfa 100644
--- a/lang/java/tools/src/main/java/org/apache/avro/tool/Tool.java
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/Tool.java
@@ -30,9 +30,9 @@
    * Runs the tool with supplied arguments.  Input and output streams
    * are customizable for easier testing.
    *
-   * @param in Input stream to read data (typically System.in).
-   * @param out Output of tool (typically System.out).
-   * @param err Error stream (typically System.err).
+   * @param in   Input stream to read data (typically System.in).
+   * @param out  Output of tool (typically System.out).
+   * @param err  Error stream (typically System.err).
    * @param args Non-null list of arguments.
    * @return result code (0 for success)
    * @throws Exception Just like main(), tools may throw Exception.
@@ -41,11 +41,15 @@
 
   /**
    * Name of tool, to be used in listings.
+   *
+   * @return the name
    */
   String getName();
 
   /**
    * 1-line description to be used in command listings.
+   *
+   * @return the short description
    */
   String getShortDescription();
 }
&lt;p&gt;diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniCreateRandomTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniCreateRandomTool.java&lt;br/&gt;
index 67245947a..2fa72c85b 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniCreateRandomTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniCreateRandomTool.java&lt;br/&gt;
@@ -27,7 +27,9 @@&lt;br/&gt;
 import org.apache.trevni.avro.AvroColumnWriter;&lt;br/&gt;
 import org.apache.trevni.avro.RandomData;&lt;/p&gt;

&lt;p&gt;-/** Tool to create randomly populated Trevni file based on an Avro schema */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tool to create randomly populated Trevni file based on an Avro schema&lt;br/&gt;
+ */&lt;br/&gt;
 public class TrevniCreateRandomTool implements Tool {&lt;/p&gt;

&lt;p&gt;   @Override&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniMetadataTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniMetadataTool.java&lt;br/&gt;
index 87aa108a0..2ecc46dfd 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniMetadataTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniMetadataTool.java&lt;br/&gt;
@@ -33,8 +33,13 @@&lt;br/&gt;
 import org.codehaus.jackson.JsonEncoding;&lt;br/&gt;
 import org.codehaus.jackson.util.MinimalPrettyPrinter;&lt;/p&gt;

&lt;p&gt;-/** Tool to print Trevni file metadata as JSON. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tool to print Trevni file metadata as JSON.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TrevniMetadataTool implements Tool &lt;/p&gt;
{
+  /**
+   * The Factory.
+   */
   static final JsonFactory FACTORY = new JsonFactory();
 
   private JsonGenerator generator;
@@ -70,7 +75,13 @@ public int run(InputStream stdin, PrintStream out, PrintStream err,
     return 0;
   }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Read a Trevni file and print each row as a JSON object. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read a Trevni file and print each row as a JSON object.  @param input the input&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param out    the out&lt;br/&gt;
+   * @param pretty the pretty&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public void dump(Input input, PrintStream out, boolean pretty)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     this.generator = FACTORY.createJsonGenerator(out, JsonEncoding.UTF8);&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniToJsonTool.java b/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniToJsonTool.java&lt;br/&gt;
index 6c549d18c..7f1343e68 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniToJsonTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniToJsonTool.java&lt;br/&gt;
@@ -32,11 +32,15 @@&lt;br/&gt;
 import org.codehaus.jackson.JsonEncoding;&lt;br/&gt;
 import org.codehaus.jackson.util.MinimalPrettyPrinter;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** Tool to read Trevni files and print them as JSON.&lt;br/&gt;
+/**&lt;br/&gt;
+ * Tool to read Trevni files and print them as JSON.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;This can read any Trevni file.  Nested structure is reconstructed from the&lt;/li&gt;
	&lt;li&gt;columns rather than any schema information.&lt;br/&gt;
  */&lt;br/&gt;
 public class TrevniToJsonTool implements Tool 
{
+  /**
+   * The Factory.
+   */
   static final JsonFactory FACTORY = new JsonFactory();
 
   private JsonGenerator generator;
@@ -74,7 +78,13 @@ public int run(InputStream stdin, PrintStream out, PrintStream err,
     return 0;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Read a Trevni file and print each row as a JSON object. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Read a Trevni file and print each row as a JSON object.  @param input the input&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param out    the out&lt;br/&gt;
+   * @param pretty the pretty&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   public void toJson(Input input, PrintStream out, boolean pretty)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
     this.generator = FACTORY.createJsonGenerator(out, JsonEncoding.UTF8);&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniUtil.java b/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniUtil.java&lt;br/&gt;
index 0f3fce1e0..e9494fb22 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniUtil.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/TrevniUtil.java&lt;br/&gt;
@@ -35,9 +35,18 @@&lt;br/&gt;
 import org.apache.hadoop.fs.FileSystem;&lt;br/&gt;
 import org.apache.hadoop.fs.Path;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** Static utility methods for tools. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Static utility methods for tools.&lt;br/&gt;
+ */&lt;br/&gt;
 class TrevniUtil {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Input input.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param filename the filename&lt;br/&gt;
+   * @return the input&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   static Input input(String filename) throws IOException {&lt;br/&gt;
     if (filename.startsWith(&quot;hdfs://&quot;)) {&lt;br/&gt;
       return new HadoopInput(new Path(filename), new Configuration());&lt;br/&gt;
@@ -49,7 +58,11 @@ static Input input(String filename) throws IOException {&lt;br/&gt;
   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns stdin if filename is &quot;-&quot;, else opens the local or HDFS file&lt;/li&gt;
	&lt;li&gt;and returns an InputStream for it.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param filename the filename&lt;br/&gt;
+   * @param stdin    the stdin&lt;br/&gt;
+   * @return the input stream&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static InputStream input(String filename, InputStream stdin)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
@@ -66,7 +79,11 @@ else if (filename.startsWith(&quot;hdfs://&quot;)) {&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Returns stdout if filename is &quot;-&quot;, else opens the local or HDFS file&lt;/li&gt;
	&lt;li&gt;and returns an OutputStream for it.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param filename the filename&lt;br/&gt;
+   * @param stdout   the stdout&lt;br/&gt;
+   * @return the output stream&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static OutputStream output(String filename, OutputStream stdout)&lt;br/&gt;
     throws IOException {&lt;br/&gt;
diff --git a/lang/java/tools/src/main/java/org/apache/avro/tool/Util.java b/lang/java/tools/src/main/java/org/apache/avro/tool/Util.java&lt;br/&gt;
index d4904ae1c..887d4806e 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/tools/src/main/java/org/apache/avro/tool/Util.java&lt;br/&gt;
+++ b/lang/java/tools/src/main/java/org/apache/avro/tool/Util.java&lt;br/&gt;
@@ -47,14 +47,19 @@&lt;br/&gt;
 import joptsimple.OptionParser;&lt;br/&gt;
 import joptsimple.OptionSpec;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-/** Static utility methods for tools. */&lt;br/&gt;
+/**&lt;br/&gt;
+ * Static utility methods for tools.&lt;br/&gt;
+ */&lt;br/&gt;
 class Util {&lt;br/&gt;
   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Returns stdin if filename is &quot;-&quot;, else opens the File in the owning filesystem&lt;/li&gt;
	&lt;li&gt;and returns an InputStream for it.&lt;/li&gt;
	&lt;li&gt;Relative paths will be opened in the default filesystem.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param filename The filename to be opened&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @param stdin    the stdin&lt;br/&gt;
+   * @return the buffered input stream&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static BufferedInputStream fileOrStdin(String filename, InputStream stdin)&lt;br/&gt;
       throws IOException {&lt;br/&gt;
@@ -67,8 +72,11 @@ static BufferedInputStream fileOrStdin(String filename, InputStream stdin)&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Returns stdout if filename is &quot;-&quot;, else opens the file from the owning filesystem&lt;/li&gt;
	&lt;li&gt;and returns an OutputStream for it.&lt;/li&gt;
	&lt;li&gt;Relative paths will be opened in the default filesystem.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param filename The filename to be opened&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @param stdout   the stdout&lt;br/&gt;
+   * @return the buffered output stream&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static BufferedOutputStream fileOrStdout(String filename, OutputStream stdout)&lt;br/&gt;
       throws IOException {&lt;br/&gt;
@@ -80,8 +88,10 @@ static BufferedOutputStream fileOrStdout(String filename, OutputStream stdout)&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Returns an InputStream for the file using the owning filesystem,&lt;/li&gt;
	&lt;li&gt;or the default if none is given.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param filename The filename to be opened&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @return the input stream&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static InputStream openFromFS(String filename)&lt;br/&gt;
       throws IOException {&lt;br/&gt;
@@ -92,8 +102,10 @@ static InputStream openFromFS(String filename)&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Returns an InputStream for the file using the owning filesystem,&lt;/li&gt;
	&lt;li&gt;or the default if none is given.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param filename The filename to be opened&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @return the input stream&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static InputStream openFromFS(Path filename)&lt;br/&gt;
       throws IOException {&lt;br/&gt;
@@ -103,8 +115,10 @@ static InputStream openFromFS(Path filename)&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Returns a seekable FsInput using the owning filesystem,&lt;/li&gt;
	&lt;li&gt;or the default if none is given.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param filename The filename to be opened&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @return the fs input&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static FsInput openSeekableFromFS(String filename)&lt;br/&gt;
       throws IOException {&lt;br/&gt;
@@ -114,9 +128,10 @@ static FsInput openSeekableFromFS(String filename)&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Opens the file for writing in the owning filesystem,&lt;/li&gt;
	&lt;li&gt;or the default if none is given.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param filename The filename to be opened.&lt;/li&gt;
	&lt;li&gt;@return An OutputStream to the specified file.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static OutputStream createFromFS(String filename)&lt;br/&gt;
       throws IOException {&lt;br/&gt;
@@ -127,6 +142,7 @@ static OutputStream createFromFS(String filename)&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Closes the inputstream created from 
{@link Util.fileOrStdin}&lt;/li&gt;
	&lt;li&gt;unless it is System.in.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param in The inputstream to be closed.&lt;br/&gt;
    */&lt;br/&gt;
   static void close(InputStream in) {&lt;br/&gt;
@@ -142,6 +158,7 @@ static void close(InputStream in) {&lt;br/&gt;
   /**&lt;/li&gt;
	&lt;li&gt;Closes the outputstream created from 
{@link Util.fileOrStdout}&lt;/li&gt;
	&lt;li&gt;unless it is System.out.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param out The outputStream to be closed.&lt;br/&gt;
    */&lt;br/&gt;
   static void close(OutputStream out) {&lt;br/&gt;
@@ -156,9 +173,10 @@ static void close(OutputStream out) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Parses a schema from the specified file.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param filename The file name to parse&lt;/li&gt;
	&lt;li&gt;@return The parsed schema&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static Schema parseSchemaFromFS(String filename) throws IOException {&lt;br/&gt;
     InputStream stream = openFromFS(filename);&lt;br/&gt;
@@ -175,11 +193,12 @@ static Schema parseSchemaFromFS(String filename) throws IOException {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;this directory. Only files inside that directory are included, no subdirectories or files&lt;/li&gt;
	&lt;li&gt;in subdirectories will be added.&lt;/li&gt;
	&lt;li&gt;If pathname is a glob pattern, all files matching the pattern are included.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+   * &amp;lt;p&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;The List is sorted alphabetically.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param fileOrDirName filename, directoryname or a glob pattern&lt;/li&gt;
	&lt;li&gt;@return A Path List&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static List&amp;lt;Path&amp;gt; getFiles(String fileOrDirName) throws IOException {&lt;br/&gt;
     List&amp;lt;Path&amp;gt; pathList = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -211,11 +230,12 @@ static Schema parseSchemaFromFS(String filename) throws IOException {&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Concatenate the result of 
{@link #getFiles(String)}
&lt;p&gt; applied to all file or directory names.&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;The list is sorted alphabetically and contains no subdirectories or files within those.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+   * &amp;lt;p&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;The list is sorted alphabetically.&lt;br/&gt;
+   *&lt;/li&gt;
	&lt;li&gt;@param fileOrDirNames A list of filenames, directorynames or glob patterns&lt;/li&gt;
	&lt;li&gt;@return A list of Paths, one for each file&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @throws IOException&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static List&amp;lt;Path&amp;gt; getFiles(List&amp;lt;String&amp;gt; fileOrDirNames)&lt;br/&gt;
       throws IOException {&lt;br/&gt;
@@ -229,9 +249,14 @@ static Schema parseSchemaFromFS(String filename) throws IOException {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Converts a String JSON object into a generic datum.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+   * &amp;lt;p&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;This is inefficient (creates extra objects), so should be used&lt;/li&gt;
	&lt;li&gt;sparingly.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param schema   the schema&lt;br/&gt;
+   * @param jsonData the json data&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
    */&lt;br/&gt;
   static Object jsonToGenericDatum(Schema schema, String jsonData)&lt;br/&gt;
       throws IOException 
{
@@ -241,7 +266,13 @@ static Object jsonToGenericDatum(Schema schema, String jsonData)
     return datum;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** Reads and returns the first datum in a data file. */&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Reads and returns the first datum in a data file.  @param schema the schema&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param file the file&lt;br/&gt;
+   * @return the object&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   static Object datumFromFile(Schema schema, String file) throws IOException {&lt;br/&gt;
     DataFileReader&amp;lt;Object&amp;gt; in =&lt;br/&gt;
         new DataFileReader&amp;lt;&amp;gt;(new File(file),&lt;br/&gt;
@@ -253,6 +284,12 @@ static Object datumFromFile(Schema schema, String file) throws IOException {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Compression codec option option spec.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param optParser the opt parser&lt;br/&gt;
+   * @return the option spec&lt;br/&gt;
+   */&lt;br/&gt;
   static OptionSpec&amp;lt;String&amp;gt; compressionCodecOption(OptionParser optParser) {&lt;br/&gt;
     return optParser&lt;br/&gt;
       .accepts(&quot;codec&quot;, &quot;Compression codec&quot;)&lt;br/&gt;
@@ -261,6 +298,12 @@ static Object datumFromFile(Schema schema, String file) throws IOException &lt;/p&gt;
{
       .defaultsTo(&quot;null&quot;);
 }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Compression level option option spec.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param optParser the opt parser&lt;br/&gt;
+   * @return the option spec&lt;br/&gt;
+   */&lt;br/&gt;
   static OptionSpec&amp;lt;Integer&amp;gt; compressionLevelOption(OptionParser optParser) {&lt;br/&gt;
     return optParser&lt;br/&gt;
       .accepts(&quot;level&quot;, &quot;Compression level (only applies to deflate and xz)&quot;)&lt;br/&gt;
@@ -269,10 +312,27 @@ static Object datumFromFile(Schema schema, String file) throws IOException &lt;/p&gt;
{
       .defaultsTo(Deflater.DEFAULT_COMPRESSION);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Codec factory codec factory.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param opts  the opts&lt;br/&gt;
+   * @param codec the codec&lt;br/&gt;
+   * @param level the level&lt;br/&gt;
+   * @return the codec factory&lt;br/&gt;
+   */&lt;br/&gt;
   static CodecFactory codecFactory(OptionSet opts, OptionSpec&amp;lt;String&amp;gt; codec, OptionSpec&amp;lt;Integer&amp;gt; level) &lt;/p&gt;
{
     return codecFactory(opts, codec, level, DEFLATE_CODEC);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Codec factory codec factory.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param opts         the opts&lt;br/&gt;
+   * @param codec        the codec&lt;br/&gt;
+   * @param level        the level&lt;br/&gt;
+   * @param defaultCodec the default codec&lt;br/&gt;
+   * @return the codec factory&lt;br/&gt;
+   */&lt;br/&gt;
   static CodecFactory codecFactory(OptionSet opts, OptionSpec&amp;lt;String&amp;gt; codec, OptionSpec&amp;lt;Integer&amp;gt; level, String defaultCodec) {&lt;br/&gt;
       String codecName = opts.hasArgument(codec)&lt;br/&gt;
         ? codec.value(opts)&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestCatTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestCatTool.java&lt;br/&gt;
index cfc38c990..c67a373be 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestCatTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestCatTool.java&lt;br/&gt;
@@ -45,6 +45,9 @@&lt;br/&gt;
 import org.apache.avro.generic.GenericRecord;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test cat tool.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestCatTool {&lt;br/&gt;
   private static final int ROWS_IN_INPUT_FILES = 100000;&lt;br/&gt;
   private static final int OFFSET = 1000;&lt;br/&gt;
@@ -137,6 +140,11 @@ private int numRowsInFile(File output) throws Exception &lt;/p&gt;
{
     return rowcount;
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test cat.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testCat() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -197,6 +205,11 @@ public void testCat() throws Exception {&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test limit out of bounds.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testLimitOutOfBounds() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -220,6 +233,11 @@ public void testLimitOutOfBounds() throws Exception {
     assertEquals(ROWS_IN_INPUT_FILES - OFFSET, numRowsInFile(output));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test samplerate accuracy.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSamplerateAccuracy() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -246,6 +264,11 @@ public void testSamplerateAccuracy() throws Exception {
     assertTrue(&quot;&quot;, (ROWS_IN_INPUT_FILES - OFFSET)*SAMPLERATE - numRowsInFile(output) &amp;gt; -2);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test off set accuracy.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testOffSetAccuracy() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -271,6 +294,11 @@ public void testOffSetAccuracy() throws Exception {
       OFFSET, getFirstIntDatum(output));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test offset bigger than input.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testOffsetBiggerThanInput() throws Exception{&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -294,6 +322,11 @@ public void testOffsetBiggerThanInput() throws Exception{
       0, numRowsInFile(output));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test samplerate smaller than input.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSamplerateSmallerThanInput() throws Exception{&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -320,6 +353,11 @@ public void testSamplerateSmallerThanInput() throws Exception{&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test different schemas fail.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected = IOException.class)&lt;br/&gt;
   public void testDifferentSchemasFail() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -342,6 +380,11 @@ public void testDifferentSchemasFail() throws Exception {
       args);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test helpful message when no args given.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testHelpfulMessageWhenNoArgsGiven() throws Exception {&lt;br/&gt;
     ByteArrayOutputStream buffer = new ByteArrayOutputStream(1024);&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestConcatTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestConcatTool.java&lt;br/&gt;
index 777d83ed7..743914b3d 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestConcatTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestConcatTool.java&lt;br/&gt;
@@ -46,6 +46,9 @@&lt;br/&gt;
 import org.apache.avro.generic.GenericRecord;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 &lt;br/&gt;
+/**&lt;br/&gt;
+ * The type Test concat tool.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestConcatTool {&lt;br/&gt;
   private static final int ROWS_IN_INPUT_FILES = 100000;&lt;br/&gt;
   private static final CodecFactory DEFLATE = CodecFactory.deflateCodec(9);&lt;br/&gt;
@@ -108,6 +111,11 @@ private int numRowsInFile(File output) throws Exception {     return rowcount;   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test dir concat.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testDirConcat() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -137,6 +145,11 @@ public void testDirConcat() throws Exception &lt;/p&gt;
{
     assertEquals(ROWS_IN_INPUT_FILES * 3, numRowsInFile(output));
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test glob pattern concat.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testGlobPatternConcat() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -166,6 +179,11 @@ public void testGlobPatternConcat() throws Exception {     assertEquals(ROWS_IN_INPUT_FILES * 3, numRowsInFile(output));   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test file does not exist.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test(expected = FileNotFoundException.class)&lt;br/&gt;
   public void testFileDoesNotExist() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -185,6 +203,11 @@ public void testFileDoesNotExist() throws Exception &lt;/p&gt;
{
       args);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test concat.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testConcat() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -213,6 +236,11 @@ public void testConcat() throws Exception &lt;/p&gt;
{
     assertEquals(getCodec(input1).getClass(), getCodec(output).getClass());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test different schemas fail.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testDifferentSchemasFail() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -236,6 +264,11 @@ public void testDifferentSchemasFail() throws Exception &lt;/p&gt;
{
     assertEquals(1, returnCode);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test different metadata fail.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testDifferentMetadataFail() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata1 = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -261,6 +294,11 @@ public void testDifferentMetadataFail() throws Exception &lt;/p&gt;
{
     assertEquals(2, returnCode);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test different codec fail.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testDifferentCodecFail() throws Exception {&lt;br/&gt;
     Map&amp;lt;String, String&amp;gt; metadata = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -284,6 +322,11 @@ public void testDifferentCodecFail() throws Exception &lt;/p&gt;
{
     assertEquals(3, returnCode);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test helpful message when no args given.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testHelpfulMessageWhenNoArgsGiven() throws Exception {&lt;br/&gt;
     ByteArrayOutputStream buffer = new ByteArrayOutputStream(1024);&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestCreateRandomFileTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestCreateRandomFileTool.java&lt;br/&gt;
index d47eedd84..6a7afdc39 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestCreateRandomFileTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestCreateRandomFileTool.java&lt;br/&gt;
@@ -39,6 +39,9 @@&lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test create random file tool.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestCreateRandomFileTool {&lt;br/&gt;
   private static final String COUNT = System.getProperty(&quot;test.count&quot;, &quot;200&quot;);&lt;br/&gt;
   private static final File DIR&lt;br/&gt;
@@ -52,12 +55,20 @@&lt;br/&gt;
   private ByteArrayOutputStream out;&lt;br/&gt;
   private ByteArrayOutputStream err;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Before.&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void before() &lt;/p&gt;
{
     out = new ByteArrayOutputStream();
     err = new ByteArrayOutputStream();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * After.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @After&lt;br/&gt;
   public void after() throws Exception {&lt;br/&gt;
     out.close();&lt;br/&gt;
@@ -111,21 +122,41 @@ private void checkMissingCount(String... extraArgs) throws Exception &lt;/p&gt;
{
     assertTrue(err.toString().contains(&quot;Need count (--count)&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test simple.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSimple() throws Exception &lt;/p&gt;
{
     check();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test codec.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testCodec() throws Exception &lt;/p&gt;
{
     check(&quot;--codec&quot;, &quot;snappy&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test missing count parameter.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testMissingCountParameter() throws Exception &lt;/p&gt;
{
     checkMissingCount();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test std out.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testStdOut() throws Exception {&lt;br/&gt;
     TestUtil.resetRandomSeed();&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestDataFileRepairTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestDataFileRepairTool.java&lt;br/&gt;
index 2a4ed492f..43d147969 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestDataFileRepairTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestDataFileRepairTool.java&lt;br/&gt;
@@ -42,6 +42,9 @@&lt;br/&gt;
 import static org.junit.Assert.assertFalse;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test data file repair tool.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestDataFileRepairTool {&lt;/p&gt;

&lt;p&gt;   private static final Schema SCHEMA = Schema.create(Schema.Type.STRING);&lt;br/&gt;
@@ -50,6 +53,11 @@&lt;/p&gt;

&lt;p&gt;   private File repairedFile;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Write corrupt file.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @BeforeClass&lt;br/&gt;
   public static void writeCorruptFile() throws IOException {&lt;br/&gt;
     // Write a data file&lt;br/&gt;
@@ -100,11 +108,17 @@ public static void writeCorruptFile() throws IOException &lt;/p&gt;
{
     out.close();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Sets up.&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void setUp() &lt;/p&gt;
{
     repairedFile = AvroTestUtil.tempFile(TestDataFileRepairTool.class, &quot;repaired.avro&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Tear down.&lt;br/&gt;
+   */&lt;br/&gt;
   @After&lt;br/&gt;
   public void tearDown() &lt;/p&gt;
{
     repairedFile.delete();
@@ -125,6 +139,11 @@ private String run(Tool tool, InputStream stdin, String... args) throws Exceptio
     return out.toString(&quot;UTF-8&quot;).replace(&quot;\r&quot;, &quot;&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test report corrupt block.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testReportCorruptBlock() throws Exception {&lt;br/&gt;
     String output = run(new DataFileRepairTool(), &quot;-o&quot;, &quot;report&quot;, corruptBlockFile.getPath());&lt;br/&gt;
@@ -132,6 +151,11 @@ public void testReportCorruptBlock() throws Exception &lt;/p&gt;
{
     assertTrue(output, output.contains(&quot;Number of records: 5 Number of corrupt records: 0&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test report corrupt record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testReportCorruptRecord() throws Exception {&lt;br/&gt;
     String output = run(new DataFileRepairTool(), &quot;-o&quot;, &quot;report&quot;, corruptRecordFile.getPath());&lt;br/&gt;
@@ -139,6 +163,11 @@ public void testReportCorruptRecord() throws Exception &lt;/p&gt;
{
     assertTrue(output, output.contains(&quot;Number of records: 8 Number of corrupt records: 2&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test repair all corrupt block.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRepairAllCorruptBlock() throws Exception {&lt;br/&gt;
     String output = run(new DataFileRepairTool(), &quot;-o&quot;, &quot;all&quot;,&lt;br/&gt;
@@ -148,6 +177,11 @@ public void testRepairAllCorruptBlock() throws Exception &lt;/p&gt;
{
     checkFileContains(repairedFile, &quot;apple&quot;, &quot;banana&quot;, &quot;celery&quot;, &quot;guava&quot;, &quot;hazelnut&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test repair all corrupt record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRepairAllCorruptRecord() throws Exception {&lt;br/&gt;
     String output = run(new DataFileRepairTool(), &quot;-o&quot;, &quot;all&quot;,&lt;br/&gt;
@@ -158,6 +192,11 @@ public void testRepairAllCorruptRecord() throws Exception &lt;/p&gt;
{
         &quot;hazelnut&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test repair prior corrupt block.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRepairPriorCorruptBlock() throws Exception {&lt;br/&gt;
     String output = run(new DataFileRepairTool(), &quot;-o&quot;, &quot;prior&quot;,&lt;br/&gt;
@@ -167,6 +206,11 @@ public void testRepairPriorCorruptBlock() throws Exception &lt;/p&gt;
{
     checkFileContains(repairedFile, &quot;apple&quot;, &quot;banana&quot;, &quot;celery&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test repair prior corrupt record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRepairPriorCorruptRecord() throws Exception {&lt;br/&gt;
     String output = run(new DataFileRepairTool(), &quot;-o&quot;, &quot;prior&quot;,&lt;br/&gt;
@@ -176,6 +220,11 @@ public void testRepairPriorCorruptRecord() throws Exception &lt;/p&gt;
{
     checkFileContains(repairedFile, &quot;apple&quot;, &quot;banana&quot;, &quot;celery&quot;, &quot;date&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test repair after corrupt block.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRepairAfterCorruptBlock() throws Exception {&lt;br/&gt;
     String output = run(new DataFileRepairTool(), &quot;-o&quot;, &quot;after&quot;,&lt;br/&gt;
@@ -185,6 +234,11 @@ public void testRepairAfterCorruptBlock() throws Exception &lt;/p&gt;
{
     checkFileContains(repairedFile, &quot;guava&quot;, &quot;hazelnut&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test repair after corrupt record.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRepairAfterCorruptRecord() throws Exception {&lt;br/&gt;
     String output = run(new DataFileRepairTool(), &quot;-o&quot;, &quot;after&quot;,&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestDataFileTools.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestDataFileTools.java&lt;br/&gt;
index cab28d42c..50805ba98 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestDataFileTools.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestDataFileTools.java&lt;br/&gt;
@@ -45,17 +45,40 @@&lt;br/&gt;
 import org.junit.BeforeClass;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test data file tools.&lt;br/&gt;
+ */&lt;br/&gt;
 @SuppressWarnings(&quot;deprecation&quot;)&lt;br/&gt;
 public class TestDataFileTools {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Count.&lt;br/&gt;
+   */&lt;br/&gt;
   static final int COUNT = 10;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Sample file.&lt;br/&gt;
+   */&lt;br/&gt;
   static File sampleFile;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Json data.&lt;br/&gt;
+   */&lt;br/&gt;
   static String jsonData;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Schema.&lt;br/&gt;
+   */&lt;br/&gt;
   static Schema schema;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Schema file.&lt;br/&gt;
+   */&lt;br/&gt;
   static File schemaFile;&lt;/p&gt;

&lt;p&gt;   private static final String KEY_NEEDING_ESCAPES = &quot;trn\\\r\t\n&quot;;&lt;br/&gt;
   private static final String ESCAPED_KEY = &quot;trn\\\\\\r\\t&lt;br class=&quot;atl-forced-newline&quot; /&gt;n&quot;;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Write sample file.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @BeforeClass&lt;br/&gt;
   public static void writeSampleFile() throws IOException &lt;/p&gt;
{
     sampleFile = AvroTestUtil.tempFile(TestDataFileTools.class,
@@ -99,24 +122,44 @@ private String run(Tool tool, InputStream stdin, String... args) throws Exceptio
     return baos.toString(&quot;UTF-8&quot;).replace(&quot;\r&quot;, &quot;&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test read.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRead() throws Exception &lt;/p&gt;
{
     assertEquals(jsonData,
         run(new DataFileReadTool(), sampleFile.getPath()));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test read stdin.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testReadStdin() throws Exception &lt;/p&gt;
{
     FileInputStream stdin = new FileInputStream(sampleFile);
     assertEquals(jsonData, run(new DataFileReadTool(), stdin, &quot;-&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test read to json pretty.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testReadToJsonPretty() throws Exception &lt;/p&gt;
{
     assertEquals(jsonData,
         run(new DataFileReadTool(), &quot;--pretty&quot;, sampleFile.getPath()));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test get meta.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testGetMeta() throws Exception {&lt;br/&gt;
     String output = run(new DataFileGetMetaTool(), sampleFile.getPath());&lt;br/&gt;
@@ -124,6 +167,11 @@ public void testGetMeta() throws Exception &lt;/p&gt;
{
     assertTrue(output, output.contains(ESCAPED_KEY+&quot;\t\n&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test get meta for single key.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testGetMetaForSingleKey() throws Exception {&lt;br/&gt;
     assertEquals(schema.toString() + &quot;\n&quot;,&lt;br/&gt;
@@ -131,27 +179,60 @@ public void testGetMetaForSingleKey() throws Exception &lt;/p&gt;
{
             &quot;avro.schema&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test get schema.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testGetSchema() throws Exception &lt;/p&gt;
{
     assertEquals(schema.toString() + &quot;\n&quot;,
         run(new DataFileGetSchemaTool(), sampleFile.getPath()));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test write with deflate.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testWriteWithDeflate() throws Exception &lt;/p&gt;
{
     testWrite(&quot;deflate&quot;, Arrays.asList(&quot;--codec&quot;, &quot;deflate&quot;), &quot;deflate&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test write.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testWrite() throws Exception &lt;/p&gt;
{
     testWrite(&quot;plain&quot;, Collections.emptyList(), &quot;null&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test write.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name          the name&lt;br/&gt;
+   * @param extra         the extra&lt;br/&gt;
+   * @param expectedCodec the expected codec&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public void testWrite(String name, List&amp;lt;String&amp;gt; extra, String expectedCodec)&lt;br/&gt;
       throws Exception &lt;/p&gt;
{
       testWrite(name, extra, expectedCodec, &quot;-schema&quot;, schema.toString());
       testWrite(name, extra, expectedCodec, &quot;-schema-file&quot;, schemaFile.toString());
   }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test write.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param name          the name&lt;br/&gt;
+   * @param extra         the extra&lt;br/&gt;
+   * @param expectedCodec the expected codec&lt;br/&gt;
+   * @param extraArgs     the extra args&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public void testWrite(String name, List&amp;lt;String&amp;gt; extra, String expectedCodec, String... extraArgs)&lt;br/&gt;
   throws Exception &lt;/p&gt;
{
     File outFile = AvroTestUtil.tempFile(getClass(),
@@ -189,6 +270,11 @@ public void testWrite(String name, List&amp;lt;String&amp;gt; extra, String expectedCodec, Str
     assertEquals(expectedCodec, codecStr);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test failure on writing partial json values.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFailureOnWritingPartialJSONValues() throws Exception {&lt;br/&gt;
     ByteArrayOutputStream baos = new ByteArrayOutputStream();&lt;br/&gt;
@@ -207,6 +293,11 @@ public void testFailureOnWritingPartialJSONValues() throws Exception {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test writing zero json values.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testWritingZeroJsonValues() throws Exception {&lt;br/&gt;
     File outFile = writeToAvroFile(&quot;zerojsonvalues&quot;,&lt;br/&gt;
@@ -226,6 +317,11 @@ private int countRecords(File outFile) throws IOException &lt;/p&gt;
{
     return i;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test different separators between json records.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testDifferentSeparatorsBetweenJsonRecords() throws Exception {&lt;br/&gt;
     File outFile = writeToAvroFile(&lt;br/&gt;
@@ -235,6 +331,15 @@ public void testDifferentSeparatorsBetweenJsonRecords() throws Exception &lt;/p&gt;
{
     assertEquals(5, countRecords(outFile));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Write to avro file file.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param testName the test name&lt;br/&gt;
+   * @param schema   the schema&lt;br/&gt;
+   * @param json     the json&lt;br/&gt;
+   * @return the file&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   public File writeToAvroFile(String testName, String schema, String json) throws Exception {&lt;br/&gt;
     File outFile = AvroTestUtil.tempFile(getClass(),&lt;br/&gt;
         TestDataFileTools.class + &quot;.&quot; + testName + &quot;.avro&quot;);&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestIdlToSchemataTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestIdlToSchemataTool.java&lt;br/&gt;
index a749d900a..1a870c477 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestIdlToSchemataTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestIdlToSchemataTool.java&lt;br/&gt;
@@ -25,8 +25,16 @@&lt;/p&gt;

&lt;p&gt; import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test idl to schemata tool.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestIdlToSchemataTool {&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test split idl into schemata.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testSplitIdlIntoSchemata() throws Exception {&lt;br/&gt;
     String idl = &quot;src/test/idl/protocol.avdl&quot;;&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestJsonToFromBinaryFragmentTools.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestJsonToFromBinaryFragmentTools.java&lt;br/&gt;
index 849968788..c3cf29bd3 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestJsonToFromBinaryFragmentTools.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestJsonToFromBinaryFragmentTools.java&lt;br/&gt;
@@ -47,41 +47,81 @@&lt;br/&gt;
   private static final String JSON =&lt;br/&gt;
     &quot;\&quot;Long string implies readable length encoding.\&quot;\n&quot;;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test binary to json.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBinaryToJson() throws Exception &lt;/p&gt;
{
     binaryToJson(AVRO, JSON, STRING_SCHEMA);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test json to binary.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
     public void testJsonToBinary() throws Exception &lt;/p&gt;
{
     jsonToBinary(JSON, AVRO, STRING_SCHEMA);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test multi binary to json.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
     public void testMultiBinaryToJson() throws Exception &lt;/p&gt;
{
     binaryToJson(AVRO + AVRO + AVRO, JSON + JSON + JSON, STRING_SCHEMA);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test multi json to binary.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
     public void testMultiJsonToBinary() throws Exception &lt;/p&gt;
{
     jsonToBinary(JSON + JSON + JSON, AVRO + AVRO + AVRO, STRING_SCHEMA);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test binary to no pretty json.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBinaryToNoPrettyJson() throws Exception &lt;/p&gt;
{
     binaryToJson(AVRO, JSON, &quot;--no-pretty&quot;, STRING_SCHEMA);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test multi binary to no pretty json.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
     public void testMultiBinaryToNoPrettyJson() throws Exception &lt;/p&gt;
{
     binaryToJson(AVRO + AVRO + AVRO, JSON + JSON + JSON, &quot;--no-pretty&quot;, STRING_SCHEMA);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test binary to json schema file.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testBinaryToJsonSchemaFile() throws Exception &lt;/p&gt;
{
     binaryToJson(AVRO, JSON, &quot;--schema-file&quot;, schemaFile());
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test json to binary schema file.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
     public void testJsonToBinarySchemaFile() throws Exception {&lt;br/&gt;
     jsonToBinary(JSON, AVRO, &quot;--schema-file&quot;, schemaFile());&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestMain.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestMain.java&lt;br/&gt;
index 5a2acc008..ddf691c7f 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestMain.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestMain.java&lt;br/&gt;
@@ -21,7 +21,13 @@&lt;/p&gt;

&lt;p&gt; import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test main.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestMain {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test tool description length.&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   /** Make sure that tool descriptions fit in 80 characters. */&lt;br/&gt;
   public void testToolDescriptionLength() {&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestRecodecTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestRecodecTool.java&lt;br/&gt;
index 894bc206e..1337e13c1 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestRecodecTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestRecodecTool.java&lt;br/&gt;
@@ -34,7 +34,15 @@&lt;br/&gt;
 import org.junit.Assert;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test recodec tool.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestRecodecTool {&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test recodec.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRecodec() throws Exception {&lt;br/&gt;
     String metaKey = &quot;myMetaKey&quot;;&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestRpcProtocolTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestRpcProtocolTool.java&lt;br/&gt;
index 2991505b0..376fde34b 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestRpcProtocolTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestRpcProtocolTool.java&lt;br/&gt;
@@ -33,11 +33,16 @@&lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+ * The type Test rpc protocol tool.&lt;br/&gt;
  */&lt;br/&gt;
 @RunWith(Parameterized.class)&lt;br/&gt;
 public class TestRpcProtocolTool {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Data list.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @return the list&lt;br/&gt;
+   */&lt;br/&gt;
   @Parameterized.Parameters(/*name = &quot;&lt;/p&gt;
{0}
&lt;p&gt;&quot;*/)&lt;br/&gt;
   public static List&amp;lt;Object[]&amp;gt; data() {&lt;br/&gt;
     return Arrays.asList( new Object[]&lt;/p&gt;
{&quot;http&quot;}
&lt;p&gt;,&lt;br/&gt;
@@ -49,10 +54,20 @@&lt;/p&gt;

&lt;p&gt;   private String uriScheme ;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Instantiates a new Test rpc protocol tool.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @param uriScheme the uri scheme&lt;br/&gt;
+   */&lt;br/&gt;
   public TestRpcProtocolTool(String uriScheme) &lt;/p&gt;
{
     this.uriScheme = uriScheme;
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Sets up.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void setUp() throws Exception {&lt;br/&gt;
     String protocolFile =&lt;br/&gt;
@@ -70,12 +85,22 @@ public void setUp() throws Exception &lt;/p&gt;
{
             &quot;-data&quot;, &quot;\&quot;Hello!\&quot;&quot;));
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Tear down.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @After&lt;br/&gt;
   public void tearDown() throws Exception &lt;/p&gt;
{
     if( receive != null )
       receive.server.close(); // force the server to finish
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test rpc protocol.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testRpcProtocol() throws Exception {&lt;/p&gt;

&lt;p&gt;diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestRpcReceiveAndSendTools.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestRpcReceiveAndSendTools.java&lt;br/&gt;
index d642dfbda..c681358d0 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestRpcReceiveAndSendTools.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestRpcReceiveAndSendTools.java&lt;br/&gt;
@@ -26,10 +26,15 @@&lt;/p&gt;

&lt;p&gt; import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test rpc receive and send tools.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestRpcReceiveAndSendTools {&lt;/p&gt;

&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Starts a server (using the tool) and sends a single message to it.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
    */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testServeAndSend() throws Exception {&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestSpecificCompilerTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestSpecificCompilerTool.java&lt;br/&gt;
index 1f9a25617..fd63e9308 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/tools/src/test/java/org/apache/avro/tool/TestSpecificCompilerTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestSpecificCompilerTool.java&lt;br/&gt;
@@ -73,11 +73,19 @@&lt;br/&gt;
   private static final File TEST_OUTPUT_STRING_POSITION =&lt;br/&gt;
     new File(TEST_OUTPUT_STRING_DIR, &quot;avro/examples/baseball/Position.java&quot;);&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  /**&lt;br/&gt;
+   * Sets up.&lt;br/&gt;
+   */&lt;br/&gt;
   @Before&lt;br/&gt;
   public void setUp() &lt;/p&gt;
{
     TEST_OUTPUT_DIR.delete();
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test compile schema single file.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testCompileSchemaSingleFile() throws Exception {&lt;/p&gt;

&lt;p&gt;@@ -87,6 +95,11 @@ public void testCompileSchemaSingleFile() throws Exception &lt;/p&gt;
{
     assertFileMatch(TEST_EXPECTED_POSITION, TEST_OUTPUT_POSITION);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test compile schema two files.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testCompileSchemaTwoFiles() throws Exception {&lt;/p&gt;

&lt;p&gt;@@ -98,6 +111,11 @@ public void testCompileSchemaTwoFiles() throws Exception &lt;/p&gt;
{
     assertFileMatch(TEST_EXPECTED_PLAYER,   TEST_OUTPUT_PLAYER);
   }&lt;br/&gt;
 &lt;br/&gt;
+  /**&lt;br/&gt;
+   * Test compile schema file and directory.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testCompileSchemaFileAndDirectory() throws Exception {&lt;br/&gt;
 &lt;br/&gt;
@@ -109,6 +127,11 @@ public void testCompileSchemaFileAndDirectory() throws Exception {     assertFileMatch(TEST_EXPECTED_PLAYER,   TEST_OUTPUT_PLAYER);   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test compile schemas using string.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testCompileSchemasUsingString() throws Exception {&lt;/p&gt;

&lt;p&gt;diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestTetherTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestTetherTool.java&lt;br/&gt;
index 118ccf772..c56d8f2bb 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestTetherTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestTetherTool.java&lt;br/&gt;
@@ -40,13 +40,18 @@&lt;br/&gt;
 import org.apache.hadoop.mapred.JobConf;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test tether tool.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestTetherTool {&lt;/p&gt;

&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Test that the tether tool works with the mapreduce example&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
+   * &amp;lt;p&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;TODO: How can we ensure that when we run, the WordCountTether example has&lt;/li&gt;
	&lt;li&gt;been properly compiled?&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
    */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void test() throws Exception {&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestTextFileTools.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestTextFileTools.java&lt;br/&gt;
index 9d1615cab..bf4a7a571 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/lang/java/tools/src/test/java/org/apache/avro/tool/TestTextFileTools.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestTextFileTools.java&lt;br/&gt;
@@ -41,17 +41,37 @@&lt;br/&gt;
 import org.junit.AfterClass;&lt;br/&gt;
 import org.junit.Test;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test text file tools.&lt;br/&gt;
+ */&lt;br/&gt;
 @SuppressWarnings(&quot;deprecation&quot;)&lt;br/&gt;
 public class TestTextFileTools {&lt;br/&gt;
   private static final int COUNT =&lt;br/&gt;
     Integer.parseInt(System.getProperty(&quot;test.count&quot;, &quot;10&quot;));&lt;/p&gt;

&lt;p&gt;   private static final byte[] LINE_SEP = System.getProperty(&quot;line.separator&quot;).getBytes();&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Lines file.&lt;br/&gt;
+   */&lt;br/&gt;
   static File linesFile;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Lines.&lt;br/&gt;
+   */&lt;br/&gt;
   static ByteBuffer[] lines;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Schema.&lt;br/&gt;
+   */&lt;br/&gt;
   static Schema schema;&lt;br/&gt;
+  /**&lt;br/&gt;
+   * The Schema file.&lt;br/&gt;
+   */&lt;br/&gt;
   static File schemaFile;&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+   * Write random file.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws IOException the io exception&lt;br/&gt;
+   */&lt;br/&gt;
   @BeforeClass&lt;br/&gt;
   public static void writeRandomFile() throws IOException {&lt;br/&gt;
     schema = Schema.create(Type.BYTES);&lt;br/&gt;
@@ -99,6 +119,11 @@ private void fromText(String name, String... args) throws Exception &lt;/p&gt;
{
     assertEquals(COUNT, i);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test from text.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void testFromText() throws Exception {&lt;br/&gt;
     fromText(&quot;null&quot;, &quot;--codec&quot;, &quot;null&quot;);&lt;br/&gt;
@@ -106,6 +131,11 @@ public void testFromText() throws Exception &lt;/p&gt;
{
     fromText(&quot;snappy&quot;, &quot;--codec&quot;, &quot;snappy&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test to text.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @AfterClass&lt;br/&gt;
   public static void testToText() throws Exception {&lt;br/&gt;
     toText(&quot;null&quot;);&lt;br/&gt;
diff --git a/lang/java/tools/src/test/java/org/apache/avro/tool/TestToTrevniTool.java b/lang/java/tools/src/test/java/org/apache/avro/tool/TestToTrevniTool.java&lt;br/&gt;
index 663c6c819..54a8edce2 100644&lt;br/&gt;
&amp;#8212; a/lang/java/tools/src/test/java/org/apache/avro/tool/TestToTrevniTool.java&lt;br/&gt;
+++ b/lang/java/tools/src/test/java/org/apache/avro/tool/TestToTrevniTool.java&lt;br/&gt;
@@ -32,6 +32,9 @@&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;/p&gt;

&lt;p&gt;+/**&lt;br/&gt;
+ * The type Test to trevni tool.&lt;br/&gt;
+ */&lt;br/&gt;
 public class TestToTrevniTool {&lt;br/&gt;
   private static final int COUNT =&lt;br/&gt;
     Integer.parseInt(System.getProperty(&quot;test.count&quot;, &quot;200&quot;));&lt;br/&gt;
@@ -49,6 +52,11 @@ private String run(String... args) throws Exception &lt;/p&gt;
{
     return baos.toString(&quot;UTF-8&quot;).replace(&quot;\r&quot;, &quot;&quot;);
   }

&lt;p&gt;+  /**&lt;br/&gt;
+   * Test.&lt;br/&gt;
+   *&lt;br/&gt;
+   * @throws Exception the exception&lt;br/&gt;
+   */&lt;br/&gt;
   @Test&lt;br/&gt;
   public void test() throws Exception {&lt;br/&gt;
     Schema schema = Schema.parse(SCHEMA_FILE);&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 26 Sep 2018 02:26:00 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            15 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3q66v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>


<item>
            <title>[AVRO-2146] getting Expected start-union. Got VALUE_STRING</title>
                <link>https://issues.apache.org/jira/browse/AVRO-2146</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;Here is the schema, no unions, but getting union error :&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;{&lt;br/&gt;
 &quot;type&quot; : &quot;record&quot;,&lt;br/&gt;
 &quot;name&quot; : &quot;edm_generic_publisher_avro_schema&quot;,&lt;br/&gt;
 &quot;namespace&quot; : &quot;edm.avro&quot;,&lt;br/&gt;
 &quot;doc&quot; : &quot;The generic avro schema used by publishers to publish events to the enterprise streaming service&quot;,&lt;br/&gt;
 &quot;fields&quot; : [&lt;/p&gt;

&lt;p&gt;{&quot;name&quot; : &quot;event&quot;, &lt;br/&gt;
 &quot;type&quot; : {&lt;br/&gt;
 &quot;type&quot; : &quot;record&quot;,&lt;br/&gt;
 &quot;name&quot; : &quot;event_meta_data&quot;,&lt;br/&gt;
 &quot;fields&quot; : [&lt;/p&gt;

{&quot;name&quot; : &quot;event_name&quot;, &quot;type&quot; : &quot;string&quot;, &quot;doc&quot; : &quot;The name of the event. In the CDC, this field is populated with the name of the data base table or segment.&quot;}

&lt;p&gt;,&lt;/p&gt;

{&quot;name&quot; : &quot;operation_type&quot;, &quot;type&quot; : &quot;string&quot;, &quot;doc&quot;: &quot;The operation or action that triggered the event. e.g., Insert, Update, Delete, etc.&quot;}

&lt;p&gt;,&lt;/p&gt;

{&quot;name&quot; : &quot;transaction_identifier&quot;, &quot;type&quot; : &quot;string&quot;, &quot;default&quot; : &quot;NONE&quot;, &quot;doc&quot; : &quot;A unique identifier that identifies a unit or work or transaction. Useful in relating multiple events together.&quot;}

&lt;p&gt;,&lt;/p&gt;

{&quot;name&quot; : &quot;event_publication_timestamp_millis&quot;, &quot;type&quot; : &quot;string&quot;, &quot;doc&quot;: &quot;timestamp when the event was published&quot;}

&lt;p&gt;,&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

{&quot;name&quot; : &quot;event_publisher&quot;, &quot;type&quot; : &quot;string&quot;, &quot;doc&quot; : &quot;The system or application that published the event&quot;}

&lt;p&gt;,&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

{&quot;name&quot; : &quot;event_publisher_identity&quot;, &quot;type&quot;: &quot;string&quot;, &quot;default&quot; : &quot;NONE&quot;, &quot;doc&quot;: &quot;The identity (user) of the system or application that published the event&quot;}

&lt;p&gt;,&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

{&quot;name&quot; : &quot;event_timestamp_millis&quot;, &quot;type&quot; : &quot;string&quot;, &quot;default&quot; : &quot;NONE&quot;, &quot;doc&quot;: &quot;timestamp when the event occured&quot;}

&lt;p&gt;,&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

{&quot;name&quot;: &quot;event_initiator&quot;, &quot;type&quot;: &quot;string&quot;, &quot;default&quot; : &quot;NONE&quot;, &quot;doc&quot; : &quot;The system or application that initiated the event&quot;}

&lt;p&gt;,&lt;/p&gt;

{&quot;name&quot;: &quot;event_initiator_identity&quot;, &quot;type&quot; : &quot;string&quot;, &quot;default&quot; : &quot;NONE&quot;, &quot;doc&quot;: &quot;The system id or application id that initiated the event&quot; }

&lt;p&gt;]},&lt;br/&gt;
 &quot;doc&quot; : &quot;The data about the published event&quot;&lt;br/&gt;
 },&lt;br/&gt;
 { &quot;name&quot; : &quot;contents&quot;,&lt;br/&gt;
 &quot;type&quot; : {&lt;br/&gt;
 &quot;name&quot;: &quot;data_field_groups&quot;,&lt;br/&gt;
 &quot;type&quot;: &quot;array&quot;,&lt;br/&gt;
 &quot;items&quot;: {&lt;br/&gt;
 &quot;type&quot;: &quot;record&quot;,&lt;br/&gt;
 &quot;name&quot;: &quot;data_field_group&quot;,&lt;br/&gt;
 &quot;fields&quot; : [&lt;/p&gt;

{&quot;name&quot;: &quot;data_group_name&quot;, &quot;type&quot;: &quot;string&quot; }

&lt;p&gt;,&lt;br/&gt;
 {&lt;br/&gt;
 &quot;name&quot;: &quot;data_fields&quot;,&lt;br/&gt;
 &quot;type&quot;: {&lt;br/&gt;
 &quot;type&quot;: &quot;array&quot;,&lt;br/&gt;
 &quot;items&quot;: {&lt;br/&gt;
 &quot;name&quot;: &quot;data_field&quot;,&lt;br/&gt;
 &quot;type&quot;: &quot;record&quot;,&lt;br/&gt;
 &quot;fields&quot;:[&lt;/p&gt;

{&quot;name&quot; : &quot;data_field_name&quot;, &quot;type&quot; : &quot;string&quot;, &quot;doc&quot; : &quot;The field name&quot;}

&lt;p&gt;,&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

{&quot;name&quot;: &quot;data_field_type&quot;, &quot;type&quot;: &quot;string&quot;, &quot;doc&quot; : &quot;The data type is one of the following values: string, boolean, int, long, float, double or bytes&quot;}

&lt;p&gt;,&lt;/p&gt;

{&quot;name&quot; : &quot;data_field_value&quot;, &quot;type&quot; : [&quot;string&quot;], &quot;doc&quot; : &quot;The value&quot;}

&lt;p&gt;]&lt;br/&gt;
 }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;}&lt;br/&gt;
 ]&lt;br/&gt;
 }&lt;br/&gt;
 },&lt;br/&gt;
 &quot;doc&quot; : &quot;The datafields for the for the published event&quot;&lt;br/&gt;
 } &lt;br/&gt;
 ]&lt;br/&gt;
 }&lt;/p&gt;

&lt;p&gt;;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;here is the code that is causing the issue-------------------------------&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;static byte[] fromJasonToAvro( InputStream json, Schema schemastr) throws Exception {&lt;br/&gt;
 FileOutputStream outStream;&lt;/p&gt;

&lt;p&gt;InputStream input = json; &lt;br/&gt;
 DataInputStream din = new DataInputStream(input);&lt;/p&gt;

&lt;p&gt;Schema schema = schemastr;&lt;/p&gt;

&lt;p&gt;Decoder decoder = DecoderFactory.get().jsonDecoder(schema, din);&lt;/p&gt;

&lt;p&gt;DatumReader&amp;lt;Object&amp;gt; reader = new GenericDatumReader&amp;lt;Object&amp;gt;(schema);&lt;br/&gt;
 Object datum = reader.read(null, decoder);&lt;/p&gt;

&lt;p&gt;GenericDatumWriter&amp;lt;Object&amp;gt; w = new GenericDatumWriter&amp;lt;Object&amp;gt;(schema);&lt;br/&gt;
 ByteArrayOutputStream outputStream = new ByteArrayOutputStream();&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Encoder e = EncoderFactory.get().binaryEncoder(outputStream, null);&lt;/p&gt;

&lt;p&gt;w.write(datum, e);&lt;br/&gt;
 e.flush();&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;json file:&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;{&lt;br/&gt;
 &quot;event&quot;: &lt;/p&gt;
{
 &quot;event_name&quot;: &quot;Customer Phone Number&quot;,
 &quot;operation_type&quot;: &quot;Add&quot;,
 &quot;transaction_identifier&quot;: &quot;1234567890&quot;,
 &quot;event_publication_timestamp_millis&quot;: &quot;1518464452915&quot;,
 &quot;event_publisher&quot;: &quot;CIS&quot;,
 &quot;event_publisher_identity&quot;: &quot;System&quot;,
 &quot;event_timestamp_millis&quot;: &quot;NONE&quot;,
 &quot;event_initiator&quot;: &quot;NONE&quot;,
 &quot;event_initiator_identity&quot;: &quot;NONE&quot;
 }
&lt;p&gt;,&lt;br/&gt;
 &quot;content&quot;: [&lt;br/&gt;
 {&lt;br/&gt;
 &quot;data_group_name&quot;: &quot;customer_identifier&quot;,&lt;br/&gt;
 &quot;data_fields&quot;: [&lt;br/&gt;
 &lt;/p&gt;
{
 &quot;data_field_name&quot;: &quot;company_number&quot;,
 &quot;data_field_type&quot;: &quot;string&quot;,
 &quot;data_field_value&quot;: &quot;069&quot;
 }
&lt;p&gt;,&lt;br/&gt;
 &lt;/p&gt;
{
 &quot;data_field_name&quot;: &quot;customer_short_name&quot;,
 &quot;data_field_type&quot;: &quot;string&quot;,
 &quot;data_field_value&quot;: &quot;marshben&quot;
 }
&lt;p&gt;,&lt;/p&gt;
 {
 &quot;data_field_name&quot;: &quot;tie_breaker&quot;,
 &quot;data_field_type&quot;: &quot;string&quot;,
 &quot;data_field_value&quot;: &quot;01&quot;
 }
&lt;p&gt; ]&lt;br/&gt;
 },&lt;br/&gt;
 {&lt;br/&gt;
 &quot;data_group_name&quot;: &quot;customer_phone_number&quot;,&lt;br/&gt;
 &quot;data_fields&quot;: [&lt;br/&gt;
 &lt;/p&gt;
{
 &quot;data_field_name&quot;: &quot;phone_number&quot;,
 &quot;data_field_type&quot;: &quot;string&quot;,
 &quot;data_field_value&quot;: &quot;6x2-555-1x12&quot;
 }
&lt;p&gt;,&lt;br/&gt;
 &lt;/p&gt;
{
 &quot;data_field_name&quot;: &quot;phone_type&quot;,
 &quot;data_field_type&quot;: &quot;string&quot;,
 &quot;data_field_value&quot;: &quot;cell&quot;
 }
&lt;p&gt;,&lt;/p&gt;
 {
 &quot;data_field_name&quot;: &quot;primary_indicator&quot;,
 &quot;data_field_type&quot;: &quot;string&quot;,
 &quot;data_field_value&quot;: &quot;yes&quot;
 }
&lt;p&gt; ]&lt;br/&gt;
 }&lt;/p&gt;

&lt;p&gt; ]&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</description>
                <environment>&lt;p&gt;error message:&lt;/p&gt;

&lt;p&gt;Exception in thread &quot;main&quot; org.apache.avro.AvroTypeException: Expected start-union. Got VALUE_STRING&lt;br/&gt;
 at org.apache.avro.io.JsonDecoder.error(JsonDecoder.java:698)&lt;br/&gt;
 at org.apache.avro.io.JsonDecoder.readIndex(JsonDecoder.java:441)&lt;br/&gt;
 at org.apache.avro.io.ResolvingDecoder.doAction(ResolvingDecoder.java:290)&lt;br/&gt;
 at org.apache.avro.io.parsing.Parser.advance(Parser.java:88)&lt;br/&gt;
 at org.apache.avro.io.ResolvingDecoder.readIndex(ResolvingDecoder.java:267)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.readWithoutConversion(GenericDatumReader.java:179)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.read(GenericDatumReader.java:153)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.readField(GenericDatumReader.java:232)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.readRecord(GenericDatumReader.java:222)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.readWithoutConversion(GenericDatumReader.java:175)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.read(GenericDatumReader.java:153)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.readField(GenericDatumReader.java:232)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.readRecord(GenericDatumReader.java:222)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.readWithoutConversion(GenericDatumReader.java:175)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.read(GenericDatumReader.java:153)&lt;br/&gt;
 at org.apache.avro.generic.GenericDatumReader.read(GenericDatumReader.java:145)&lt;br/&gt;
 at myJson2Avro.fromJasonToAvro(myJson2Avro.java:81)&lt;br/&gt;
 at myJson2Avro.main(myJson2Avro.java:48)&lt;/p&gt;</environment>
        <key id="13139097">AVRO-2146</key>
            <summary>getting Expected start-union. Got VALUE_STRING</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="laki">laki</reporter>
                        <labels>
                    </labels>
                <created>Fri, 16 Feb 2018 17:39:17 +0000</created>
                <updated>Sun, 30 Dec 2018 04:35:14 +0000</updated>
                                            <version>1.8.2</version>
                                                    <component>java</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="16368876" author="nkollar" created="Mon, 19 Feb 2018 08:46:52 +0000"  >&lt;p&gt;I think your schema includes a union: {&lt;tt&gt;&quot;name&quot; : &quot;data_field_value&quot;, &quot;type&quot; : &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;string&amp;quot;&amp;#93;&lt;/span&gt;, &quot;doc&quot; : &quot;The value&quot;&lt;/tt&gt;}. Here string is in square brackets, so &lt;tt&gt;data_field_value&lt;/tt&gt; is a union field (see details in &lt;a href=&quot;https://avro.apache.org/docs/1.8.1/spec.html#Unions&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;doc&lt;/a&gt;).&lt;/p&gt;</comment>
                            <comment id="16550672" author="fhuertas" created="Fri, 20 Jul 2018 11:28:44 +0000"  >&lt;p&gt;&lt;font color=&quot;#333333&quot;&gt;I have a more simple example&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;font color=&quot;#333333&quot;&gt;Schema&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font color=&quot;#333333&quot;&gt;{&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160; &quot;type&quot; : &quot;record&quot;,&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160; &quot;name&quot; : &quot;recordName&quot;,&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160;&#160; &quot;namespace&quot; : &quot;name.space&quot;,&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160;&#160; &quot;fields&quot; : [ {&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160;&#160;&#160;&#160; &quot;name&quot; : &quot;id&quot;,&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160;&#160;&#160;&#160; &quot;type&quot; : &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;int&amp;quot;&amp;#93;&lt;/span&gt;&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160;&#160; } ]&lt;/font&gt;&lt;br/&gt;
 }&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Json&lt;font color=&quot;#333333&quot;&gt;: &lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font color=&quot;#333333&quot;&gt;{&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160;&#160; &quot;id&quot; : 141&lt;/font&gt;&lt;br/&gt;
 }&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Code:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font color=&quot;#cc7832&quot;&gt;new &lt;/font&gt;GenericDatumReader&amp;lt;GenericRecord&amp;gt;(schema).read(null&lt;font color=&quot;#cc7832&quot;&gt;, &lt;/font&gt;DecoderFactory.get().jsonDecoder(schema&lt;font color=&quot;#cc7832&quot;&gt;, &lt;/font&gt;json))&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&quot;#333333&quot;&gt;Error: &lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font color=&quot;#333333&quot;&gt;Expected start-union. Got VALUE_NUMBER_INT&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;org.apache.avro.AvroTypeException: Expected start-union. Got VALUE_NUMBER_INT&lt;/font&gt;&lt;br/&gt;
 &lt;font color=&quot;#333333&quot;&gt;&#160;&#160; &#160;at org.apache.avro.io.JsonDecoder.error(JsonDecoder.java:698)&lt;/font&gt;&lt;/p&gt;&lt;/blockquote&gt;</comment>
                            <comment id="16550702" author="nkollar" created="Fri, 20 Jul 2018 11:59:26 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fhuertas&quot; class=&quot;user-hover&quot; rel=&quot;fhuertas&quot;&gt;Francisco Huertas&lt;/a&gt; you should specify in the Json data which union branch to use. Your Json should look like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
{
   &lt;span class=&quot;code-quote&quot;&gt;&quot;id&quot;&lt;/span&gt; : {
    &lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;&quot;&lt;/span&gt; : 141
   }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;See details in &lt;a href=&quot;https://avro.apache.org/docs/1.8.2/spec.html#json_encoding&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;doc&lt;/a&gt;.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 19 Feb 2018 08:46:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            26 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3qa73:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>


<item>
            <title>[AVRO-2147] Proto to Avro serialization is unnecessarily slow due to repeated schema creation</title>
                <link>https://issues.apache.org/jira/browse/AVRO-2147</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I discovered that proto to avro serialization is unnecessarily slow in certain cases due to repeated schema creation. Specifically,&#160;this slowness&#160;shows when serializing protocol buffer messages that contain nested protocol buffer messages that contain&#160;enums with many possible values. Some profiling showed this is due to the &lt;tt&gt;Schema&lt;/tt&gt; objects for the nested message/enum not being cached in this case.&lt;/p&gt;

&lt;p&gt;An example that reproduces this is to add the following to &lt;tt&gt;test.proto&lt;/tt&gt;:&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;message Foo {&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; ...&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160;&#160;optional MessageWithLargeEnum bar = 21;&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;}&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;message MessageWithLargeEnum {&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; optional LargeEnum enum = 1;&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;}&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;enum LargeEnum {&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; AA = 1;&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; AB = 2;&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; AC = 3;&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; ...&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160;&#160;ZZ = 676;&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;}&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;Then, a test like&#160;the following&#160;will exhibit the slow behavior:&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;@Test public void perf() throws Exception {&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; Foo.Builder builder = Foo.newBuilder();&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setInt32(0);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setInt64(2);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setUint32(3);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setUint64(4);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setSint32(5);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setSint64(6);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setFixed32(7);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setFixed64(8);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setSfixed32(9);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setSfixed64(10);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setFloat(1.0F);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setDouble(2.0);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setBool(true);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setString(&quot;foo&quot;);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setBytes(ByteString.copyFromUtf8(&quot;bar&quot;));&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.setEnum(org.apache.avro.protobuf.Test.A.X);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.addIntArray(27);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; builder.addSyms(org.apache.avro.protobuf.Test.A.Y);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; &#160;builder.setBar(MessageWithLargeEnum.newBuilder().setEnum(LargeEnum.AA));&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;&#160; Foo objToConvert = builder.build();&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;&#160; Schema schema = ProtobufData.get().getSchema(Foo.class);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; ByteArrayOutputStream bao = new ByteArrayOutputStream();&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; Encoder e = EncoderFactory.get().binaryEncoder(bao, null);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; ProtobufDatumWriter&amp;lt;Foo&amp;gt; w = new ProtobufDatumWriter&amp;lt;Foo&amp;gt;(schema);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; GenericDatumReader gdr = new GenericDatumReader(schema, schema);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; BinaryDecoder d = null;&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;&#160; long startTime = System.nanoTime();&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; for (int i = 0; i &amp;lt; 1000000; ++i) {&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; &#160; bao.reset();&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; &#160; w.write(objToConvert, e);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; &#160; e.flush();&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; &#160; d = DecoderFactory.get().binaryDecoder(bao.toByteArray(), d);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; &#160; &#160;gdr.read(null, d);&lt;/tt&gt;&lt;br/&gt;
 {&lt;/p&gt;
{&#160; }
&lt;p&gt;}}&lt;br/&gt;
 &lt;tt&gt;&#160; long endTime = System.nanoTime();&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;&#160; System.out.println(&quot;Elapsed: &quot; + (endTime - startTime) / 1000000 + &quot; ms&quot;);&lt;/tt&gt;&lt;br/&gt;
 &lt;tt&gt;}&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;I will attach a patch that&#160;optimizes this.&lt;/p&gt;

&lt;p&gt;With the attached patch this test reports a runtime of about 4 seconds, while the runtime without the patch is 30+ seconds, so this is an 7.5-8x improvement for this particular test enum.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13139267">AVRO-2147</key>
            <summary>Proto to Avro serialization is unnecessarily slow due to repeated schema creation</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21140&amp;avatarType=issuetype">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="Tobi">Tobi Vollebregt</assignee>
                                    <reporter username="Tobi">Tobi Vollebregt</reporter>
                        <labels>
                            <label>java</label>
                            <label>optimization</label>
                            <label>protobuf</label>
                    </labels>
                <created>Sat, 17 Feb 2018 20:41:05 +0000</created>
                <updated>Fri, 2 Mar 2018 23:02:39 +0000</updated>
                            <resolved>Fri, 2 Mar 2018 22:45:18 +0000</resolved>
                                    <version>1.8.1</version>
                    <version>1.8.2</version>
                                    <fixVersion>1.9.0</fixVersion>
                                    <component>java</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="16368360" author="tobi" created="Sat, 17 Feb 2018 21:11:13 +0000"  >&lt;p&gt;BTW &#8211; not sure how to best include a test for this:&#160;explicitly testing the performance seems like it would create a flaky test, and the only other way I can think of would require instrumenting the code somehow so that the test can assert that serializing&#160;N objects doesn&apos;t require&#160;O(N) schema objects to be created.&#160;&lt;/p&gt;</comment>
                            <comment id="16368363" author="tobi" created="Sat, 17 Feb 2018 21:14:21 +0000"  >&lt;p&gt;I have separately attached the&#160;full modified test.proto and the test I put in the description, since jira&#160;mangles the code otherwise.&#160;&lt;/p&gt;</comment>
                            <comment id="16371757" author="cutting" created="Wed, 21 Feb 2018 17:57:13 +0000"  >&lt;p&gt;Patch looks fine to me.  I don&apos;t think we need to commit the perf test.&lt;/p&gt;

&lt;p&gt;Does anyone object to committing this patch?&lt;/p&gt;
</comment>
                            <comment id="16384255" author="jira-bot" created="Fri, 2 Mar 2018 22:31:54 +0000"  >&lt;p&gt;Commit 94f12b85c3d269cdb510f8c0b843008469e4f826 in avro&apos;s branch refs/heads/master from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cutting&quot; class=&quot;user-hover&quot; rel=&quot;cutting&quot;&gt;Doug Cutting&lt;/a&gt;&lt;br/&gt;
[ &lt;a href=&quot;https://gitbox.apache.org/repos/asf?p=avro.git;h=94f12b8&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://gitbox.apache.org/repos/asf?p=avro.git;h=94f12b8&lt;/a&gt; ]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-2147&quot; title=&quot;Proto to Avro serialization is unnecessarily slow due to repeated schema creation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-2147&quot;&gt;&lt;del&gt;AVRO-2147&lt;/del&gt;&lt;/a&gt;. Java Protobuf: use schema cache to improve performance. (Tobi Vollebregt via cutting)&lt;/p&gt;</comment>
                            <comment id="16384269" author="cutting" created="Fri, 2 Mar 2018 22:45:18 +0000"  >&lt;p&gt;I committed this.  Thanks, Tobi!&lt;/p&gt;</comment>
                            <comment id="16384287" author="tobi" created="Fri, 2 Mar 2018 23:02:39 +0000"  >&lt;p&gt;Nice, thank you!&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12911038" name="AVRO-2147.patch" size="1029" author="Tobi" created="Sat, 17 Feb 2018 20:53:04 +0000"/>
                            <attachment id="12911041" name="TestProtobufPerf.java" size="2098" author="Tobi" created="Sat, 17 Feb 2018 21:13:35 +0000"/>
                            <attachment id="12911040" name="test.proto" size="9887" author="Tobi" created="Sat, 17 Feb 2018 21:13:07 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 21 Feb 2018 17:57:13 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310250" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10430"><![CDATA[Patch]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            46 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3qb8v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                    </customfields>
    </item>
</channel>
</rss>
