<!--
RSS generated by JIRA (7.6.3#76005-sha1:8a4e38d34af948780dbf52044e7aafb13a7cae58) at Mon Jan 21 19:15:33 UTC 2019

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<!-- If you wish to do custom client-side styling of RSS, uncomment this:
<?xml-stylesheet href="https://issues.apache.org/jira/styles/jiraxml2html.xsl" type="text/xsl"?>
-->
<rss version="0.92">
    <channel>
        <title>ASF JIRA</title>
        <link>https://issues.apache.org/jira/issues/?jql=project+%3D+AVRO+AND+created+%3E%3D+2011-5-4+AND+created+%3C%3D+2011-5-11+ORDER+BY+key+ASC</link>
        <description>An XML representation of a search request</description>
                <language>en-uk</language>
                        <issue start="0" end="2" total="2"/>
                <build-info>
            <version>7.6.3</version>
            <build-number>76005</build-number>
            <build-date>09-01-2018</build-date>
        </build-info>

<item>
            <title>[AVRO-816] Schema Comparison Utils</title>
                <link>https://issues.apache.org/jira/browse/AVRO-816</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;From my post on the mailing list, and Doug&apos;s response:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;On 05/05/2011 10:29 AM, Joe Crobak wrote:&lt;br/&gt;
&amp;gt; We&apos;ve recently come across a situation where we have two data files with&lt;br/&gt;
&amp;gt; different schemas that we&apos;d like to process together using&lt;br/&gt;
&amp;gt; GenericDatumReader.  One schema is promotable to the other, but not vice&lt;br/&gt;
&amp;gt; versa.  We&apos;d like to programmatically determine which of the schemas to&lt;br/&gt;
&amp;gt; use.  I did a brief look through javadoc and tests, and I couldn&apos;t find&lt;br/&gt;
&amp;gt; any examples of checking if one schema is promotable to the other.  Has&lt;br/&gt;
&amp;gt; anyone else come across this?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; For some context, we&apos;re considering patching AvroStorage &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; to remove&lt;br/&gt;
&amp;gt; the assumption that all files have the same schema.  In our case, our&lt;br/&gt;
&amp;gt; schema has evolved in that a field that was an int was promoted to a long.&lt;/p&gt;

&lt;p&gt;A boolean method that tells you if one schema is promotable to another&lt;br/&gt;
would work in this case, but would not help in cases where, e.g.,&lt;br/&gt;
different fields had changed in different versions.  For example, in&lt;br/&gt;
branched development, two branches might each add a distinct symbol to&lt;br/&gt;
an enum.  So I think you might be better off with a method that, given&lt;br/&gt;
two schemas, returns their superset, a schema that can read data written&lt;br/&gt;
by either.&lt;/p&gt;

&lt;p&gt;Such a method does not yet exist in Avro, but should not be difficult to&lt;br/&gt;
add.  Please file an issue in Jira if this sounds of interest.&lt;/p&gt;

&lt;p&gt;Doug&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think it would be useful to have both of the methods that Doug mentioned in some sort of schema utils class.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12506446">AVRO-816</key>
            <summary>Schema Comparison Utils</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21141&amp;avatarType=issuetype">New Feature</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Minor</priority>
                        <status id="10002" iconUrl="https://issues.apache.org/jira/images/icons/statuses/document.png" description="A patch for this issue has been uploaded to JIRA by a contributor.">Patch Available</status>
                    <statusCategory id="4" key="indeterminate" colorName="yellow"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="joecrobak">Joe Crobak</assignee>
                                    <reporter username="joecrobak">Joe Crobak</reporter>
                        <labels>
                    </labels>
                <created>Fri, 6 May 2011 19:19:13 +0000</created>
                <updated>Thu, 31 Jan 2013 18:48:51 +0000</updated>
                                                                            <component>java</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="13030101" author="joecrobak" created="Fri, 6 May 2011 19:20:00 +0000"  >&lt;p&gt;I think I should have some time to implement this in the coming days, so I&apos;ll try to put a patch together.&lt;/p&gt;</comment>
                            <comment id="13058625" author="joecrobak" created="Fri, 1 Jul 2011 16:28:44 +0000"  >&lt;p&gt;I was looking for some feedback on the approach I took for &lt;tt&gt;isSuperset&lt;/tt&gt; before working on &lt;tt&gt;unify&lt;/tt&gt;. My implementation is duplicating a lot of the logic in ResolvingGrammarGenerator, but it&apos;s &lt;tt&gt;generate&lt;/tt&gt; method doesn&apos;t seem quite suitable.  Please let me know if you have suggestions on how the logic could be consolidated.&lt;/p&gt;</comment>
                            <comment id="13058647" author="cutting" created="Fri, 1 Jul 2011 16:51:26 +0000"  >&lt;p&gt;I don&apos;t think this duplicates too much logic.&lt;/p&gt;

&lt;p&gt;Alternately, the isSuperset method could be Schema#isSuperset(Schema that).  Then, instead of a big switch statement, you&apos;d implement this method on Schema subclasses.  The base class, Schema, would implement this as just this.getType()==that.getType, handling int, byte, boolean and string.  NamedSchema would override this, checking names, etc.&lt;/p&gt;

&lt;p&gt;Also, I worry that &apos;Arrays.asList(Type.INT, Type.LONG).contains(t)&apos; may be slow, if performance matters.  &apos;t==INT || t == LONG&apos; would be a lot faster and still readable.&lt;/p&gt;</comment>
                            <comment id="13058660" author="joecrobak" created="Fri, 1 Jul 2011 17:24:47 +0000"  >&lt;p&gt;Thanks for the feedback.  I think moving the isSuperset method to Schema would be a lot nicer. What do you think about unify, would a method like Schema#unify(Schema... others) be ok or should it stay in a static util class?&lt;/p&gt;

&lt;p&gt;Will also remove the use Arrays#asList/contains.&lt;/p&gt;</comment>
                            <comment id="13058672" author="cutting" created="Fri, 1 Jul 2011 17:47:31 +0000"  >&lt;p&gt;I don&apos;t mind having it on Schema directly, like applyAliases.&lt;/p&gt;</comment>
                            <comment id="13059206" author="joecrobak" created="Sun, 3 Jul 2011 14:44:07 +0000"  >&lt;p&gt;Implemented Schema#isSuperset, Schema#unify, and a Tool for generating unified Schemas from avro data files.&lt;/p&gt;

&lt;p&gt;I have one open question about how unify should work in the case where two Records have the same name/type but different default values. I suspect there are other edge cases that I may have missed &amp;#8211; maybe someone more familiar with the data model can suggest some additional checks.&lt;/p&gt;</comment>
                            <comment id="13060048" author="cutting" created="Tue, 5 Jul 2011 18:03:18 +0000"  >&lt;p&gt;Patch looks great.  A few things we might consider changing before committing:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The relationship between &apos;isSuperset&apos; and &apos;unify&apos; might be a bit clearer if different names were used.  &apos;isSuperset/union&apos; would be confusing since &apos;union&apos; already has a meaning in Avro, so maybe &apos;subsumes/unify&apos; would be slightly better?  What do you think?&lt;/li&gt;
	&lt;li&gt;Unification currently ignores schema &amp;amp; record properties and field ordering.  This is fine, since they&apos;re not needed for reading, but probably should be called out in the javadoc.  Someone could add this as a feature later if they need it.&lt;/li&gt;
	&lt;li&gt;When default values differ maybe an exception should be thrown?&lt;/li&gt;
	&lt;li&gt;Should a call to unifyAliases() be added to RecordSchema?&lt;/li&gt;
	&lt;li&gt;I would prefer that the methods instead started like: 
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (type != RECORD)
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.unify(other);
  ... &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; This removes a level of indentation from the bulk of the method and makes it clear to the reader that no other cases are dealt with.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13060077" author="joecrobak" created="Tue, 5 Jul 2011 19:04:38 +0000"  >&lt;p&gt;Agree on all accounts &amp;#8211; I&apos;ll update the patch with your feedback&lt;/p&gt;</comment>
                            <comment id="13061217" author="joecrobak" created="Thu, 7 Jul 2011 11:24:10 +0000"  >&lt;p&gt;Updated patch that incorporates Doug&apos;s feedback.&lt;/p&gt;</comment>
                            <comment id="13061552" author="scott_carey" created="Thu, 7 Jul 2011 20:06:29 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getFixedSize() &amp;gt;= other.getFixedSize();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I believe the below is incorrect for a fixed schema subsuming another.  You cannot type promote a fixed schema from one length to a longer one.  The spec states that the sizes must match.&lt;/p&gt;</comment>
                            <comment id="13061685" author="joecrobak" created="Fri, 8 Jul 2011 00:00:45 +0000"  >&lt;blockquote&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getFixedSize() &amp;gt;= other.getFixedSize();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;Great catch - thanks Scott! I&apos;ll fix this and also take another pass on the spec to make sure that the implementation is consistent with it.&lt;/p&gt;</comment>
                            <comment id="13063328" author="joecrobak" created="Mon, 11 Jul 2011 13:13:10 +0000"  >&lt;p&gt;I&apos;ve discovered one other case that might be considered a bug.  currently, &lt;tt&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;int&amp;quot;&amp;#93;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt;&lt;/tt&gt; unify to &lt;tt&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt;&lt;/tt&gt;.  I think it&apos;d be much nicer if we followed the primitive promotion rules and unified to &lt;tt&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt;&lt;/tt&gt;, though.  What do others think?&lt;/p&gt;</comment>
                            <comment id="13063451" author="cutting" created="Mon, 11 Jul 2011 17:47:47 +0000"  >&lt;p&gt;I agree that since &quot;long&quot; and &quot;int&quot; unify to &quot;long&quot; that &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt; and &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;int&amp;quot;&amp;#93;&lt;/span&gt; should ideally unify to &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt;.&lt;/p&gt;</comment>
                            <comment id="13063649" author="joecrobak" created="Tue, 12 Jul 2011 01:36:47 +0000"  >&lt;p&gt;I&apos;ve updated the patch to fix the problem identified with the FixedSchema, and I&apos;ve fixed subsumes and unify for UnionSchema in the case where one invokes subsume/unify with &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;int&amp;quot;&amp;#93;&lt;/span&gt; and &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt; (as well as more complex types).&lt;/p&gt;

&lt;p&gt;The implementation is quadratic (loops over both unions), and could possibly be improved if there are performance concerns.&lt;/p&gt;</comment>
                            <comment id="13063691" author="dkaminsky" created="Tue, 12 Jul 2011 03:19:46 +0000"  >&lt;p&gt;a) some thoughts on functionality - if you&apos;re going for set operations, you should just go for it and give the full set of operations:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;intersection of two schemas would be conceivably useful&lt;/li&gt;
	&lt;li&gt;in addition to isSuperset, isSubset should be available&lt;/li&gt;
	&lt;li&gt;isStrictSubset or isProperSubset (even if its entire body is &quot;return !isSuperset(schema)&quot;)&lt;/li&gt;
	&lt;li&gt;isStrictSuperset or isProperSuperset (even if its entire body is &quot;return !isSubset(schema)&quot;)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;b) some thoughts on naming - &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I would favor &quot;compose&quot; &quot;join&quot; or &quot;combine&quot; over &quot;unify&quot;&lt;/li&gt;
	&lt;li&gt;&quot;subsumes&quot; seems a bit... obtuse? I&apos;d leave it as &quot;isSupersetOf&quot; or &quot;contains&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;c) +1 on the ability to combine two records whose schemas compose a more complex type&lt;/p&gt;</comment>
                            <comment id="13063912" author="joecrobak" created="Tue, 12 Jul 2011 14:00:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;a) some thoughts on functionality - if you&apos;re going for set operations, you should just go for it and give the full set of operations:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think it&apos;s pretty non-intuitive (and potentially incorrect) to think about set operations for avro schemas. In addition to &quot;union&quot; meaning something different in Avro, it&apos;s unclear to me what a number of other operations would be... e.g. what is the intersection of int and long? int or {} (what does empty set even mean..)?  There are plenty of other examples where it breaks down...&lt;/p&gt;

&lt;p&gt;With that said, I could see use for some of the methods you mention.  I&apos;d prefer to add those as part of a separate patch, though (this is already getting rather large). subsumes/unify grew out of the need to determine the correct &quot;read&quot; schema for reading multiple avro data files with different but compatible schemas... nothing to do with set operations.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;b) some thoughts on naming -&lt;/p&gt;

&lt;p&gt;I would favor &quot;compose&quot; &quot;join&quot; or &quot;combine&quot; over &quot;unify&quot;&lt;br/&gt;
&quot;subsumes&quot; seems a bit... obtuse? I&apos;d leave it as &quot;isSupersetOf&quot; or &quot;contains&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m terrible at naming &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.. compose, join, and combine would all be fine with me. I&apos;d like to avoid the use of set operations in names per above (which rules out isSupersetOf) and I think contains would be confusing (e.g. a record with an int field &quot;contains&quot; an int schema)... other suggestions?&lt;/p&gt;
</comment>
                            <comment id="13063956" author="joecrobak" created="Tue, 12 Jul 2011 15:37:48 +0000"  >&lt;p&gt;FWIW, I choose &quot;unify&quot; because this is solving a similar problem to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Type_inference&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;type inference&lt;/a&gt; problem, which is solved via &lt;a href=&quot;http://en.wikipedia.org/wiki/Unification_(computing)&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;unification&lt;/a&gt;... nothing to do with set operations.&lt;/p&gt;</comment>
                            <comment id="13064051" author="cutting" created="Tue, 12 Jul 2011 18:11:43 +0000"  >&lt;p&gt;I like subsumes/unify, but am open to other names.  As Joe noted, sets may not be a great metaphor, since &apos;union&apos; would be overloaded and not all set operations make sense.  Maybe &apos;canRead/readsBoth&apos;?  Then we might add &apos;boolan readsSame(Schema)&apos; for &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-853&quot; title=&quot;Cache hash codes in Schema and Field&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-853&quot;&gt;&lt;del&gt;AVRO-853&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="13065023" author="dkaminsky" created="Thu, 14 Jul 2011 03:19:04 +0000"  >&lt;p&gt;I think the set operations make sense conceptually for several use cases - custom diff reports on schemas, re-creating inheritance at runtime, deep copy between disparate types, etc.&lt;/p&gt;

&lt;p&gt;To address the specific question, if the &quot;unification&quot; of a long and an int is a long, the intersection should logically be an int. It makes sense if you think of it in terms of bytes - the upper half of the long doesn&apos;t exist in the int, so the natural intersection are the lower 32 bytes shared by both types.&lt;/p&gt;</comment>
                            <comment id="13065024" author="dkaminsky" created="Thu, 14 Jul 2011 03:20:42 +0000"  >&lt;p&gt;**sorry, meant 32 bits, also realized I arbitrarily was using a 32 bit word size system in my example, I&apos;m sure you get where I&apos;m going with it&lt;/p&gt;</comment>
                            <comment id="13065489" author="joecrobak" created="Thu, 14 Jul 2011 19:32:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think the set operations make sense conceptually for several use cases - custom diff reports on schemas, re-creating inheritance at runtime, deep copy between disparate types, etc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re probably right &amp;#8211; just I haven&apos;t come across the use case yet. How do you feel about creating a separate issue for adding the other operations? I think that some of the operations, in particular diff/intersection, will require some thinking and documentation (and would we want to prove that the operations are true set operations and thus commutative, associative, etc?)&lt;/p&gt;

&lt;p&gt;If we can agree to the above, then we only need to agree on naming of the two methods implemented here.&lt;/p&gt;</comment>
                            <comment id="13065520" author="scott_carey" created="Thu, 14 Jul 2011 20:41:27 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Maybe &apos;canRead/readsBoth&apos;? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Lets not introduce the notion of reading, writing, or serializing at all in Schema.java.  &apos;subsumes&apos; may not be the best term, but whatever term is used should not relate to things outside of the scope of unions.&lt;/p&gt;

&lt;p&gt;As part of my conceptual work on &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-859&quot; title=&quot;Java: Data Flow Overhaul -- Composition and Symmetry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;AVRO-859&quot;&gt;AVRO-859&lt;/a&gt; I realized that schema resolution/promotion does not only apply to reads.  A resolution applies from a schema &apos;source&apos; to a schema &apos;target&apos;.  The source could be an object graph, with the target another object graph or the source could be bytes, and the target bytes.  One could have an object graph representing one schema and project out only a subset schema on write.  &lt;/p&gt;</comment>
                            <comment id="13065557" author="scott_carey" created="Thu, 14 Jul 2011 21:48:41 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I agree that since &quot;long&quot; and &quot;int&quot; unify to &quot;long&quot; that &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt; and &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;int&amp;quot;&amp;#93;&lt;/span&gt; should ideally unify to &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is a different operation than &apos;unify&apos;.   It creates a schema that can resolve both source schemas, but information is lost.  If we say that the result is &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt; we are in effect saying that the two schemas: &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt; and &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;, &amp;quot;int&amp;quot;&amp;#93;&lt;/span&gt; are the same.  We might as well not allow the schema &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;long&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;null&amp;quot;&amp;#93;&lt;/span&gt; and force only one numeric type in a union.  &lt;/p&gt;

&lt;p&gt;If there is use for a schema &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;long&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;null&amp;quot;&amp;#93;&lt;/span&gt; (and I argue there is), then the union of &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;long&amp;quot;&amp;#93;&lt;/span&gt; and &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;null&amp;quot;, &amp;quot;int&amp;quot;&amp;#93;&lt;/span&gt; should be &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;long&amp;quot;, &amp;quot;int&amp;quot;, &amp;quot;null&amp;quot;&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;The notion of making a union of two schemas and resolving them to a schema that can read both is distinct.&lt;/p&gt;

&lt;p&gt;Type promotion from int -&amp;gt; long does not lose data, but promotion from int -&amp;gt; float does.  The result is an approximation with (much) fewer significant bits.&lt;/p&gt;

&lt;p&gt;For example&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;      &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-quote&quot;&gt;&quot;%10d&quot;&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE));
      &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-quote&quot;&gt;&quot;%10.1f&quot;&lt;/span&gt;, (&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt;)&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE));
      &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-quote&quot;&gt;&quot;%10d&quot;&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE - 63));
      &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;.format(&lt;span class=&quot;code-quote&quot;&gt;&quot;%10.1f&quot;&lt;/span&gt;, (&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt;)(&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE - 63)));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;prints: &lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;2147483647
2147483648.0
2147483584
2147483648.0
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So on one hand we want to ask for a schema that &quot;can read both of these&quot;, and on the other we have a schema that &quot;can read both at maximum fidelity&quot;.&lt;/p&gt;</comment>
                            <comment id="13067239" author="dkaminsky" created="Mon, 18 Jul 2011 19:44:48 +0000"  >&lt;p&gt;In the case of unions, maximum fidelity is simple, but how would you propose &quot;unifying&quot; a type: &quot;long&quot; and type: &quot;int&quot; field that aren&apos;t in a union? Are you proposing that the composite type would be the union of &quot;long&quot; and &quot;int&quot;?&lt;/p&gt;</comment>
                            <comment id="13067243" author="dkaminsky" created="Mon, 18 Jul 2011 19:50:54 +0000"  >&lt;blockquote&gt;
&lt;p&gt;You&apos;re probably right &#8211; just I haven&apos;t come across the use case yet. How do you feel about creating a separate issue for adding the other operations? I think that some of the operations, in particular diff/intersection, will require some thinking and documentation (and would we want to prove that the operations are true set operations and thus commutative, associative, etc?)&lt;/p&gt;

&lt;p&gt;If we can agree to the above, then we only need to agree on naming of the two methods implemented here.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I wouldn&apos;t be against a separate issue for this - I think if implemented as described they are naturally commutative and associative so if you need a proof it should follow easily.&lt;/p&gt;

&lt;p&gt;I would especially look forward to a way to programatically &quot;diff&quot; schemas using these new operations and allow custom processing of the output (maybe some sort of visitor pattern or event dispatch). This is a real use case that we are currently doing very inefficiently using the ResolvingGrammarGenerator&lt;/p&gt;</comment>
                            <comment id="13070708" author="cutting" created="Mon, 25 Jul 2011 19:42:14 +0000"  >&lt;p&gt;&amp;gt; Lets not introduce the notion of reading, writing, or serializing at all in Schema.java.&lt;/p&gt;

&lt;p&gt;So do you think these methods don&apos;t belong on Schema, but rather on some utility class in the io package&lt;/p&gt;

&lt;p&gt;They&apos;re derived from the specification&apos;s schema resolution rules:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://avro.apache.org/docs/current/spec.html#Schema+Resolution&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://avro.apache.org/docs/current/spec.html#Schema+Resolution&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;These rules are explicitly about reading data.  Perhaps we could name them &apos;resolves&apos; and &apos;resolve&apos;?&lt;/p&gt;</comment>
                            <comment id="13089838" author="cutting" created="Tue, 23 Aug 2011 22:48:27 +0000"  >&lt;p&gt;Where are we with this issue?  Scott, what changes would you like to see in this patch?&lt;/p&gt;</comment>
                            <comment id="13222127" author="scott_carey" created="Mon, 5 Mar 2012 02:25:46 +0000"  >&lt;p&gt;Sorry for the (far too long) delay.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the case of unions, maximum fidelity is simple, but how would you propose &quot;unifying&quot; a type: &quot;long&quot; and type: &quot;int&quot; field that aren&apos;t in a union? Are you proposing that the composite type would be the union of &quot;long&quot; and &quot;int&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, I am suggesting that an operation that creates a union of two schemas would result in all possible branches existing and not just a compatible subset.  A separate operation would take care of the latter, but I&apos;m not sure what a good name for that would be.  &lt;/p&gt;

&lt;p&gt;The use case for each of these differs.  In one case the need is for an exact superset schema in order to read all variations with maximum information retention &amp;#8211; for example this may be useful when reading over a large set of archived data with a long schema evolution history.&lt;/p&gt;

&lt;p&gt;In another situation, reading all of the data with possible loss of precision is ok, and instead the goal is to generate the simplest schema that can read all of the data within an accepted level of precision loss.&lt;/p&gt;

&lt;p&gt;My contention is not that we must create both of these in this ticket, but that if we only have one of them we leave space in the API conceptually for the other (in documentation and class/method names).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;These rules are explicitly about reading data. Perhaps we could name them &apos;resolves&apos; and &apos;resolve&apos;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Perhaps in another ticket we can talk about how to change the language in the spec to be about about the operations we apply to the schema rather than what we are using those operations for.  I think at this point that is relatively low priority until we start adding other features besides reading that rely on schema resolution, and I don&apos;t want to tie that discussion to this ticket.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;So do you think these methods don&apos;t belong on Schema, but rather on some utility class in the io package&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It makes sense to keep pure schema operations in the Schema class or with other Schema utilities.  If I were to start over from scratch I&apos;d probably have an org.apache.avro.schema package that had no dependencies on other concepts in Avro such as serialization or object representations.  But that is separate from this ticket.  Lets just be careful with mixing schema manipulation/transformation concepts unnecessarily with object representation or serialization concepts.&lt;/p&gt;</comment>
                            <comment id="13556742" author="bob.cotton@gmail.com" created="Thu, 17 Jan 2013 23:32:11 +0000"  >&lt;p&gt;There are two issues covered by this patch, subsume-ification and unification, with the latter being the contentious one.&lt;/p&gt;

&lt;p&gt;We have an interest in using subsume, can we split this JIRA and get subsume committed? &lt;br/&gt;
Would be nice not to have to track our custom build for this.&lt;/p&gt;</comment>
                            <comment id="13567932" author="cutting" created="Thu, 31 Jan 2013 18:48:51 +0000"  >&lt;p&gt;The patch still applies but tests no longer pass.&lt;/p&gt;

&lt;p&gt;I think both parts are useful and would be willing to commit this.  Re-reading the comments, I think Scott&apos;s concern is that we (someday) also provide something like &quot;intersection&quot; rather than opposition to &quot;union&quot;.&lt;/p&gt;

&lt;p&gt;I&apos;d perhaps like to see the documentation improved.  &quot;subsume&quot; and &quot;unify&quot; should be more clearly defined.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12486130" name="AVRO-816.patch" size="33375" author="joecrobak" created="Tue, 12 Jul 2011 01:36:47 +0000"/>
                            <attachment id="12485572" name="AVRO-816.patch" size="30295" author="joecrobak" created="Thu, 7 Jul 2011 11:24:10 +0000"/>
                            <attachment id="12485089" name="AVRO-816.patch" size="28825" author="joecrobak" created="Sun, 3 Jul 2011 14:44:07 +0000"/>
                            <attachment id="12484898" name="AVRO-816.patch" size="9904" author="joecrobak" created="Fri, 1 Jul 2011 16:28:44 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 1 Jul 2011 16:51:26 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>63977</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 51 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0e2n3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>80190</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Implemented Schema#isSuperset, Schema#unify, and a Tool for generating unified Schemas from avro data files.</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                </customfields>
    </item>


<item>
            <title>[AVRO-817] Add __version__ to avro/__init__.py</title>
                <link>https://issues.apache.org/jira/browse/AVRO-817</link>
                <project id="12310911" key="AVRO">Apache Avro</project>
                    <description>&lt;p&gt;Currently, there is no way to know which version of avro is installed on my machine. Add a _&lt;em&gt;version&lt;/em&gt;_ string to avro/_&lt;em&gt;init&lt;/em&gt;_.py&lt;/p&gt;</description>
                <environment></environment>
        <key id="12506447">AVRO-817</key>
            <summary>Add __version__ to avro/__init__.py</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21140&amp;avatarType=issuetype">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="miki">Miki Tebeka</assignee>
                                    <reporter username="miki">Miki Tebeka</reporter>
                        <labels>
                    </labels>
                <created>Fri, 6 May 2011 19:26:58 +0000</created>
                <updated>Tue, 31 May 2011 17:13:22 +0000</updated>
                                            <version>1.5.1</version>
                                                    <component>python</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>2</watches>
                                    <timeoriginalestimate seconds="600">10m</timeoriginalestimate>
                            <timeestimate seconds="600">10m</timeestimate>
                                        <comments>
                            <comment id="13030104" author="miki" created="Fri, 6 May 2011 19:30:47 +0000"  >&lt;p&gt;Patch for adding _&lt;em&gt;version&lt;/em&gt;_&lt;/p&gt;</comment>
                            <comment id="13030146" author="cutting" created="Fri, 6 May 2011 21:21:17 +0000"  >&lt;p&gt;It would be nice if we didn&apos;t have to update this by hand with each release.  The single place we&apos;d like to update is share/VERSION.txt.  The lang/py/build.xml currently replaces the @VERSION@ in setup.py with the contents of share/VERSION.txt.  Could we get the version for _&lt;em&gt;init&lt;/em&gt;_.py from either setup.py or via replacement as with setup.py?&lt;/p&gt;</comment>
                            <comment id="13030150" author="philip" created="Fri, 6 May 2011 21:31:34 +0000"  >&lt;p&gt;That approach is a bit of an anti-pattern: you want to be able to point your python path towards the python directory; replacing stuff at build-time is very uncommon in python-land.&lt;/p&gt;</comment>
                            <comment id="13030162" author="scott_carey" created="Fri, 6 May 2011 21:58:44 +0000"  >&lt;p&gt;The top level project pom can run an ant task to change it at branch time, and/or to validate that it matches during &apos;dist&apos;.  &lt;br/&gt;
We could have an action that changes VERSION.txt and anything else required at once. &lt;/p&gt;</comment>
                            <comment id="13041096" author="jkoshy" created="Mon, 30 May 2011 11:42:42 +0000"  >&lt;p&gt;The methodology used in the patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/AVRO-831&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;AVRO-831&lt;/a&gt; could be used to patch &lt;tt&gt;&amp;#95;&amp;#95;init__.py&lt;/tt&gt;, adding in a version number at build time.&lt;/p&gt;</comment>
                            <comment id="13041682" author="tebeka" created="Tue, 31 May 2011 17:13:22 +0000"  >&lt;p&gt;Auto generating version with ant&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12508560">AVRO-831</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12480964" name="version.patch" size="983" author="tebeka" created="Tue, 31 May 2011 17:13:22 +0000"/>
                            <attachment id="12478462" name="version.patch" size="269" author="miki" created="Fri, 6 May 2011 19:30:47 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 6 May 2011 21:21:17 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>95008</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 34 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0e2nb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>80191</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>
